#	Zilch Screen Editor, Copyright (c) 1982,1983,1984 William P. Wood, Jr.

define(header,implicit integer (a-p,r-z); implicit logical (q)
include "memory.cmn"
include "session.cmn")

  function q_switch_to_buffer(na)
  header
  byte na(ARB)

  q_switch_to_buffer = true
  if (wi_buffer(se_current_window) != null) {
    bu_dot(wi_buffer(se_current_window)) = wi_dot(se_current_window)
    bu_bow(wi_buffer(se_current_window)) = wi_bow(se_current_window)
    }
  bu = bu_find_by_name(na)
  if (bu == null)
    bu = bu_new(na,EOS)
  wi_buffer(se_current_window) = bu
  wi_dot(se_current_window) = min(bu_dot(bu),bu_size(bu)+1)
  wi_set_bow(se_current_window,find_bol(bu,bu_bow(bu)))
  wi_map(se_windows,wi)
    if (wi != se_current_window & wi_buffer(wi) == bu) {
      wi_dot(se_current_window) = wi_dot(wi)
      wi_set_bow(se_current_window,wi_bow(wi))
      break
      }
  wi_mode_line(se_current_window) = bu_name(bu)
  return
  end

  function q_pop_to_buffer(na)
  header
  byte na(ARB)

  if (q_pop_up_window())
    return(q_switch_to_buffer(na))
  call ms_error("Can't make a new window!")
  return(false)
  end

  function q_visit_file(na,switch_buffer,nf)
  header
  byte na(ARB)
  logical switch_buffer

  bu = bu_find_by_file_name(na)
  if (bu == null) {
    bu = bu_new(EOS,na)
    if (! q_fi_read_file(bu,st_buffer(bu_file_name(bu)),'C',true))
      call ms_message2("New file: ",bu_file_name(bu))
    }
  if (switch_buffer)
    return(q_switch_to_buffer(st_buffer(bu_name(bu))))
  else if (nf == 1)
    if (q_pop_up_window())
      return(q_switch_to_buffer(st_buffer(bu_name(bu))))
  call pa_generate(pa_number(se_current_page))
  call delete_other_windows
  return(q_switch_to_buffer(st_buffer(bu_name(bu))))
  end

  subroutine multi_visit_file(na,switch_buffer,clear_context)
  header
  byte na(ARB)
  logical switch_buffer, clear_context

  fi = st_allocate(FILENAMESIZE)
  st = st_allocate(max(MAX_COMMAND,MAX_PROMPT))
  st1 = st_allocate(max(MAX_COMMAND,MAX_PROMPT))
  pa = se_current_page
  totfiles = 0
  while (q_co_parse(na, st_buffer(st1), false)) {
    nfile = 0
    while (q_co_parse(st_buffer(st1), st_buffer(st), true)) {
      n = 0
      if (q_fi_find_file(FIND_UNIT,st_buffer(st),st_buffer(fi),n,true,
				totfiles == 0 & clear_context)) {
	repeat {
	  nfile = nfile + 1
	  totfiles = totfiles + 1
	  call q_visit_file(st_buffer(fi),switch_buffer & totfiles == 1,nfile)
	  } until(! q_fi_find_file(FIND_UNIT,st_buffer(st),st_buffer(fi),n,
					true,false))
	}
      else
	call ms_error("Bad file name encountered!")
      }
    if (se_current_page != pa) {
      call ms_message("Some files windowed on succeeding pages.")
      call pa_switch(pa_number(pa))
      }
    }
  call st_deallocate(fi)
  call st_deallocate(st)
  call st_deallocate(st1)
  return
  end

  function q_bu_find_window(na)
  header
  byte na(ARB)

  bu = bu_find_by_name(na)
  if (bu == null)
    return(q_pop_to_buffer(na))
  bu_map_windows(bu,wi) {
    while (wi != se_current_window)
      call next_window
    return(true)
    }
  return(q_pop_to_buffer(na))
  end

  function q_bu_pop_up_message(msg, mlen, na)
  header
  byte msg(ARB), na(ARB)
  logical all_blank

  q_bu_pop_up_message = false
  wi = se_current_window
  size = wi_size(wi)
  if (! q_pop_up_window())
    return
  wi_size(wi) = max(1, size - 2)
  wi_size(se_current_window) = 1
  bu = bu_new(na, EOS)
  if (q_switch_to_buffer(st_buffer(bu_name(bu)))) {
    q_bu_pop_up_message = true
    all_blank = true
    nlines = 1
    for (i = 1; i <= mlen; i = i + 1) {
      if (msg(i) == CR)
	if (i < mlen) {
	  if (msg(i+1) == LF)
	    next
	  }
	else {
	  call insert_character(NEWLINE)
	  next
	  }
      if (msg(i) == LF) {
	call insert_character(NEWLINE)
	if (i < mlen & ! all_blank)
	  nlines = nlines + 1
	}
      else {
	if (all_blank) {
	  call line_to_top_of_window
	  all_blank = false
	  }
	call insert_character(msg(i))
	}
      }
    wi_dot(se_current_window) = wi_bow(se_current_window)
    bu_modified(se_current_buffer) = 0
    size = wi_size(wi)
    wi_size(wi) = max(1, wi_size(wi) - nlines + 1)
    wi_size(se_current_window) = wi_size(se_current_window) +
							size - wi_size(wi)
    call wi_fill
    while (se_current_window != wi)
      call next_window
    }
  return
  end

  function bu_find_by_file_name(na)
  header
  byte na(ARB)

  bu_map(se_buffers,bu)
    if (bu_file_name(bu) != null)
      if (q_ho_equal(st_buffer(bu_file_name(bu)), na))
	return(bu)
  return(null)
  end

  function bu_find_by_name(na)
  header
  byte na(ARB)

  bu_map(se_buffers,bu)
    if (bu_name(bu) != null)
      if (q_ho_equal(st_buffer(bu_name(bu)), na))
	return(bu)
  return(null)
  end

  function bu_new(name, fname)
  header
  byte name(ARB), fname(ARB)

  bu_new = me_allocate(bu_sizeof)
  for ([p = null; bu = se_buffers]; bu != null; [p = bu; bu = bu_next(bu)])
    ;
  if (p == null)
    se_buffers = bu_new
  else
    bu_next(p) = bu_new
  bu_size(bu_new) = 0
  bu_gap(bu_new) = null
  bu_gap_size(bu_new) = 0
  bu_base(bu_new) = null - 1
  bu_modified(bu_new) = 0
  bu_mark1(bu_new) = 0
  bu_mark2(bu_new) = 0
  bu_save_dot(bu_new) = 1
  bu_save_bow(bu_new) = 1
  bu_next(bu_new) = null
  bu_dot(bu_new) = 1
  bu_bow(bu_new) = 1
  bu_mappings(bu_new) = null
  bu_indent(bu_new) = 1
  bu_type(bu_new) = 0
  bu_case(bu_new) = se_default_case
  bu_protection(bu_new) = -1
  bu_name(bu_new) = null
  bu_file_name(bu_new) = null
  call bu_new_names(bu_new,name,fname)
  call tx_more_memory_please(bu_new,0)
  return
  end

  subroutine bu_new_names(bu,name,fname)
  header
  byte name(ARB), fname(ARB), num(14), ho_clower

  old = bu_name(bu)
  bu_name(bu) = null
  call st_deallocate(bu_file_name(bu))
  if (name(1) != EOS) {
    st = st_allocate(ho_length(name)+1)
    call ho_scopy(name, 1, st_buffer(st), 1)
    for (i = st; st_buffer(i) != EOS; i = i+1)
      st_buffer(i) = ho_clower(st_buffer(i))
    }
  else
    st = bu_make_name(fname)
  if (fname(1) != EOS) {
    bu_file_name(bu) = st_allocate(ho_length(fname)+1)
    call ho_scopy(fname, 1, st_buffer(bu_file_name(bu)), 1)
    }
  else
    bu_file_name(bu) = null
  sl = st_length(st)
  for (n = 2; bu_find_by_name(st_buffer(st)) != null; n = n+1) {
    nl = ho_itoc(n,num(2),12)
    num(1) = '<'
    num(2+nl) = '>'
    num(3+nl) = EOS
    st2 = st_allocate(3+nl+sl)
    call st_scopy(st,st2)
    call ho_scopy(num,1,st_buffer(st2+sl),1)
    call st_deallocate(st)
    st = st2
    }
  bu_name(bu) = st
  if (old != null) {				# update old pointers
    call pa_switch(pa_number(se_current_page))	# force page update
    pa_map(se_pages,pa)
      wi_map(pa_windows(pa),wi)
	if (wi_mode_line(wi) == old)
	  wi_mode_line(wi) = bu_name(bu)
    call st_deallocate(old)
    }
  call mp_set_mappings(bu,0)
  return
  end

  function bu_make_name(file)
  header
  byte file(ARB)

  i = max(ho_indexq(file, ']'), ho_indexq(file, '>'))
  if (i == 0) {
    repeat {
      j = ho_indexq(file(i+1), ':')
      i = i + j
      } until (j == 0)
    }
  i = i+1
  k = ho_length(file)+1
  bu_make_name = st_allocate(k - i + 1)
  for (j = i ; j <= k; j = j+1)
    st_buffer(bu_make_name + j - i) = file(j)
  return
  end

  subroutine bu_clear_text(bu)
  header

  call tx_delete(bu, 1, bu_size(bu))
  bu_modified(bu) = 0
  if (bu_gap_size(bu) > 0)
    call tx_more_memory_please(bu,0)
  bu_dot(bu) = 1
  bu_bow(bu) = 1
  return
  end

  function q_buffer_list
  header
  include "screen.cmn"
  logical do_files
  string head "  Name@t@t@tSize    Page    Filename@l@l", num(9) " "

  q_buffer_list = true
  call pa_switch(-1)
  call q_switch_to_buffer("Buffer list")
  call delete_other_windows
  call bu_clear_text(se_current_buffer)
  call insert_string(head)
  do_files = true
  repeat {
    bu_map(se_buffers,bu) {
      if (do_files .xor. (bu_file_name(bu) == null)) { # do files, then buffers
	if (bu != se_current_buffer & bu_modified(bu))
	  call insert_string('M ')
	else
	  call insert_string('  ')
	curcol = 3
	if (bu_name(bu) != null) {
	  call insert_string(st_buffer(bu_name(bu)))
	  curcol = curcol + ho_length(st_buffer(bu_name(bu)))
	  }
	if (bu == se_current_buffer)
	  nlen = ho_itoc(0,num,9)
	else
	  nlen = ho_itoc(bu_size(bu),num,9)
	if (curcol + 1 + nlen > 29)
	  call insert_character(NEWLINE)
	call tab_to_column(29 - nlen)
	call insert_string(num)
	call bu_list_page(bu)
	if (bu_file_name(bu) != null) {
	  flen = st_length(bu_file_name(bu))
	  if (41 + flen > sc_width) {
	    call insert_character(NEWLINE)
	    call tab_to_column(max(1, int((sc_width - flen - 1)/8)*8 + 1))
	    }
	  else
	    call tab_to_column(41)
	  call insert_string(st_buffer(bu_file_name(bu)))
	  }
	call insert_character(NEWLINE)
	}
      }
    do_files = ! do_files
    } until (do_files)				# do files, then buffers
  wi_dot(se_current_window) = 1
  bu_modified(se_current_buffer) = 0
  call ms_message("Type carriage-return to exit Buffer list.")
  return
  end

  subroutine bu_list_page(bu)
  header
  byte num(9)

  pa = se_current_page
  wi_map(se_windows,wi)
    if (wi_buffer(wi) == bu)
      goto 10
  pa_map(se_pages,pa)
    if (pa != se_current_page)
      wi_map(pa_windows(pa),wi)
	if (wi_buffer(wi) == bu)
	  goto 10
  return
10
  call ho_itocrj(pa_number(pa),num,9)
  call insert_string(num)
  if (wi == se_current_window)
    call insert_character('*')
  return
  end

  subroutine bu_switch_case
  header

  bu_case(se_current_buffer) = 1 - bu_case(se_current_buffer)
  if (bu_case(se_current_buffer) == 1)
    call ms_message("Buffer is now in upper case mode.")
  else
    call ms_message("Buffer is now in lower/upper case mode.")
  return
  end
