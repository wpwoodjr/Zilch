# Zilch Screen Editor, Copyright (c) 1982,1983,1984,1986 William P. Wood, Jr.

define(header,implicit integer (a-p,r-z); implicit logical (q)
  include "session.cmn"
  include "memory.cmn")

  subroutine case_change
  header

  bu = se_current_buffer
  if (bu_mark1(bu) != 0 & bu_mark2(bu) != 0) {
    m1 = min(bu_mark1(bu), bu_size(bu)+1)
    m2 = min(bu_mark2(bu), bu_size(bu)+1)
    call tx_case_change(bu, min(m1, m2), max(m1, m2) - 1)
    }
  else
    call ms_error("Both marks must be set!")
  return
  end

  subroutine save_text
  header

  bu = se_current_buffer
  if (bu_mark1(bu) != 0 & bu_mark2(bu) != 0) {
    m1 = min(bu_mark1(bu), bu_size(bu)+1)
    m2 = min(bu_mark2(bu), bu_size(bu)+1)
    if (q_copy_region_to_buffer("Save", m1, m2))
      call ms_report_number2("Saved ", abs(m1 - m2),
	  " character.", " characters.")
    }
  else
    call ms_error("Both marks must be set!")
  return
  end

  subroutine extract_text
  header

  bu = se_current_buffer
  if (bu_mark1(bu) != 0 & bu_mark2(bu) != 0) {
    bu_mark1(bu) = min(bu_mark1(bu), bu_size(bu)+1)
    bu_mark2(bu) = min(bu_mark2(bu), bu_size(bu)+1)
    call delete_region_to_buffer("Save", bu_mark1(bu), bu_mark2(bu))
    call ms_report_number2("Extracted ", abs(bu_mark1(bu) - bu_mark2(bu)),
						" character.", " characters.")
    bu_mark1(bu) = 0
    bu_mark2(bu) = 0
    }
  else
    call ms_error("Both marks must be set!")
  return
  end

  subroutine delete_text
  header

  bu = se_current_buffer
  if (bu_mark1(bu) != 0 & bu_mark2(bu) != 0) {
    bu_mark1(bu) = min(bu_mark1(bu), bu_size(bu)+1)
    bu_mark2(bu) = min(bu_mark2(bu), bu_size(bu)+1)
    call delete_region(bu_mark1(bu), bu_mark2(bu))
    call ms_report_number2("Deleted ", abs(bu_mark1(bu) - bu_mark2(bu)),
						" character.", " characters.")
    bu_mark1(bu) = 0
    bu_mark2(bu) = 0
    }
  else
    call ms_error("Both marks must be set!")
  return
  end

  subroutine add_text_after_cursor
  header

  bu_mark1(se_current_buffer) = wi_dot(se_current_window)
  call yank_buffer("Save")
  bu_mark2(se_current_buffer) = wi_dot(se_current_window)
  wi_dot(se_current_window) = bu_mark1(se_current_buffer)
  return
  end

  subroutine add_text_before_cursor
  header

  bu_mark1(se_current_buffer) = wi_dot(se_current_window)
  call yank_buffer("Save")
  bu_mark2(se_current_buffer) = wi_dot(se_current_window)
  return
  end

  subroutine save_location
  header

  bu_save_dot(se_current_buffer) = wi_dot(se_current_window)
  bu_save_bow(se_current_buffer) = wi_bow(se_current_window)
  call ms_message("Current location saved.")
  return
  end

  subroutine exchange_dot_and_save_location
  header

  td = wi_dot(se_current_window)
  tb = wi_bow(se_current_window)
  wi_dot(se_current_window) = min(bu_size(se_current_buffer)+1,
	bu_save_dot(se_current_buffer))
  wi_set_bow(se_current_window,
	find_bol(se_current_buffer,bu_save_bow(se_current_buffer)))
  bu_save_dot(se_current_buffer) = td
  bu_save_bow(se_current_buffer) = tb
  return
  end

  subroutine goto_save_location
  header

  wi_dot(se_current_window) = min(bu_size(se_current_buffer)+1,
	bu_save_dot(se_current_buffer))
  wi_set_bow(se_current_window,
	find_bol(se_current_buffer,bu_save_bow(se_current_buffer)))
  return
  end

  subroutine write_text
  header

  bu = se_current_buffer
  if (bu_mark1(bu) != 0 & bu_mark2(bu) != 0) {
    st = st_allocate(MAX_PROMPT)
    if (q_pr_read_prompt("Print file (eg. LP:FILE.DAT, or RETURN for local): ",
	  st,len)) {
      m1 = min(bu_mark1(bu), bu_size(bu)+1)
      m2 = min(bu_mark2(bu), bu_size(bu)+1)
      if (len == 0) {
	call ho_scopy("SYS$COMMAND", 1, st_buffer(st), 1)
	call te_printer_on
	call ti_flush
	}
      if (q_fi_write_region(bu,st_buffer(st),min(m1,m2),max(m1,m2)-1,'N',stat)) {
	if (len > 0) {
	  call ms_message("Wrote ")
	  call ms_add_to_message(st_buffer(st))
	  }
	}
      else {
	call ms_message2("Can't write ",st)
	call ms_error(EOS)
	}
      if (len == 0) {
	call te_printer_off
	call ti_flush
	call redraw
	}
      }
    call st_deallocate(st)
    }
  else
    call ms_error("Both marks must be set!")
  return
  end
