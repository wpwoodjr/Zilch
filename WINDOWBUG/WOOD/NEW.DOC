I have made a number of changes in Zilch recently. These are:

  1) The scroll functions, ^J and ^K, now leave the cursor where it was
	before the scroll.

  2) A switch, /INDent=n, has been added to enable use of indents
	other than the default of 2.

  3) Other screen programs which don't clean their tub before using it
	will now work properly in DCL mode as well as after exiting Zilch.

  4) Page placement of windows may be controlled when Zilching multiple files
	or when WV or WC-ing multiple files. For example:

	Z a b c		! zilch a b and c, placing them all on page 0
	Z a,b,c		! zilch a, b, and c, placing them on succeeding pages

	WV a b c	! window visit a b and c, placing them on the current
			! page
	WV a,b,c	! window visit a, b, and c, placing "a" on the current
			! page, and b and c on their own pages

	WC a b c	! window change to a b and c, placing them on the
			! current page
	WC a,b,c	! window change to a, b, and c, placing "a" on the
			! current page, and b and c on their own pages

  5) Zilch now always reads and writes network files correctly.

  6) A prompt to the terminal can be made from a mapping sequence by
	enclosing the prompt within ^P's in the sequence.
	For example, the following "IF" mapping prompts <condition>:

		i	if (^P<condition>^P^[0+

* 7) THE FOLLOWING FUNCTION WAS EXPUNGED ON OCT 30, 1986; it is
     unneccesary with new macro capabilities:
	The special ^Fx command is useful for keyboards with definable
	keys. First it takes you out of insert mode if you are in it,
	then it reads the following command string, and pushes it back
	on the input buffer as many times as are specified by the current
	repeat count. The command string must be enclosed by a character
	which is not itself in the command string. For instance, to define
	the REMOVE key on the Rainbow to delete the last word, define it as:

		^Fx">o<^D"

	The advantage of using ^Fx is that commands may be repeated,
	no screen update is done until the command is finished, and
	errors in the command cause the rest of the command string
	to be flushed.
	Please try it and let me know if you like it - I'm a bit
	ambivalent about it.

* 8) The "," and "." keys now act like the "<" and ">" keys respectively.
	This is because some idiot decided that the Rainbow should have the
	"<" and ">" keys on the left side of the keyboard, driving me
	absolutely nuts.
	The "," and "." keys are the unshifted "<" and ">" keys.

* 9) The DELETE key in command mode deletes the previous character
	and enters insert mode.

*10) A new switch, /CRoss_lines, determines whether or not the cursor
	crosses line boundaries on  DELETE and WORD MOVEMENT commands.
	The default is no line crossing.

*11) THE FOLLOWING FUNCTION WAS REMOVED OCT 30, 1986; it was useless:
	Jump mode search - @ key in standard Zilch

*12) The update routine doesn't update the screen as often when you are
	typing fast.

*13) Zilch uses the operating system's terminal width to determine
	the screen width unless the /WIDTH qualifier is specified
	on Zilch's command line. Also the screen width is reset upon
	exiting Zilch if changed by the /WIDTH qualifier.

*14) New non-standard Zilch functions
	self_insert
	newline				# now used by OVERSTRIKE
	open_line
	delete_previous_character	# now used by OVERSTRIKE
	delete_next_character
	kill_to_end_of_line
	goto_end_of_file
	beginning_of_line
	end_of_line
	illegal_operation
	null_operation

*15) The DCL function doesn't delete the created subprocess when you logoff
	the subprocess. Zilch redefines LO*GOFF to be ATTACH "process name"
	in the subprocess,
	where "process name" is the name of the parent process in double
	quotes. Then when you enter DCL again, Zilch tries to reattach to the
	subprocess instead of creating a new one. The subprocess is deleted
	when you exit Zilch unless you CONTROL-Y out of Zilch.

*16) An ^@ in a macro causes the prompt routine to read from the terminal.

*17) Mailbox for broadcasts, checkpoints and saves session on disconnect.

*18) Can now restore with a different width eg. z/wid=132


From:	WOOD            2-MAR-1984 09:41  
To:	@ZILCH.DIS
Subj:	New zilch features

Following are several new Zilch features:


	1) The arrow keys move the cursor appropriately.
	2) PF1 does a search-again-reverse (ie. \<CR>)
	3) PF2 does a search-again-forward (ie. /<CR>)
	4) PF3 deletes the previous word
	5) PF4 deletes the next word
	6) Keypad - deletes the next character
		(that's the minus key on the keypad)
	6.5) Keypad comma deletes to the end of the line, saving the
		deleted text in the kill (^R) buffer.
	7) The accent (`) key enters and exits insert mode. This is useful
		on the PC, where the Escape key is hard to reach for former
		VT100 users. Also, on the VT240 in VT200 mode, the only way
		to generate an Escape is <CONTROL>3.
		To insert a literal accent, type a backslash before the accent.
		(The escape key still enters and exits insert mode.)
	8) Zilch is much faster over the network now do to an optimization
		in the character read routine.
	9) Coming soon - 10 definable keypad macros.

This new version may be present only on V07 for a few days for testing. Please
send me any comments you have. I am particularly interested in the following
things:

	1) Do you like the new delete keys to leave you in Insert mode
		even though you may have started in Control mode?
	2) Do you like the new search keys to leave you in control mode
		even though you may have started in Insert mode?
	3) What functions should the keypad comma and keypad ENTER keys
		perform? (0-9 and keypad dot will be used by the keyboard
		macros)?
	4) Can I expunge the type-ahead macro facility (ie. ^Fx) when keypad
		macros come out (you will be able to initialize them at
		startup as well as define them as interactive keyboard macros)
	5) Are there any problems with the new version?

Thanks!

July 14, 1986:

Well, its been 2 years almost to the day (July 12, 1984) since I released
a new version of Zilch.  I am releasing one today which is significant
because you can now use the ARROW keys and the keypad without getting glitches
in your document.  As a reminder, here are the definitions of the arrow
and keypad keys:

	1) The arrow keys move the cursor appropriately.
	2) PF1 does a search-again-reverse (ie. \<CR>)
	3) PF2 does a search-again-forward (ie. /<CR>)
	4) PF3 deletes the previous word
	5) PF4 deletes the next word
	6) Keypad "," (comma) deletes the next character
	6.5) Keypad "-" (minus) deletes to the end of the line, saving the
		deleted text in the kill (^R) buffer.
	7) The accent (`) key enters and exits insert mode. This is useful
		on the PC, where the Escape key is hard to reach for former
		VT100 users. Also, on the VT240 in VT200 mode, the only way
		to generate an Escape is <CONTROL>3.
		To insert a literal accent, type a backslash before the accent.
		(The escape key still enters and exits insert mode.)
	9) Coming soon - 10 definable keypad macros.

- Bill

28-Jul-1986:
	1) indent works better, esp for fortran - can't indent < col 7,
	2) next and previous procedure works better - "end !" works

20-Oct-1986
	1) attach back to Zilch after DCL uses /ID=xxxxxxxx instead
		of attach process_name
	2) added 52 line support
	3) Zilch now uses terminal page size for default screen length, eg.
		$ set ter/page=52
	   causes Zilch to use a screen size of 52, unless overridden
	   by the /len switch or by a restore of an old session.
	4) protection on .ZIL files is now SY:RWED,OW:RWED,GR,WO:D

23-Oct-1986
	1) defaults carry through from one file to the next during
		visit files and on the command line, eg:

		$ zilch x.dat y
	   or

		wv x.dat y

	   both load in x.dat and y.dat

28-Oct-1986
	^P writes marked region to a local printer, regular printer,
	or a file.  ^C cancels the printout if it's to a local printer.

29-Oct-1986
	WL shows files before buffers  (also, from before, has nicer looking
		output)
	Zilch does not warn about modified buffers without file names
		(ie. buffers not associated with a file)
		before exiting, as it used to, unless you are in a window
		on a modified buffer.  Then it asks "Save file [y]?"
		This makes it convenient to use buffers for scratch storage.

??-Oct-1986
	~ puts you into a new mode, OVERSTRIKE mode, in which typed
	characters replace previous characters.  OVERSTRIKE is smart about
	writing over and adding TABS.
	The arrows work in OVERSTRIKE mode, also ^H, ^J, ^K, ^L, DEL,
	PF1, PF2, PF3, PF4, -, and . keys.
	INSERT HERE switches to insert and back again.
	Use `, ESC, or ^Z to exit OVERSTRIKE.

Nov 3, 1986
	The W# command sets the size below which a window will not be pushed
	by size changes in other windows.
	This command causes an incompatibility between new Zilch save files
	and old ones, so that new save files may not be used with old versions
	of Zilch.

	The WS (window shrink) and WE (window enlarge) commands do not produce
	an error beep when they cannot shrink or expand the window.
	This means they can be used in macros without terminating the macro
	because of an error status.

	New algorithm for computing screen update's output buffer size.
	Also, X# displays selected buffer size. It takes awhile for Zilch to
	select the buffer size.

Nov 10, 1986
	You can now enter any character during a prompt by typing a \ followed
	by the octal value of the desired character, eg. \377 or \177, etc.
	The display changes as you type in the octal value to reflect the
	value as computed to that point.  For instance, as you type \177,
	the display shows nothing after the \, then ^A after \1, then ^O
	after \17, then finally \177.

Nov 11, 1986
	new command line switch:

	  /word=characters

	lets you define your own set of characters which define what a
	word is for word movement commands, for example:

	  z/word="A-Za-z0-9"

	is the old default and specifies capital and little letters and 0
	through 9 as word characters.
	The ascii value of a character may be entered as an octal
	number after a backslash, for example:

	  z/word="\0-\177"

	defines every character from NUL to DEL as a word character.

	  z/word="a"""

	defines " and little a as word characters.

	  z/word="A-Za-z0-9,)"

	defines two classes of word characters, one is A-Za-z0-9 and the
	other is )   (the comma separates the classes.  For a literal
	comma, use "\," )
	At this time, 9 word classes may be defined by the user.

NEXT_WORD and PREVIOUS_WORD work by first scanning over characters that aren't
in any class, then determining a class to use based on the character
which stopped the scan, then scanning over characters in that class.
Class 0 is special.  It contains, for each character, the number of the
class that the character is in, and 0 if the character is not in a class.
In fact, a character may be in more than one class, but it's PRIMARY
class is the one indicated by Class 0;  when NEXT_WORD and PREVIOUS_WORD
check what class a character is in, they check Class 0.  If a character
is in a class that is not it's primary class, then it cannot be used
to start a scan in that class, but once a scan is started, it will be
scanned over.  It is possible for a character to have a secondary class
but not a primary class, in which case it can participate in scans but
never start one, since its primary class is class 0.
For example, the following class definitions scan over numbers, words,
and right parentheses, and are currently the default:

	z/word="A-Za-z~0-9,0-9~.A-Za-z,)"

The first class definition is "A-Za-z~0-9".  That means that A through Z and
little a through little z are primary class members, while 0-9 are secondary
class members. The ~ (tilde) separates the primary and secondary class
members.  This class scans over words beginning with A-Z or a-z until
encountering a character which is not A-Z, a-z, or 0-9.
The second class definition is "0-9~.A-Za-z".  It is separated from the
first class definition by a comma.  This class scans over numbers
beginning with 0-9 until encountering a character which is not a period,
A-Z, or a-z.  Note that period is not a primary member in any class,
but is a secondary member of the second class.  This means that it cannot
start a scan, but can be scanned over in a number starting with 0-9.
The third class contains only right parenthesis.

Nov 11, 1986
	The = command may now be used in CHANGE mode to cause a return
	to the current location when change mode is exited, instead of
	returning to where you were when the CHANGE command was started.

Nov 12, 1986
	Keyboard macros

Nov 13, 1986
	Can stop defining a macro in insert mode or overstrike mode
	  with ^]
	Can call macros from within other macros.
	Can write (XW) and get (XG) macros.
	Can specify a file of macros to be read on the command line:
		$ z/macros=file
	The macros in this file are overridden by restored macros.
	By default, macros are read/written to sys$login:zilch.macros
	  if the macro file is not specified on the command line.

*** ICR version Nov 13, 1986 ***

Nov 17, 1986
	Line editing of prompts:
	  insert mode only; no overstrike; ^A recalls save buffer instead
	  no delete previous word; ^J is NEWLINE character for Zilch
	    pr_kill_to_beginning_of_line	^U
	    pr_delete_previous_character	DEL
	    pr_previous_line			^B, up arrow
	    pr_next_line			down arrow
	    pr_previous_character		^D, left arrow
	    pr_next_character			^F, right arrow
	    pr_end_of_line			^E
	    pr_beginning_of_line		^H, F12
	    pr_add_text_before_cursor		^A (from save buffer)
	    pr_abort				^G
	    pr_special_character		\nnn, \@ = \0, \c = c

Nov 17, 1986
	! forces a checkpoint of modified files
	500! sets the checkpoint frequency to 500.  By default
	it is 400.

Nov 21, 1986
	% gives a display of your position in the window, the buffer status,
	and other stuff

Nov 22, 1986
	New qualifier, /RECOVER, causes Zilch to attempt to recover checkpoint
	file before reading actual file.
	Checkpointed file names are now of the form:

		name.extension_ckp

	unless a specific version of the file is being edited; then the
	checkpoint name is of the form:

		name.extension_ckp_version

	For example:

		NOTES.TXT_CKP		is the checkpoint file for NOTES.TXT
		NOTES.TXT_CKP_35	is the checkpoint file for NOTES.TXT;35

Dec 3, 1986
	A file is not read in until the page it is on is visited, leading
	to much faster response to commands like:

		$ zilch *.*;*
