$ create ALLOC.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1987 William P. Wood, Jr. */

#include <stdlib.h>
#include "symbols.h"
#include "memory.cmn"

intp me_allocate(int size)
{
  register intp ptr;
  register intp *mptr;

  mptr = malloc(size*CHARS_PER_INT);
  if (mptr != NULL) {
    if ((intp) mptr % CHARS_PER_INT != 0 || (intp) memory.me_memory %
							CHARS_PER_INT != 0) {
      printf("mptr or memory.me_memory not on intp boundary in me_allocate!\n");
      exit(EXIT_BAD);
      }
    ptr = ((intp) mptr - (intp) memory.me_memory)/CHARS_PER_INT;
    return ptr;
    }
  else {
    ti_kill();
    te_clear();
    te_finish();
    te_pos(1,1);
    send_message_to_terminal(
"Dynamic memory overflow! All modified file buffers are being checkpointed...");
    ti_finish();
    dcl_finish();
    checkpoint_modified_files();
    exit(EXIT_BAD);
    return null;
    }
}

void me_deallocate(intp ptr)
{
  if (ptr != null)
    free((void *) (ptr*CHARS_PER_INT + (intp) memory.me_memory));
}
$eod
$ create BIND.C
$deck
/*	Zilch Screen Editor
 *	Copyright (c) 1982,1983,1984,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "bind.cmn"
#include "tables.cmn"
#include "screen.cmn"

int bi_use_keymap(int mode)
{
  register int i;

  for (i = 0; i < NUM_MODES; ++i)
    if (bind.modes[i] == bind.mode)
      break;
  if (mode < 0 || mode >= NUM_MODES)
    goto L10;
  else if (bind.modes[mode] == null) {
L10:
    ms_report_number("Illegal mode: ", mode, "");
    ms_error("");
    }
  else
    bind.mode = bind.modes[mode];
  return i;
}

int bi_get_command(void)
{
  register int bi;
  register char c;
  int errmsglen, newerrmsglen;

  errmsglen = sc_new_length(sc_size);
  bi = bi_mem(ta_lower(get_tty_character()) + bind.mode);
  newerrmsglen = sc_new_length(sc_size);
  for ( ; bi > 0; bi = bi_mem(bi)) {
    sc_new_length(sc_size) = errmsglen;
    c = get_tty_character();
    while (bi_char(bi) != ta_lower(c) && bi_char(bi) != - c) {
      bi = bi_next(bi);
      if (bi == 0) {
	sc_new_length(sc_size) = newerrmsglen;
	return 0;
	}
      }
    }
  sc_new_length(sc_size) = newerrmsglen;
  return (-bi);
}

int bi_allocate(int n)
{
  register int i;

  if (bind.free + n - 1 > bind.bmax) {
    ms_error("Binding memory overflow!");
    return null;
    }
  else {
    for (i = bind.free; bind.free < i + n; )
      bi_mem(bind.free++) = null;
    return i;
    }
}

int bi_new(int k)
{
  register int bi;

  bi = bi_allocate(bi_sizeof);
  bi_next(bi) = 0;
  bi_char(bi) = ho_clower(k);
  bi_mem(bi) = 0;
  return bi;
}

int bi_make_bindings(int fnc, register const char *key)
{
  int bi, bitmp;

  bi = bitmp = bi_new(key[0]);
  for ( ; *++key != EOS; ) {
    bi_mem(bi) = bi_new(*key);
    bi = bi_mem(bi);
    }
  bi_mem(bi) = - fnc;
  return bitmp;
}

void bi_bind_to_key(int fnc, register const char *key)
{
  int bi, nxtchar, t;

  if (key[0] != EOS) {
    if (key[0] == bind.alternate_escape)
      if (key[1] != EOS)
	if (key[1] >= 0) {
	  bind.alternate_escape_followers[key[1]] = true;
	  bind.alternate_escape_followers[ho_clower(key[1])] = true;
	  }
	else
	  bind.alternate_escape_followers[- key[1]] = true;
    bi = ho_clower(*key++) + bind.mode;
    while (bi_mem(bi) > 0 && *key != EOS) {
      for (nxtchar = bi_mem(bi); nxtchar > 0; nxtchar = bi_next(nxtchar))
	if (bi_char(nxtchar) == ho_clower(*key)) {
	  bi = nxtchar;
	  goto L10;
	  }
      break;
L10:
      key++;
      }
    if (*key == EOS) {			/* found it */
      if (bi_mem(bi) <= 0)		/* don't overwrite longer binds */
	bi_mem(bi) = - fnc;
      }
    else {
      t = bi_make_bindings(fnc, key);
      bi_next(t) = max(0, bi_mem(bi));
      bi_mem(bi) = t;
      }
    }
}

int q_bi_in_mode(int mode)
{
  if (mode < 0 || mode >= NUM_MODES)
    return false;
  else if (bind.mode == bind.modes[mode])
    return true;
  else
    return false;
}
$eod
$ create BIND.CMN
$deck
/* this struct maps onto common block produced by makebind (hopefully) */

declare struct {
	short int
	  mode,
	  modes[NUM_MODES],
	  keypad,
	  macros[NUM_MACROS],
	  free,
	  bmax;
	char
	  alternate_escape,
	  filler,
	  alternate_escape_followers[128];
	short int
	  mem[1];
	} bind;
$eod
$ create BIND.H
$deck
#define NUM_MODES 10
#define NUM_MACROS 100
#define CONTROL_MODE 0
#define INSERT_MODE 1
#define OVERSTRIKE_MODE 2
#define PROMPT_MODE 3
#define CHANGE_MODE 4
#define SEQ_MODE 5
#define CALC_MODE 6
#define KEYPAD_NUMERIC 0
#define KEYPAD_APPLICATION 1

/* offset by 1 because if bi == 0, has special meaning - should modify makebind
   to put in filler at bi = 0 */
#define bi_mem(bi) bind.mem[(bi)-1]
#define bi_next(bi) bind.mem[(bi)]	/*1+(bi)]*/
#define bi_char(bi) bind.mem[1+(bi)]	/*2+(bi)]*/
#define bi_sizeof 3
$eod
$ create BUFFER.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1983,1984,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "memory.cmn"
#include "session.cmn"

int q_switch_to_buffer(register bufferp bu, const char *na)
{
  windowp wicur;
  register windowp wi, wi2;

  if (bu == null)
    bu = bu_find_by_name(na);
  if (bu == null)
    bu = bu_new(na,"");
  wi_switch_to_buffer(se_current_window, bu);
  wi_map(se_windows,wi) /* try to find another window onto bu to set dot from */
    if (wi != se_current_window && wi_parent_buffer(wi) == bu_parent(bu)) {
      wicur = wi_parent(se_current_window);
      wi_map_sub_windows(wi, wi2) {
	wi_dot(wicur) = wi_dot(wi2);
	wi_set_bow(wicur,wi_bow(wi2));
	if (wi2 == wi)
	  se_current_window = wicur;
	wicur = wi_sub_windows(wicur);
	}
      break;
      }
  return true;
}

int q_pop_to_buffer(bufferp bu, const char *na)
{
  if (q_pop_up_window())
    return q_switch_to_buffer(bu, na);
  ms_error("Can't make a new window!");
  return false;
}

int q_visit_file(const char *na, int switch_buffer, int nf)
{
  register bufferp bu;

  bu = bu_find_by_file_name(na);
  if (bu == null) {
    bu = bu_new("",na);
    if (se_recover)
      q_ch_recover(bu);
    }
  if (switch_buffer)
    return q_switch_to_buffer(bu, st_buffer(bu_name(bu)));
  else if (nf == 1)
    if (q_pop_up_window())
      return q_switch_to_buffer(bu, st_buffer(bu_name(bu)));
  pa_generate(pa_number(se_current_page));
  if (q_split_current_window())
    return q_switch_to_buffer(bu, st_buffer(bu_name(bu)));
  return false;
}

void multi_visit_file(const char *na, int switch_buffer, int clear_context)
{
  register stringp st, st1, fi;
  pagep pa;
  int totfiles, nfile, n;

  fi = st_allocate(FILENAMESIZE);
  st = st_allocate(max(MAX_COMMAND,MAX_PROMPT));
  st1 = st_allocate(max(MAX_COMMAND,MAX_PROMPT));
  pa = se_current_page;
  totfiles = 0;
  while (q_co_parse(na, st_buffer(st1), false)) {
    nfile = 0;
    while (q_co_parse(st_buffer(st1), st_buffer(st), true)) {
      n = 0;
      if (q_fi_find_file(FIND_UNIT,st_buffer(st),st_buffer(fi),n,true,
				totfiles == 0 && clear_context)) {
	do {
	  nfile = nfile + 1;
	  totfiles = totfiles + 1;
	  q_visit_file(st_buffer(fi), switch_buffer && totfiles == 1, nfile);
	  } while (q_fi_find_file(FIND_UNIT, st_buffer(st), st_buffer(fi), n,
					true, false));
	}
      else
	ms_error("Bad file name encountered!");
      }
    if (se_current_page != pa) {
      ms_message("Some files windowed on succeeding pages.");
      pa_switch(pa_number(pa));
      }
    }
  st_deallocate(fi);
  st_deallocate(st);
  st_deallocate(st1);
}

void bu_ready(register bufferp bu)
{
  register bufferp bu2;

  if (bu_modified(bu) == 2) {
    if (! q_mp_read_file(bu,st_buffer(bu_file_name(bu)),0,true))
      ms_message2("New file: ",bu_file_name(bu));
    bu_modified(bu) = 0;
    }
  bu_map_sub_buffers(bu, bu2)
    if (bu_gap(bu2) == null)
      tx_more_memory_please(bu2, 0);
}

int q_bu_find_window(const char *na)
{
  register bufferp bu;
  register windowp wi;

  bu = bu_find_by_name(na);
  if (bu == null)
    return q_pop_to_buffer(null, na);
  wi_map(se_windows, wi)
    if (wi_buffer(wi) == bu) {
      while (wi != se_current_window)
	next_window();
      return true;
      }
  return q_pop_to_buffer(bu, na);
}

int q_bu_pop_up_message(register const char *msg, int mlen, const char *na)
{
  int all_blank, size, nlines;
  register int i;
  register windowp wi;
  bufferp bu;

  wi = se_current_window;
  size = wi_size(wi);
  if (! q_pop_up_window())
    return false;
  wi_size(wi) = max(1, size - 2);
  wi_size(se_current_window) = 1;
  bu = bu_new(na, "");
  if (q_switch_to_buffer(bu, st_buffer(bu_name(bu)))) {
    all_blank = true;
    nlines = 1;
    for (i = 0; i < mlen; ++i) {
      if (msg[i] == CR)
	if (i < mlen-1) {
	  if (msg[i+1] == LF)
	    continue;
	  }
	else {
	  insert_character(NEWLINE);
	  continue;
	  }
      if (msg[i] == LF) {
	insert_character(NEWLINE);
	if (i < mlen-1 && ! all_blank)
	  nlines = nlines + 1;
	}
      else {
	if (all_blank) {
	  line_to_top_of_window();
	  all_blank = false;
	  }
	insert_character(msg[i]);
	}
      }
    wi_dot(se_current_window) = wi_bow(se_current_window);
    bu_modified(se_current_buffer) = 0;
    size = wi_size(wi);
    wi_size(wi) = max(1, wi_size(wi) - nlines + 1);
    wi_size(se_current_window) = wi_size(se_current_window) +
							size - wi_size(wi);
    wi_fill();
    while (wi != se_current_window)
      next_window();
    return true;
    }
  else
    return false;
}

bufferp bu_find_by_file_name(const char *na)
{
  register bufferp bu;

  bu_map(se_buffers,bu)
    if (bu_file_name(bu) != null)
      if (q_ho_equal(st_buffer(bu_file_name(bu)), na))
	return bu;
  return null;
}

bufferp bu_find_by_name(const char *na)
{
  register bufferp bu;

  bu_map(se_buffers,bu)
    if (bu_name(bu) != null)
      if (q_ho_equal(st_buffer(bu_name(bu)), na))
	return bu;
  return null;
}

bufferp bu_new(const char *name, const char *fname)
{
  register bufferp bu;
  static bufferp bu_last_buffer = null;

  bu = me_allocate(bu_sizeof);
  bu_parent(bu) = bu;
  bu_next(bu) = null;
  bu_sub_buffers(bu) = null;
  bu_name(bu) = null;
  bu_file_name(bu) = null;
  if (fname[0] != EOS)
    bu_modified(bu) = 2;			/* file, not read in yet */
  else
    bu_modified(bu) = 0;
  bu_type(bu) = 0;
  bu_mappings(bu) = null;
  bu_protection(bu) = -1;
  bu_indent(bu) = 1;
  bu_case(bu) = se_default_case;
  bu_windows(bu) = null;
  bu_size(bu) = 0;
  bu_base(bu) = null - 1;
  bu_gap(bu) = null;
  bu_gap_size(bu) = 0;
  bu_dot(bu) = 1;
  bu_bow(bu) = 1;
  bu_save_dot_ptr(bu) = mk_new(1);
  bu_save_bow_ptr(bu) = mk_new(1);
  bu_mark1_ptr(bu) = mk_new(0);
  bu_mark2_ptr(bu) = mk_new(0);
  bu_markers(bu) = null;
  bu_id(bu) = 0;
  bu_current(bu) = 1;
  if (name[0] != EOS || fname[0] != EOS) {	/* if not a sub-buffer... */
    if (bu_last_buffer == null)
      se_buffers = bu;
    else
      bu_next(bu_last_buffer) = bu;
    bu_last_buffer = bu;
    bu_new_names(bu, name, fname);
    }
  return bu;
}

bufferp bu_new_sub_buffer(bufferp parent, int id)
{
  register bufferp bu;

  bu = bu_new("", "");
  bu_parent(bu) = parent;
  bu_id(bu) = id;
  bu_current(bu) = 0;
  return bu;
}

/* Should deallocate unused space! */
bufferp bu_delete_sub_buffer(register bufferp bu)
{
  return bu_sub_buffers(bu);
}

void bu_new_names(register bufferp bu, const char *name, const char *fname)
{
  register windowp wi;
  char num[14];
  stringp old, st, st2;
  int sl, n, nl;

  old = bu_name(bu);
  bu_name(bu) = null;
  st_deallocate(bu_file_name(bu));
  if (name[0] != EOS) {
    st = st_allocate(ho_length(name)+1);
    ho_scopy(name, 1, st_buffer(st), 1);
    for (st2 = st; *st_buffer(st2) != EOS; st2++)
      *st_buffer(st2) = ho_clower(*st_buffer(st2));
    }
  else
    st = bu_make_name(fname);
  if (fname[0] != EOS) {
    bu_file_name(bu) = st_allocate(ho_length(fname)+1);
    ho_scopy(fname, 1, st_buffer(bu_file_name(bu)), 1);
    }
  else
    bu_file_name(bu) = null;
  sl = st_length(st);
  for (n = 2; bu_find_by_name(st_buffer(st)) != null; n++) {
    nl = ho_itoc(n, num + 1, 12);
    num[0] = '<';
    num[1+nl] = '>';
    num[2+nl] = EOS;
    st2 = st_allocate(3+nl+sl);
    st_scopy(st, st2);
    ho_scopy(num, 1, st_buffer(st2+sl), 1);
    st_deallocate(st);
    st = st2;
    }
  bu_name(bu) = st;
  if (old != null) {				/* update old pointers */
    bu_map_windows(bu, wi)
      if (wi_mode_line(wi) == old) {
	wi_mode_line(wi) = bu_name(bu);
	wi_modified(wi) = 1;
	}
    st_deallocate(old);
    }
  mp_set_mappings(bu, 0);
}

bufferp bu_make_name(const char *file)
{
  register int i, j, k;
  bufferp bu;

  i = 0;
  for (j = ho_nuqcp(file, 1); file[j-1] != EOS; j = ho_nuqcp(file, j+1))
    if (file[j-1] == ']' || file[j-1] == '>' || file[j-1] == ':')
      i = j;
  bu = st_allocate(j - i);
  i = i + 1;
  for (k = i; k <= j; k++)
    *st_buffer(bu + k - i) = file[k-1];
  return bu;
}

void bu_clear_text(register bufferp bu)
{
  register bufferp sb;
  textind save_dot, save_bow;

  bu_map_sub_buffers(bu, sb) {
    if (bu_modified(sb) != 2) {		/* don't mess with "unread file" buffers */
      save_dot = bu_save_dot(sb);	/* so that restores work properly */
      save_bow = bu_save_bow(sb);
      tx_delete(sb, 1, bu_size(sb));
      mk_set_mark(bu_mark1_ptr(sb), 0, sb);
      mk_set_mark(bu_mark2_ptr(sb), 0, sb);
      mk_set_mark(bu_save_dot_ptr(sb), save_dot, sb);
      mk_set_mark(bu_save_bow_ptr(sb), save_bow, sb);
      bu_dot(sb) = 1;
      bu_bow(sb) = 1;
      if (sb == bu)
	bu_current(sb) = 1;
      else
	bu_current(sb) = 0;
      }
    }
  if (mod(bu_modified(bu), 2) == 1)
    bu_modified(bu) = 0;
}

#include "screen.cmn"
int q_buffer_list(void)
{
  int flen, nlen, curcol, do_files;
  static const char head[] = "  Name\t\t\tSize    Page    Filename\n\n";
  char num[9];
  pagep pacurrent;
  register bufferp bu, bu2;

  pacurrent = se_current_page;
  pa_switch(-1);
  q_switch_to_buffer(null, "Buffer list");
  delete_other_windows();
  pa_update;
  bu_clear_text(se_current_buffer);
  mp_set_mappings(se_current_buffer, TEXT);
  insert_string(head);
  do_files = true;
  do {
    bu_map(se_buffers,bu) {
      if (do_files ^ (bu_file_name(bu) == null)) { /* do files, then buffers */
	bu_map_sub_buffers(bu,bu2) {
	  if (bu2 == bu_parent(bu)) {
	    if (bu_parent(bu2) != bu_parent(se_current_buffer) &&
		  mod(bu_modified(bu2),2) == 1)
	      insert_string("M ");
	    else
	      insert_string("  ");
	    curcol = 3;
	    if (bu_name(bu2) != null) {
	      insert_string(st_buffer(bu_name(bu2)));
	      curcol = curcol + ho_length(st_buffer(bu_name(bu2)));
	      }
	    }
	  else
	    curcol = 1;
	  if (bu2 == se_current_buffer || bu_modified(bu2) == 2) {
	    nlen = 0;
	    num[0] = EOS;
	    }
	  else
	    nlen = ho_itoc(bu_size(bu2),num,9);
	  if (curcol + 1 + nlen > 29)
	    insert_character(NEWLINE);
	  tab_to_column(29 - nlen);
	  insert_string(num);
	  if (bu2 == bu_parent(bu)) {
	    bu_list_page(bu2,pacurrent);
	    if (bu_file_name(bu2) != null) {
	      flen = st_length(bu_file_name(bu2));
	      if (41 + flen > sc_width) {
		insert_character(NEWLINE);
		tab_to_column(max(5, ((int)(sc_width - flen - 1)/8)*8 + 1));
		}
	      else
		tab_to_column(41);
	      insert_string(st_buffer(bu_file_name(bu2)));
	      }
	    }
	  insert_character(NEWLINE);
	  }
	}
      }
    do_files = ! do_files;
    } while (! do_files);			/* do files, then buffers */
  wi_dot(se_current_window) = 1;
  bu_modified(se_current_buffer) = 0;
  ms_message("Type carriage-return to exit Buffer list.");
  return true;
}

void bu_list_page(register bufferp bu, pagep pacurrent)
{
  register pagep pa;
  register windowp wi;
  char num[9];

  pa = pacurrent;
  wi_map(pa_windows(pa),wi)
    if (wi_parent_buffer(wi) == bu_parent(bu))
      goto L10;
  pa_map(se_pages, pa)
    if (pa != pacurrent)
      wi_map(pa_windows(pa), wi)
	if (wi_parent_buffer(wi) == bu_parent(bu))
	  goto L10;
  return;
L10:
  ho_itocrj(pa_number(pa),num,9);
  insert_string(num);
  if (wi == pa_current_window(pacurrent))
    insert_character('*');
}

void bu_switch_case(void)
{
  bu_case(se_current_buffer) = 1 - bu_case(se_current_buffer);
  if (bu_case(se_current_buffer) == 1)
    ms_message("Buffer is now in upper case mode.");
  else
    ms_message("Buffer is now in lower/upper case mode.");
}
$eod
$ create BUFFER.H
$deck
#define bu_parent(bu) me_mem(bu)	/* parent buffer of this buffer */
#define bu_next(bu) \
	  me_mem(1+bu_parent(bu))	/* next buffer in list */
#define bu_name(bu) \
	  me_mem(2+bu_parent(bu))	/* pointer to buffer name */
#define bu_file_name(bu) \
	  me_mem(3+bu_parent(bu))	/* pointer to buffer file name */
#define bu_modified(bu) \
	  me_mem(4+bu_parent(bu))	/* modified flag:
					 * if even, buffer not modified
					 *   if 0, not modified
					 *   if 2, file not read yet
					 * if odd, buffer was modified
					 *   if 1, modified
					 *   if 3, has valid checkpoint file */
#define bu_type(bu) \
	  me_mem(5+bu_parent(bu))	/* mapping type of buffer */
#define bu_mappings(bu) \
	  me_mem(6+bu_parent(bu))	/* pointer to mappings buffer */
#define bu_protection(bu) \
	  me_mem(7+bu_parent(bu))	/* file protection code */
#define bu_indent(bu) \
	  me_mem(8+bu_parent(bu))	/* current indent in buffer */
#define bu_case(bu) \
	  me_mem(9+bu_parent(bu))	/* 1 - upper case; 0 - upper/lower */
#define bu_windows(bu) me_mem(10+bu)	/* list of windows onto the buffer */
#define bu_size(bu) me_mem(11+bu)	/* size in chars of text buffer */
#define bu_base(bu) me_mem(12+bu)	/* address-1 of text buffer */
#define bu_gap(bu) me_mem(13+bu)	/* address of gap in text buffer */
#define bu_gap_size(bu) me_mem(14+bu)	/* size of gap */
#define bu_dot(bu) me_mem(15+bu)	/* hold cursor pos when text not visible */
#define bu_bow(bu) me_mem(16+bu)	/* hold beg of window when text not vis */
#define bu_save_dot_ptr(bu) \
	  me_mem(17+bu)			/* cursor position at last position save */
#define bu_save_dot(bu) mk_mark(bu_save_dot_ptr(bu))
#define bu_save_bow_ptr(bu) \
	  me_mem(18+bu)			/* beg. of window at last position save */
#define bu_save_bow(bu) mk_mark(bu_save_bow_ptr(bu))
#define bu_mark1_ptr(bu) me_mem(19+bu)	/* text mark 1 */
#define bu_mark1(bu) mk_mark(bu_mark1_ptr(bu))
#define bu_mark2_ptr(bu) me_mem(20+bu)	/* text mark 2 */
#define bu_mark2(bu) mk_mark(bu_mark2_ptr(bu))
#define bu_markers(bu) me_mem(21+bu)	/* list of text markers */
#define bu_id(bu) me_mem(22+bu)		/* id of buffer */
#define bu_current(bu) me_mem(23+bu)	/* tells which sub-buf was last current */
#define bu_sub_buffers(bu) me_mem(24+bu)/* list of sub-buffers - sub-buffers do
					 * not appear in the list of session
					 * buffers */
#define bu_sizeof 25

#define bu_map(bu1, bu2) \
	  for (bu2 = bu1; bu2 != null; bu2 = bu_next(bu2))
#define bu_map_windows(bu, wi) \
	  for (wi = bu_windows(bu); wi != null; wi = wi_next_bu_window(wi))
#define bu_map_sub_buffers(bu1, bu2) \
	  for (bu2 = bu_parent(bu1); bu2 != null; bu2 = bu_sub_buffers(bu2))
$eod
$ create CALC.BND
$deck
  # Zilch Screen Editor
  #   Copyright (c) 1982,1983,1984,1986,1987 William P. Wood, Jr.
  # Calculator bindings and function definitions for standard Zilch
  # This file is %included by ZBIND.BND

%mode					calc
  define(header,implicit integer (a-p,r-z); implicit logical (q))

  define(unbound_key_sequence, error = true)
  define(qio_error, break)
  define(qio_error_in_insert_mode, next)	# can't happen here
  define(control_y_interrupt, call redraw)
  define(end_function_definition, next)

  subroutine calc
  header
  include "session.cmn"
  include "pushb.cmn"
  include "screen.cmn"
  byte get_tty_character
  integer cmd, error, state, mode
  save error, state
  data error, state /false, 0/
  string pr "Calc>* xxxxxxxxxxxxxx"
  character*14 ch_x
  equivalence (pr(8), ch_x)
  integer exp
  save exp
  data exp /0/
  real x, y, z, t, tmp, m
  save x, y, z, t, tmp, m
  data x, y, z, t, tmp, m /6*0.0/

  mode = bi_use_keymap(CALC_MODE)
  se_in_prompt = true
  sc_cursor_y = sc_size

  repeat {
    write(ch_x, (g14.7), err=10) x
    if (m != 0.0)
      pr(6) = '*'
    else
      pr(6) = ' '

    if (false) {
 10   ch_x = "Error - clear "
      error = true
      call ms_message(pr)
      call ms_error(EOS)
      }
    else {
      call ms_message(pr)
      if (error) {
	call ms_error(EOS)
	error = false
	}
      }
    cmd = bi_get_command()

calc_exit				^Z
    if (error) {
      x = 0.0
      exp = 0
      state = 2
      error = false
      }
    break
calc_exit				`
calc_exit				^[

calc_clear				c
    x = 0.0
    exp = 0
    state = 2
    error = false

calc_digit				0-9	# enter a digit into X reg
    if (error)
      goto 10
    if (state == 0) {
      t = z
      z = y
      y = x
      }
    if (state != 1) {
      x = 0.0
      exp = 0
      }
    if (pu_last_key_struck == '.') {
      if (exp == 0)
	exp = 1
      }
    else if (exp != 0) {
      exp = exp*10
      x = (x*exp + (pu_last_key_struck - '0'))/exp
      }
    else
      x = x*10 + (pu_last_key_struck - '0')
    state = 1
calc_digit				.

calc_enter				^M	# terminate entry into X reg
    if (error)
      goto 10
    t = z
    z = y
    y = x
    if (state == 1)
      state = 2
    else
      state = 0

calc_chs				~
    if (error)
      goto 10
    x = -x
    state = 0

calc_plus				+
    if (error)
      goto 10
    x = y + x
    y = z
    z = t
    state = 0

calc_minus				\-
    if (error)
      goto 10
    x = y - x
    y = z
    z = t
    state = 0

calc_mult				*
    if (error)
      goto 10
    x = y*x
    y = z
    z = t
    state = 0

calc_divide				/
    if (error)
      goto 10
    if (abs(x) < 1e-10)
      goto 10
    x = y/x
    y = z
    z = t
    state = 0

calc_invert				i
    if (error)
      goto 10
    if (abs(x) < 1e-10)
      goto 10
    x = 1/x
    state = 0

calc_store				s
    if (error)
      goto 10
    m = x
    state = 0

calc_recall				m
    if (error)
      goto 10
    if (state != 2) {
      t = z
      z = y
      y = x
      }
    x = m
    state = 0

calc_switch				w
    if (error)
      goto 10
    tmp = x
    x = y
    y = tmp
    state = 0

calc_roll_down				r
    if (error)
      goto 10
    tmp = x
    x = y
    y = z
    z = t
    t = tmp
    state = 0

    }
  mode = bi_use_keymap(mode)
  se_in_prompt = false
  return
  end
$eod
$ create CHANGE.BND
$deck
  # Zilch Screen Editor, Copyright (c) 1982,1986 William P. Wood, Jr.
  # Change bindings and function definitions for standard Zilch
  # This file is %included by ZBIND.BND

%mode					change
  define(header,implicit integer (a-p,r-z); implicit logical (q)
    include "session.cmn"
    include "memory.cmn")

  define(unbound_key_sequence,
	break)
  define(qio_error,
	break)
  define(qio_error_in_insert_mode,		# can't happen here
	continue)
  define(control_y_interrupt,
	call redraw
	break)
  define(end_function_definition,
	next)

  subroutine query_replace_string(count)
  header
  logical do_all
  string help_
  "' 'change '!'change all '.'change&stop 'n'no change '='return here '^G'stop"

  st = st_allocate(MAX_PROMPT)
  if (q_sr_get_search_string("Old string? "))
    if (q_pr_read_prompt("New string? ",st,len)) {
      dot = wi_dot(se_current_window)
      bow = wi_bow(se_current_window)
      mode = bi_use_keymap(CHANGE_MODE)
      do_all = false
      for (n = 0; n < count || count == 1; ) {
	if (! q_tx_search_forward(se_current_buffer,
    				wi_dot(se_current_window),
    				bu_size(se_current_buffer),
    				st_buffer(se_search_string),
    				st_buffer(se_search_mask),
    				se_search_length,
    				wi_dot(se_current_window)))
	  break
	else {
	  wi_dot(se_current_window) = wi_dot(se_current_window) +
							se_search_length
	  if (count > 1 || do_all)
	    goto 20
  10	  call ms_message(help)
	  cmd = bi_get_command()
sr_replace				\40		# space
	  continue
  20	  call sr_replace(st_buffer(st),len)
	  n = n+1
sr_replace				y
sr_replace_all				!
	  call sr_replace(st_buffer(st),len)
	  n = n+1
	  do_all = true
sr_no_replace				n
	  continue
sr_replace_and_stop			.
	  call sr_replace(st_buffer(st),len)
	  n = n+1
	  break
sr_return_here				=
	  dot = wi_dot(se_current_window)
	  bow = wi_bow(se_current_window)
	  if (true)
	    goto 10
sr_scroll_one_line_down			^K
	  call scroll_one_line_down
	  if (! q_dot_is_visible())
	    call scroll_one_line_up
	  if (true)
	    goto 10
sr_scroll_one_line_up			^J
	  call scroll_one_line_up
	  if (! q_dot_is_visible())
	    call scroll_one_line_down
	  goto 10
	  }
	}
      if (n > 0)
	call ms_report_number2("Replaced ",n," occurrence."," occurrences.")
      else
	call ms_message("No replacements done.")
      wi_dot(se_current_window) = dot
      wi_set_bow(se_current_window,bow)
      mode = bi_use_keymap(mode)
      }
  call st_deallocate(st)
  count = 0
  return
  end
$eod
$ create CHECKP.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "session.cmn"
#include "memory.cmn"

static char name[FILENAMESIZE];

static int q_ch_name(bufferp bu, char *name)
{
  if (bu_file_name(bu) == null)
    return q_ch_gen_name(st_buffer(bu_name(bu)),name);
  else
    return q_ch_gen_name(st_buffer(bu_file_name(bu)),name);
}

static int q_ch_gen_name(const char *buname, char *chname)
{
  int i, len;

  i = ho_length(buname);
  len = min(77, i);
  chname[0] = '$';
  movc(buname+max(0, i - len), chname+1, len);
  len++;
  if (len <= 39)
    chname[len] = '.';
  else
    movc(chname+39, chname+40, len-39);
  len++;
  chname[len] = EOS;
  for (i = 1; i < len; i++)
    if (i == 39)
      chname[i] = '.';
    else if (!isalnum(chname[i]) && chname[i] != '$' && chname[i] != '_' &&
		chname[i] != '-')
      chname[i] = '_';
  return ! q_ho_equal(buname+ho_indexq(buname, ']'), chname);
}

static int q_ch_buffer(bufferp bu)
{
  int modif, status, stat;

  if (bu_modified(bu) == 3)
    status = true;
  else {
    status = q_ch_name(bu, name);
    if (status) {
      modif = bu_modified(bu);
      status = q_mp_write_file(bu, name, 'U', &stat);
      if (status && mod(modif, 2) == 1)
	bu_modified(bu) = 3;		/* up-to-date checkpoint file exists */
      else
	bu_modified(bu) = modif;
      }
    }
  return status;
}

void checkpoint_modified_files(void)
{
  bufferp bu;
  int nch;

  nch = 0;
  bu_map(se_buffers,bu)
    if (bu_modified(bu) == 1 && bu_file_name(bu) != null)
      if (q_ch_buffer(bu))
	nch = nch + 1;
      else {
	ms_message2("Error checkpointing buffer ",bu_name(bu));
	ms_error("");
	}
  if (nch > 0)
    ms_report_number2("Checkpointed ", nch, " file.", " files.");
}

void ch_delete(bufferp bu)
{
  if (q_ch_name(bu, name)) {
    q_fi_delete(WRITE_UNIT,name);
    if (bu_modified(bu) == 3)		/* up-to-date checkpoint file exists */
      bu_modified(bu) = 1;
    }
}

int q_ch_recover(bufferp bu)
{
  if (q_ch_name(bu, name))
    if (q_mp_read_file(bu,name,0,false)) {
      ms_message2("Recovered ",bu_file_name(bu));
      ms_add_to_message(" from ");
      ms_add_to_message(name);
      bu_modified(bu) = 3;		/* up-to-date checkpoint file exists */
      return true;
      }
  return false;
}
$eod
$ create CMPC.MAR
$deck
;	Zilch Screen Editor,
;	Copyright (c) 1982,1987 William P. Wood, Jr.

	.title	q_cmpc_c
;
;
;	status = q_cmpc_c(const char *s1, unsigned int l1, const char *s2,
;			unsigned int l2, int *neq)
;
;
s1=4
l1=8
s2=12
l2=16
neq=20
	.psect	icr_code,pic,usr,con,rel,lcl,shr,exe,rd,nowrt,novec,long
q_cmpc_c::
	.word	^m<r2,r3>
	cmpc5	l1(ap),@s1(ap),#32,l2(ap),@s2(ap)	; compare the strings
	beql	10$
	subl3	r0,l1(ap),r1
	subl3	r2,l2(ap),r3
	clrl	r0					; not equal
	cmpl	r1,r3
	blss	5$
	movl	r1,@neq(ap)
	brb	30$
5$:
	movl	r3,@neq(ap)
	brb	30$
10$:
	movl	#1,r0					; equal
	cmpl	l1(ap),l2(ap)
	blss	20$
	movl	l1(ap),@neq(ap)
	brb	30$
20$:
	movl	l2(ap),@neq(ap)
30$:
	ret
	.end
$eod
$ create COMMAND.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "tables.cmn"

/* q_co_parse - return first arg in comand and increment comand */
int q_co_parse(const char **comand, char *arg, int comma_is_white)
{
  register const char *cmd;
  const char *begincmd;
  int litral, inbrak;

  for (cmd = *comand; *cmd == ' ' || (comma_is_white && *cmd == ','); cmd++)
    ;
  for (begincmd = cmd, litral = false, inbrak = false;
	  *cmd && (litral || inbrak || (*cmd != ' ' &&
					(*cmd != ',' || !comma_is_white) &&
					(cmd == begincmd || *cmd != '/'))); ) {
    if (*cmd == '"')
      if (cmd[1] == '"')
	*arg++ = *cmd++;
      else
	litral = !litral;
    else if ((*cmd == '<' || *cmd == '[') && ! litral)
      inbrak = true;
    else if ((*cmd == '>' || *cmd == ']') && ! litral)
      inbrak = false;
    if (litral)
      *arg++ = *cmd++;
    else
      *arg++ = ta_clower(*cmd++);
    }
  *arg = EOS;
  *comand = cmd;
  return cmd != begincmd;
}
 
#define isupper(c) ((c) >= 'A' && (c) <= 'Z')

/* q_co_matswi - match a switch (qualifier) */
int q_co_matswi(const char *swtch, const char *templ, int *ler, const char *errmsg, long int *n, char *cbuf, int csize)
{
  int i, j, bs;
  long int l;

  for (i = 0, j = 0; templ[j] && templ[j] != '='; j++)
    if (ta_clower(swtch[i]) == ta_clower(templ[j]) && i == j)
      i++;
    else if (isupper(templ[j]))
      return false;

  if (! templ[j])
    if (! swtch[i])
      return true;
    else if (swtch[i] == '=') {
      co_error(swtch, i, "No qualifier argument expected.");
      *ler = true;
      return false;
      }

  if (swtch[i] != '=') {
    if (swtch[i])
      return false;
    if (*errmsg)
      co_error(swtch, i, "Qualifier argument expected.");
    *ler = true;
    return false;
    }

  i++;
  bs = i;
  switch (templ[j+1]) {
    case '#':
      i++;
      l = ho_ctoi(swtch, &i);
      if (swtch[i-1])			/* didn't exhaust the string */
	break;
      *n = l;
      return true;

    case '\'':
      for(j = 0; j < csize && ((*cbuf++ = swtch[i++]) != EOS); j++)
	;
      if (j >= csize || j == 0)
	break;
      *n = j;
      return true;
    }

  if (*errmsg)
    co_error(swtch, bs, errmsg);
  *ler = true;
  return false;
}
 
void co_error(const char *swtch, int i, const char *errmsg)
{
if (*swtch)
  printf("%s\n", swtch);
printf("%s\n", errmsg);
/*
  ti_kill();
  if (*swtch)
    send_message_to_terminal(swtch);
  send_message_to_terminal(errmsg);
  ti_finish();
  exit(EXIT_BAD);
*/
}
$eod
$ create COST.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#include "symbols.h"

int cs_adm3a_clear(void)
{
  return 3;
}

int cs_adm3a_replace(int old, int new, int neq)
{
  return 4 + max(old,new) - neq;
}

int cs_adm3a_delete(void)
{
# include "terminal.cmn"

  return 1 + ti_lffill;
}

int cs_adm5_replace(int old, int new, int neq)
{
  return 4 + max(0,new-neq) + max(0,min(2,old-max(neq,new)));
}

int cs_vt100_clear(void)
{
  return 7;
}

int cs_vt100_replace(int old, int new, int neq)
{
  return 7 + max(0,new-neq) + max(0,min(3,old-max(neq,new)));
}

int cs_vt100_insert(int newlen, int neq, int cheap, int idc)
{
  register int cost;

  cost = newlen - neq;
  if (cost > 0)
    cost += 7;			/* because of cursor positioning */
  if (idc < 0)
    return cost;
  else if (cheap)
    return cost + 8;		/* would be 2 if could resolve idc problem */
				/* bumped from 5 to 8 May 6, 1988 -
				   scrolling too slow on Vax station */
  else
    return cost + 7 + 2 + 4;
}

int cs_vt100_delete(int cheap, int idc)
{
  if (idc > 0)
    return 0;
  else if (cheap)
    return 8;			/* would be 1 if could resolve idc problem */
				/* bumped from 5 to 8 May 6, 1988 -
				   scrolling too slow on Vax station */
  else
    return 7 + 5 + 1 + 4;
}

int cs_vt52_clear(void)
{
  return 4;
}

int cs_vt52_replace(int old, int new, int neq)
{
  return 4 + max(0,new-neq) + max(0,min(2,old-max(neq,new)));
}
$eod
$ create DCL.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1983,1984,1986,1987 William P. Wood, Jr. */

#include <stdlib.h>
#include "symbols.h"
#include "memory.cmn"
#include "session.cmn"
#include "screen.cmn"

#if VMS
#include "descr.h"
static vms_char_descr(d_sys$command, "SYS$COMMAND", sizeof("SYS$COMMAND")-1);
static int pid = 0;

void dcl_call(void)
{
  char process_name[16];
  static char spawn_cmd[] = "$ lo*goff := attach/id=xxxxxxxx";
  vms_char_descr(d_spawn_cmd, spawn_cmd, sizeof(spawn_cmd)-1);
  long int plen, curpid, biocnt, bytcnt, astcnt;
  int status;

  ms_message("");
  sc_update(&zero);
  te_finish();
  te_pos(sc_size,1);
  ti_flush();
  ti_finish();
  if (pid != 0)
    if (! lib$attach(&pid))
      pid = 0;
  if (pid == 0) {
    plen = sizeof(process_name);
    status = get_process_info(process_name, &plen, &curpid,
						  &biocnt, &bytcnt, &astcnt);
    if (status) {
      sprintf(spawn_cmd + 23, "%08x", curpid);
      status = lib$spawn(&d_spawn_cmd,&d_sys$command,&d_sys$command,0,0,&pid);
      if (! status) {
	ms_report_number(
"Error number ", status, " occurred while trying to spawn a subprocess.");
	ms_error("");
	}
      }
    else {
      ms_report_number(
"Error number ", status, " occurred while trying to get process information.");
      ms_error("");
      }
    }
  ti_initialize();
  redraw();
}

void dcl_finish(void)
{
  if (pid != 0)
    sys$delprc(&pid, 0);
}

long int get_process_info(char *process_name,long int *plen,long int *pid,long int *biocnt,long int *bytcnt,long int *astcnt)
{
# include <jpidef.h>
  long int jpibuf[16];
  int status;

  jpibuf[0] = JPI$_PRCNAM << 16 | *plen - 1;
  *plen = 0;
  jpibuf[1] = process_name;
  jpibuf[2] = plen;
  jpibuf[3] = JPI$_PID << 16 | 4;
  jpibuf[4] = pid;
  jpibuf[5] = 0;
  jpibuf[6] = JPI$_BIOCNT << 16 | 4;
  jpibuf[7] = biocnt;
  jpibuf[8] = 0;
  jpibuf[9] = JPI$_BYTCNT << 16 | 4;
  jpibuf[10] = bytcnt;
  jpibuf[11] = 0;
  jpibuf[12] = JPI$_ASTCNT << 16 | 4;
  jpibuf[13] = astcnt;
  jpibuf[14] = 0;
  jpibuf[15] = 0;

  status = sys$getjpi(0,0,0,jpibuf,0,0,0);
  if (status)
    process_name[*plen] = EOS;
  return status;
}
#endif

#if MSDOS
#include <process.h>

void dcl_call(void)
{
  char *command;

  command = getenv("COMSPEC");
  if (command != 0) {
    te_finish();
    te_pos(sc_size,1);
    ti_flush();
    ti_finish();
    spawnlp(P_WAIT, command, command, NULL);
    ti_initialize();
    redraw();
    }
  else
    ms_error("Couldn't get value of COMSPEC environment variable!");
}

void dcl_finish(void)
{
}

static int msdos_spawn(const char *cmd, const char *file)
{
  char *command;
  int lc;

  lc = ho_length(cmd);
  if (lc == 0) {
    cmd = getenv("COMSPEC");
    if (cmd != 0)
      lc = ho_length(cmd);
    else
      ms_error("Couldn't get value of COMSPEC environment variable!");
    }
  if (lc != 0) {
    command = malloc(lc + ho_length(file) + 3);
    if (command != NULL) {
      ho_scopy(cmd, 1, command, 1);
      strcat(command, " >");
      strcat(command, file);
      system(command);
      free(command);
      return 1;
      }
    else
      ms_error("Couldn't allocate memory for command!");
    }
  return 0;
}
#endif

void dcl_xcall(void)
{
# include "terminal.cmn"
  int i, size, len, status;
  stringp st = st_allocate(MAX_PROMPT);

# if VMS
  windowp wi = se_current_window;
  vms_char_descr(d_st, st_buffer(st), MAX_PROMPT-1);
  static char zilchlog[] = "sys$login:zilch.log";
  vms_char_descr(d_zilchlog, zilchlog, sizeof(zilchlog)-1);
  static char cli_prompt[] = "$ ";
  char mbx_trans_name[63];
  vms_char_descr(d_mbx_trans_name, mbx_trans_name, 63);
  vms_char_descr(d_mbx_name, mbx.name, sizeof(mbx.name)-1);
  vms_char_descr(d_nl, "nl:", sizeof("nl:")-1);
# endif

# if MSDOS
  static char zilchlog[] = "\\zilch.log";
# include <dir.h>
  char cli_prompt[FILENAMESIZE+2];
  if (getcwd(cli_prompt, FILENAMESIZE) == NULL)
    ho_scopy("> ", 1, cli_prompt, 1);
  else
    strcat(cli_prompt, "> ");
# endif

  if (q_pr_read_prompt(cli_prompt,st,&len))
    if (q_bu_find_window("Session log")) {
      mp_set_mappings(se_current_buffer, TEXT);
      size = bu_size(se_current_buffer);
      wi_dot(se_current_window) = size + 1;
      line_to_top_of_window();
      insert_string(cli_prompt);
      for (i = st; i < st+len; )
	insert_character(*st_buffer(i++));
# if VMS
      if (len > 0) {
	set_vms_char_descr_len(d_st, len);
	if (mbx.channel != 0) {
	  icr_trnlog_str(&d_mbx_name, &d_mbx_trans_name);
	  status = lib$spawn(&d_st, &d_nl, &d_mbx_trans_name, &1);
	  }
	else {
	  sc_update(&zero);
	  status = lib$spawn(&d_st, &d_nl, &d_zilchlog);
	  }
	insert_character(NEWLINE);
	}
      else {
# endif
	sc_update(&zero);
	te_finish();
	te_pos(sc_size,1);
	ti_flush();
	ti_finish();
# if VMS
	status = lib$spawn(0, &d_sys$command, &d_zilchlog);
# endif
# if MSDOS
	insert_character(NEWLINE);
	status = msdos_spawn(st_buffer(st), zilchlog);
# endif
	ti_initialize();
	redraw();
# if VMS
	}
# endif
      if (! status) {
	ms_report_number(
    "Error number ", status, " occurred while trying to spawn a subprocess.");
	ms_error("");
	}
# if VMS
      else if (mbx.channel != 0 && len > 0)
	;
# endif
      else if (! q_mp_read_file(se_current_buffer,zilchlog,
					bu_size(se_current_buffer)+1, false)) {
	ms_message("Can't read ");
	ms_add_to_message(zilchlog);
	ms_error("");
	}
      else
	q_fi_delete(WRITE_UNIT, zilchlog);
      bu_modified(se_current_buffer) = 0;
      wi_dot(se_current_window) = size + 1;
      line_to_top_of_window();
# if VMS
      if (mbx.channel != 0 && len > 0)
	while (se_current_window != wi)
	  next_window();
# endif
      }
  st_deallocate(st);
}
$eod
$ create DESCR.H
$deck
#if VMS
#include <descrip.h>
/*
 *	A simple macro to construct a string descriptor:
 */
#define vms_char_descr(name,string,len) \
	struct dsc$descriptor_s name = \
		{ len, DSC$K_DTYPE_T, DSC$K_CLASS_S, string }

#define set_vms_char_descr_len(name,len) name.dsc$w_length = len
#endif
$eod
$ create EDFUNC.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1983,1984,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "session.cmn"
#include "memory.cmn"

static void backup_lines(int n)
{
  textind dot;
  int i;

  for (i = 1; i <= n; i++)
    previous_line();
  if (! q_dot_is_visible()) {
    dot = wi_dot(se_current_window);
    wi_dot(se_current_window) = wi_bow(se_current_window);
    for (i = 1; i <= n; i++)
      previous_line();
    line_to_top_of_window();
    wi_dot(se_current_window) = dot;
    }
}

void next_character(void)
{
  wi_dot(se_current_window) = min(wi_dot(se_current_window)+1,
				bu_size(se_current_buffer)+1);
}

void previous_character(void)
{
  wi_dot(se_current_window) = max(wi_dot(se_current_window)-1,1);
}

void next_line(void)
{
  bufferp bu;

  bu = se_current_buffer;
  wi_dot(se_current_window) = min(find_eol(bu,wi_dot(se_current_window)),
    							bu_size(bu))+1;
}

void scroll_next_line(void)
{
  next_line();
  if (! q_dot_is_visible())
    scroll_one_line_up();
}

void scroll_next_line_col(textind hug)
{
  if (hug == 0) {
    if (q_eol())
      hug = MAXINT;
    else
      hug = current_column();
    }
  scroll_next_line();
  goto_column(hug);
}

void previous_line(void)
{
  bufferp bu;

  bu = se_current_buffer;
  wi_dot(se_current_window) =
		find_bol(bu,max(1,find_bol(bu,wi_dot(se_current_window)) - 1));
}

void scroll_previous_line(void)
{
  previous_line();
  if (! q_dot_is_visible())
    scroll_one_line_down();
}

void scroll_previous_line_col(textind hug)
{
  if (hug == 0) {
    if (q_eol())
      hug = MAXINT;
    else
      hug = current_column();
    }
  scroll_previous_line();
  goto_column(hug);
}

void scroll_one_line_up(void)
{
  textind t;

  t = wi_dot(se_current_window);
  wi_dot(se_current_window) = wi_bow(se_current_window);
  next_line();
  wi_set_bow(se_current_window,find_bol(se_current_buffer,
						wi_dot(se_current_window)));
  wi_dot(se_current_window) = t;
}

void scroll_one_line_down(void)
{
  textind t;

  t = wi_dot(se_current_window);
  wi_dot(se_current_window) = wi_bow(se_current_window);
  previous_line();
  wi_set_bow(se_current_window,wi_dot(se_current_window));
  wi_dot(se_current_window) = t;
}

void next_half_screen(void)
{
  textind dot;
  int n, i;

  n = (wi_size(se_current_window) + 1)/2;
  for (i = 1; i <= n; i++)
    next_line();
  if (! q_dot_is_visible()) {
    dot = wi_dot(se_current_window);
    wi_dot(se_current_window) = wi_bow(se_current_window);
    for (i = 1; i <= n; i++)
      next_line();
    line_to_top_of_window();
    wi_dot(se_current_window) = dot;
    }
}

void previous_half_screen(void)
{
  backup_lines((wi_size(se_current_window) + 1)/2);
}

void previous_screen(void)
{
  backup_lines(wi_size(se_current_window)-1);
}

void next_screen(void)
{
  textind t;
  int i;

  t = wi_dot(se_current_window);
  beginning_of_line();
  if (wi_dot(se_current_window) == wi_bow(se_current_window))
    for (i = 1; i < wi_size(se_current_window); i++)
      next_line();
  else
    wi_dot(se_current_window) = t;
  line_to_top_of_window();
}

textind find_bol(bufferp bu, textind loc)
{
  textind tx;

  for (tx = min(loc-1, bu_size(bu)); tx > 0; tx = tx-1)
    if (tx_text(tx_address(bu, tx)) == NEWLINE)
      break;
  return tx+1;
}

void beginning_of_line(void)
{
  wi_dot(se_current_window) =
  			find_bol(se_current_buffer,wi_dot(se_current_window));
}

textind find_eol(bufferp bu, textind loc)
{
  textp tx;

  tx = bu_base(bu) + loc;
  tx_find_newline(tx, bu_gap(bu), bu_gap_size(bu), &tx_text(0));
  return tx - 1 - bu_base(bu);
}

void end_of_line(void)
{
  wi_dot(se_current_window) =
  			find_eol(se_current_buffer,wi_dot(se_current_window));
}

void ends_of_line(void)
{
  if (q_bol())
    end_of_line();
  else
    beginning_of_line();
}

void line_to_top_of_window(void)
{
  textind dot;

  dot = wi_dot(se_current_window);
  beginning_of_line();
  wi_set_bow(se_current_window, wi_dot(se_current_window));
  wi_dot(se_current_window) = dot;
}

int q_bol(void)
{
  if (wi_dot(se_current_window) == 1)
    return true;
  if (tx_text(tx_address(se_current_buffer,
			  wi_dot(se_current_window)-1)) == NEWLINE)
    return true;
  return false;
}

/* this subroutine relies on the extra NEWLINES hidden at the end of each buffer */
int q_eol(void)
{
  return tx_text(tx_address(se_current_buffer,
			  wi_dot(se_current_window))) == NEWLINE;
}

void beginning_of_file(void)
{
  wi_dot(se_current_window) = 1;
  line_to_top_of_window();
}

void goto_last_lines_of_file(void)
{
  int i;

  end_of_file();
  previous_character();
  beginning_of_line();
  for (i = 1; i < wi_size(se_current_window); i++)
    previous_line();
  line_to_top_of_window();
}

void goto_end_of_file(void)
{
  int i;

  end_of_file();
  for (i = 1; i < wi_size(se_current_window); i++)
    previous_line();
  line_to_top_of_window();
  end_of_file();
}

void end_of_file(void)
{
  wi_dot(se_current_window) = bu_size(se_current_buffer) + 1;
}

void insert_character(int c)
{
  tx_insert_character(se_current_buffer, c, wi_dot(se_current_window));
  wi_dot(se_current_window) = wi_dot(se_current_window) + 1;
}

void insert_string(const char *buf)
{
  int len;

  len = ho_length(buf);
  tx_insert_buffer(se_current_buffer, wi_dot(se_current_window), buf, len);
  wi_dot(se_current_window) = wi_dot(se_current_window) + len;
}

void delete_previous_character(void)
{
  if (wi_dot(se_current_window) > 1)
    tx_delete(se_current_buffer,wi_dot(se_current_window)-1,
		wi_dot(se_current_window)-1);
}

void delete_next_character(void)
{
  if (wi_dot(se_current_window) <= bu_size(se_current_buffer))
    tx_delete(se_current_buffer,wi_dot(se_current_window),
		wi_dot(se_current_window));
}

void kill_to_beginning_of_line(void)
{
  textind t;

  t = wi_dot(se_current_window);
  beginning_of_line();
  delete_region_to_buffer("kill", t, wi_dot(se_current_window));
}

void kill_through_end_of_line(void)
{
  textind t;

  t = wi_dot(se_current_window);
  if (t > bu_size(se_current_buffer))
    ms_error("You're at the end of the buffer.");
  else {
    end_of_line();
    delete_region_to_buffer("kill", t,
	      min(wi_dot(se_current_window)+1, bu_size(se_current_buffer)+1));
    }
}

void kill_to_end_of_line(void)
{
  textind t;

  t = wi_dot(se_current_window);
  if (t > bu_size(se_current_buffer))
    ms_error("You're at the end of the buffer.");
  else {
    end_of_line();
    delete_region_to_buffer("kill", t, wi_dot(se_current_window));
    }
}

void yank_kill(void)
{
  textind t;

  t = wi_dot(se_current_window);
  yank_buffer("kill");
  wi_dot(se_current_window) = t;
}

int q_dot_is_visible(void)
{
  return q_sc_dot_is_visible(se_current_window, se_current_buffer);
}

/* this subroutine relies on the extra NEWLINES hidden at the end of each buffer */
int find_next_character(void)
{
  return tx_text(tx_address(se_current_buffer,wi_dot(se_current_window)));
}
$eod
$ create EDIT.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#define DEBUG 0
#include "symbols.h"
#include "memory.cmn"
#include "screen.cmn"
#include "session.cmn"

static void ed_save_string(stringp s1, stringp *s2)
{
  st_deallocate(*s2);
  *s2 = st_allocate(st_length(s1) + 1);
  st_scopy(s1, *s2);
}

#define RS_WI_BOW 0
#define RS_WI_DOT 1
#define RS_WI_SIZE 2
#define RS_WI_MIN_SIZE 2
#define RS_IS_PA_CURRENT_WINDOW 3
#define RS_PA_NUMBER 4
#define RS_IS_SE_CURRENT_PAGE 5
#define RS_SC_SIZE 6
#define RS_SC_WIDTH 7
#define RS_IS_FILE 8
#define RS_BU_INDENT 9
#define RS_BU_MARK1 10
#define RS_BU_MARK2 11
#define RS_BU_SAVE_DOT 12
#define RS_BU_SAVE_BOW 13
#define RS_BU_CASE 14
#define RS_BU_TYPE 15
#define RS_SE_DEFAULT_CASE 16
#define RS_SE_INDENT 16
#define RS_FILE 17
#define RS_BUFFER_SIZE max(MACRO_SIZE+MAX_MACROS, \
    			   FILENAMESIZE + (CHARS_PER_INT*RS_FILE))
static void ed_restore_session(void)
{
  intp buf[RS_BUFFER_SIZE];
  int oldsiz, nc, np;
  pagep pa;
  bufferp bu;
  windowp wi;
  file_info finfo;

  if (se_restore != null)
    if (! q_fi_open_read(FIND_UNIT, st_buffer(se_restore), &finfo))
      co_error(st_buffer(se_restore),1,
      					"Can't open session restore file.");
    else {
      sc_size = SCREEN_SIZE;
      oldsiz = SCREEN_SIZE;
      if (get(FIND_UNIT, buf, RS_BUFFER_SIZE, &nc))    /* restore macros */
	ma_restore_macros((char *) buf, nc);
      if (get(FIND_UNIT, buf, RS_BUFFER_SIZE, &nc)) {  /* restore search string */
	se_search_length = nc;
	if (se_search_length > 0)
	  movc(buf,st_buffer(se_search_string),se_search_length);
	}
      np = 0;
      while (get(FIND_UNIT, buf, RS_BUFFER_SIZE, &nc)) { /* restore windows */
	if (buf[RS_PA_NUMBER] != np) {
	  np = buf[RS_PA_NUMBER];
	  pa = pa_new(np);
	  pa_switch(np);
	  }
	if (buf[RS_IS_FILE] != 0)		/* was a file? */
	  q_visit_file((char *)buf + RS_FILE, false, 1);
	else
	  q_pop_to_buffer(null, (char *)buf + RS_FILE);
	}
      if (! q_fi_rewind(FIND_UNIT))
	co_error("",1,"Error rewinding session restore file.");
      get(FIND_UNIT, buf, RS_BUFFER_SIZE, &nc);
      get(FIND_UNIT, buf, RS_BUFFER_SIZE, &nc);
      pa_map(se_pages,pa)
	wi_map(pa_windows(pa),wi) {
	  if (get(FIND_UNIT, buf, RS_BUFFER_SIZE, &nc)) {
	    bu = wi_buffer(wi);
	    mk_set_mark(bu_mark1_ptr(bu), buf[RS_BU_MARK1], bu);
	    mk_set_mark(bu_mark2_ptr(bu), buf[RS_BU_MARK2], bu);
	    mk_set_mark(bu_save_dot_ptr(bu), buf[RS_BU_SAVE_DOT], bu);
	    mk_set_mark(bu_save_bow_ptr(bu), buf[RS_BU_SAVE_BOW], bu);
	    bu_case(bu) = buf[RS_BU_CASE];
	    bu_type(bu) = buf[RS_BU_TYPE];
	    mp_set_mappings(bu,bu_type(bu));
	    bu_indent(bu) = buf[RS_BU_INDENT];
	    bu_bow(bu) = buf[RS_WI_BOW];
	    bu_dot(bu) = buf[RS_WI_DOT];
	    wi_bow(wi) = buf[RS_WI_BOW];
	    wi_dot(wi) = buf[RS_WI_DOT];
	    wi_size(wi) = buf[RS_WI_SIZE] & 0xffff;
	    wi_min_size(wi) = max(1,buf[RS_WI_MIN_SIZE]/0x10000);
	    if (buf[RS_IS_PA_CURRENT_WINDOW] == 1)
	      pa_current_window(pa) = wi;
	    if (buf[RS_IS_SE_CURRENT_PAGE] == 1)
	      se_current_page = pa;
	    if (buf[RS_IS_PA_CURRENT_WINDOW] == 1 &&
		buf[RS_IS_SE_CURRENT_PAGE] == 1)
	      se_current_window = wi;
	    sc_size = buf[RS_SC_SIZE];
	    sc_width = buf[RS_SC_WIDTH];
	    se_default_case = buf[RS_SE_DEFAULT_CASE] & 1;
	    se_indent = buf[RS_SE_INDENT]/2;
	    if (se_indent == 0)
	      se_indent = 2;
	    }
	  }
      if (oldsiz != sc_size) {			/* retreive the message line! */
	sc_fill_line(sc_size,sc_buffer[sc_new][oldsiz-1]+1,
						  sc_new_length(oldsiz));
	sc_reverse_video(sc_size,sc_new) = false;
	}
      if (! q_fi_close(FIND_UNIT))
	co_error("",1,"Error closing session restore file.");
      }
}

static void ed_init_file(const char *file)
{
  int nc, i;
  file_info finfo;
# include "pushb.cmn"

  if (q_fi_open_read(READ_UNIT, file, &finfo)) {
    while (get(READ_UNIT, file, MAX_COMMAND, &nc))
      for (i = 0; i < nc; )
	tx_insert_character(pu_buffer, file[i++], bu_size(pu_buffer) + 1);
    if (! q_fi_close(READ_UNIT))
      co_error("", 1, "Error closing initialization file.");
    }
  else
    co_error("", 1, "Can't read initialization file.");
}

static int q_ed_initialize(int argc, const char *argv[])
{
# include "spfiles.cmn"
  int i, ler, status, cl_width, nfiles;
  long int n;
  stringp st;
  const char *argp;
  static const char illlen[] = "Illegal screen length.",
		    illwid[] = "Illegal screen width.",
		    illter[] = "Illegal terminal type.",
		    illfil[] = "Illegal file name.",
		    illcas[] = "Case must be \"upper\" or \"lower\".",
		    illind[] = "Illegal indent.",
		    illword[] = "Illegal word definition.";

  status = false;
  ti_initialize();
  sc_initialize();
  cl_width = 0;		/* cl_width, the width returned from command line */
  te_initialize();
  se_initialize();
  pu_initialize();
  mp_initialize();
  ma_initialize();
  st = st_allocate(MAX_COMMAND);
  nfiles = 0;
  for (i = 1; i < argc; i++) {
    argp = argv[i];
    while (q_co_parse(&argp, st_buffer(st), false)) {
      ler = false;
      if (*st_buffer(st) == '/') {
	if (nfiles > 0)
	  co_error("", 1, "Switches may not appear on file names.");
	else if (q_co_matswi(st_buffer(st), "/INItialize='", &ler,
			illfil, &n, st_buffer(st), MAX_COMMAND))
	  ed_init_file(st_buffer(st));
	else if (q_co_matswi(st_buffer(st), "/Length=#", &ler,
			illlen, &n, st_buffer(st), MAX_COMMAND)) {
	  sc_size = n;
	  if (sc_size < 3 || sc_size > SCREEN_SIZE)
	    co_error("", 1, illlen);
	  }
	else if (q_co_matswi(st_buffer(st), "/Width=#", &ler,
			illwid, &n, st_buffer(st), MAX_COMMAND))
	  cl_width = n;
	else if (q_co_matswi(st_buffer(st), "/Terminal='", &ler,
			illter, &n, st_buffer(st), MAX_COMMAND)) {
	  if (! q_te_set_type(st_buffer(st)))
	    co_error(st_buffer(st), 1, illter);
	  }
	else if (q_co_matswi(st_buffer(st), "/Restore='", &ler,
			illfil, &n, st_buffer(st), MAX_COMMAND))
	  ed_save_string(st, &se_restore);
	else if (q_co_matswi(st_buffer(st), "/Save='", &ler,
			illfil, &n, st_buffer(st), MAX_COMMAND))
	  ed_save_string(st, &se_save);
	else if (q_co_matswi(st_buffer(st), "/Help='", &ler,
			illfil, &n, st_buffer(st), MAX_COMMAND))
	  ed_save_string(st, &sp_help);
	else if (q_co_matswi(st_buffer(st), "/RATMap='", &ler,
			illfil, &n, st_buffer(st), MAX_COMMAND))
	  ed_save_string(st, &sp_ratmap);
	else if (q_co_matswi(st_buffer(st), "/PASMap='", &ler,
			illfil, &n, st_buffer(st), MAX_COMMAND))
	  ed_save_string(st, &sp_pasmap);
	else if (q_co_matswi(st_buffer(st), "/FORMap='", &ler,
			illfil, &n, st_buffer(st), MAX_COMMAND))
	  ed_save_string(st, &sp_formap);
	else if (q_co_matswi(st_buffer(st), "/TEXTMap='", &ler,
			illfil, &n, st_buffer(st), MAX_COMMAND))
	  ed_save_string(st, &sp_textmap);
	else if (q_co_matswi(st_buffer(st), "/CMap='", &ler,
			illfil, &n, st_buffer(st), MAX_COMMAND))
	  ed_save_string(st, &sp_cmap);
	else if (q_co_matswi(st_buffer(st), "/CAse='", &ler,
			illcas, &n, st_buffer(st), MAX_COMMAND)) {
	  if (q_ho_equal(st_buffer(st), "lower"))
	    se_default_case = 0;
	  else if (q_ho_equal(st_buffer(st), "upper"))
	    se_default_case = 1;
	  else
	    co_error(st_buffer(st),1,illcas);
	  }
	else if (q_co_matswi(st_buffer(st), "/INDent=#", &ler,
			illind, &n, st_buffer(st), MAX_COMMAND))
	  se_indent = n;
	else if (q_co_matswi(st_buffer(st), "/CRoss_lines", &ler,
			"", &n, st_buffer(st), MAX_COMMAND))
	  se_cross_lines = true;
	else if (q_co_matswi(st_buffer(st), "/NOCRoss_lines", &ler,
			"", &n, st_buffer(st), MAX_COMMAND))
	  se_cross_lines = false;
	else if (q_co_matswi(st_buffer(st), "/WOrd='", &ler,
			illword, &n, st_buffer(st), MAX_COMMAND)) {
	  if (! q_se_define_word_class(st_buffer(st), 2))
	    co_error("", 1, "Too many word class definitions.");
	  }
	else if (q_co_matswi(st_buffer(st), "/MAcros='", &ler,
			illfil, &n, st_buffer(st), MAX_COMMAND)) {
	  ed_save_string(st, &se_macros);
	  if (! q_ma_read_macros(st_buffer(st)))
	    co_error(st_buffer(st), 1, "Can't open macro file.");
	  }
	else if (q_co_matswi(st_buffer(st), "/RECover", &ler,
			"", &n, st_buffer(st), MAX_COMMAND))
	  se_recover = true;
	else if (! ler)
	  co_error(st_buffer(st), 1, "Illegal switch.");
	}
      else {
	nfiles = nfiles+1;
	pr_add_to_recall(st_buffer(st));
	multi_visit_file(st_buffer(st),false,nfiles == 1);
	}
      }
    }

  if (se_macros == null) {
    ho_scopy("sys$login:zilch.macros", 1, st_buffer(st), 1);
    ed_save_string(st, &se_macros);
    if (nfiles != 0)
      if (! q_ma_read_macros(st_buffer(st)))
	;
    }
  if (nfiles == 0)
    ed_restore_session();
  else {
    se_current_window = se_windows;
    wi_equalize();
    }
  if (cl_width != 0)
    sc_width = cl_width;
  if (se_windows == null)
    if (nfiles > 0)
      co_error("", 1, "Bad file name.");
    else
      co_error("", 1, "No files on command line.");
  else if ((! q_te_set_length(sc_size)) || sc_size < 3)
    co_error("", 1, illlen);
  else if (! q_te_set_width(sc_width))
    co_error("", 1, illwid);
  else {
    status = true;
    ky_bind_keys();
    redraw();
    }
  st_deallocate(st);
  return status;
}

void ed_save_session(void)
{
  intp buf[RS_BUFFER_SIZE];
  pagep pa;
  windowp wi;
  bufferp bu;
  int nc, ier;
  static const char opener[] = "Can't open session save file!\15\12",
		    closer[] = "Error closing session save file!\15\12";

  if (se_save != null)
    if (! q_fi_open_write(WRITE_UNIT, st_buffer(se_save), 'U', 0xFFFF))
      ms_error(opener);
    else {
      ma_save_macros((char *)buf, &nc, RS_BUFFER_SIZE);
      put(WRITE_UNIT, buf, nc, &ier);
      put(WRITE_UNIT, st_buffer(se_search_string), se_search_length, &ier);
      pa_update;
      pa_map(se_pages, pa)
	if (pa_number(pa) >= 0)
	  wi_map (pa_windows(pa), wi) {
	    buf[RS_WI_BOW] = wi_bow(wi);
	    buf[RS_WI_DOT] = wi_dot(wi);
	    buf[RS_WI_SIZE] = wi_size(wi);
	    buf[RS_WI_MIN_SIZE] = buf[RS_WI_SIZE] | (0x10000*wi_min_size(wi));
	    if (wi == pa_current_window(pa))
	      buf[RS_IS_PA_CURRENT_WINDOW] = 1;
	    else
	      buf[RS_IS_PA_CURRENT_WINDOW] = 0;
	    buf[RS_PA_NUMBER] = pa_number(pa);
	    if (pa == se_current_page)
	      buf[RS_IS_SE_CURRENT_PAGE] = 1;
	    else
	      buf[RS_IS_SE_CURRENT_PAGE] = 0;
	    buf[RS_SC_SIZE] = sc_size;
	    buf[RS_SC_WIDTH] = sc_width;
	    buf[RS_SE_DEFAULT_CASE] = se_default_case | (se_indent*2);
	    bu = wi_buffer(wi);
	    buf[RS_BU_INDENT] = bu_indent(bu);
	    buf[RS_BU_MARK1] = bu_mark1(bu);
	    buf[RS_BU_MARK2] = bu_mark2(bu);
	    buf[RS_BU_SAVE_DOT] = bu_save_dot(bu);
	    buf[RS_BU_SAVE_BOW] = bu_save_bow(bu);
	    buf[RS_BU_CASE] = bu_case(bu);
	    buf[RS_BU_TYPE] = bu_type(bu);
	    if (bu_file_name(bu) == null) {
	      buf[RS_IS_FILE] = 0;
	      ho_scopy(st_buffer(bu_name(bu)), 1, (char *)buf + RS_FILE, 1);
	      }
	    else {
	      buf[RS_IS_FILE] = 1;
	      ho_scopy(st_buffer(bu_file_name(bu)),1,(char *)buf + RS_FILE,1);
	      }
	    put(WRITE_UNIT, buf, ho_length((char *)buf + RS_FILE) + 1 +
				      CHARS_PER_INT*RS_FILE, &ier);
	    }
      if (! q_fi_close(WRITE_UNIT))
	ms_error(closer);
      }
}

static int q_ed_finish(void)
{
  int aborted, status;
  bufferp bu;

  status = true;
  if (mod(bu_modified(se_current_buffer), 2) == 1)
    if (q_pr_ask("Save file [y]? ", true, &aborted)) {
      if (! q_fi_write_buffer(se_current_buffer))
	return false;
      }
    else if (aborted)
      return false;
  bu_map(se_buffers, bu)
    if (bu != se_current_buffer && mod(bu_modified(bu), 2) == 1 &&
	bu_file_name(bu) != null) {
      if (! q_pr_ask("Modified files exist; exit [n]? ", false, &aborted))
	status = false;
      break;
      }
  if (status) {
    ed_save_session();
    ms_message("");
    sc_update(&zero);
    te_finish();
    te_pos(sc_size, 1);
    ti_flush();
    ti_finish();
    dcl_finish();
    }
  return status;
}

void zilch(int argc, const char *argv[])
{
#if DEBUG
  timrb();
#endif
  if (q_ed_initialize(argc, argv))
    do {
      ky_edit();
      } while (! q_ed_finish());
#if DEBUG
  timre();
#endif
}
$eod
$ create EXTERN.C
$deck
#define initialize		/* We want to allocate storage this time */
				/* And we also want to initialize things */

#include "symbols.h"

#include "bind.cmn"
#include "finfo.cmn"
#include "insert.cmn"
#include "macro.cmn"
#include "mappings.cmn"
#include "memory.cmn"
#include "page.cmn"
/*#include "prompt.cmn"*/
#include "pushb.cmn"
#include "screen.cmn"
#include "session.cmn"
#include "spfiles.cmn"
#include "tables.cmn"
#include "terminal.cmn"
$eod
$ create FILEIO.H
$deck
#define FI_OK 0
#define FI_OPEN_ERROR 1
#define FI_IO_ERROR 2
typedef struct {
	long int end_of_file_block;
	short int protection_code;
	} file_info;
$eod
$ create FILEIO.RAT
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1983,1984,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "session.cmn"
#include "memory.cmn"

int q_fi_read_named_file(bu,dot)
{

  st = st_allocate(MAX_PROMPT);
  if (dot == 0)
    q_fi_read_named_file = q_pr_read_prompt("Read from file: ",st,len);
  else
    q_fi_read_named_file = q_pr_read_prompt("Insert file: ",st,len);
  if (q_fi_read_named_file) {
    if (len == 0) {
      ms_error("Aborted.");
      q_fi_read_named_file = false;
      }
    else if (! q_mp_read_file(bu,st_buffer(st),dot,false)) {
      ms_message2("Can't read ",st);
      ms_error("");
      q_fi_read_named_file = false;
      }
    else
      bu_modified(bu) = 1;
    }
  st_deallocate(st);
  return;
}

int q_fi_read_file(bu,name,dot,setpro)
{
  byte name(ARB);
  int setpro;

  if (! q_fi_open_read(READ_UNIT,name,ebk,pro))
    return false;
  if (setpro)
    bu_protection(bu) = pro;
  if (q_fi_add_newline(READ_UNIT,rsize))
    leave = 1;
  else
    leave = 0;
  if (rsize == 0)
    i = ebk;					/* eof block set by gpopen */
  else
    i = ebk*2;
  tdot = max(1, min(dot, bu_size(bu)+1));
  if (dot == 0)
    bu_clear_text(bu);
  else
    tx_set_gap(bu, tdot);
  tx_more_memory_please(bu, i*512);
  bsize = bu_size(bu);

  while (bu_gap_size(bu) > leave) {
    err = get(READ_UNIT, &tx_text(bu_gap(bu)),
    			min(32767,bu_gap_size(bu) - leave), nc);
    if (nc < 0)
      break;
    bu_gap(bu) = bu_gap(bu) + nc + leave;
    bu_gap_size(bu) = bu_gap_size(bu) - (nc+leave);
    bu_size(bu) = bu_size(bu) + nc + leave;
    if (leave == 1)
      tx_text(bu_gap(bu) - 1) = NEWLINE;
    }
  if (bu_gap_size(bu) <= leave || nc == RECORDTOOLONG)
    ms_error( _
"Text buffer overflow! Whole file not read. What kind of file is this anyway!?");
  else if (nc != EOF) {
    ms_message("Error reading file ");
    ms_add_to_message(name);
    ms_error("");
    }

  len = bu_size(bu) - bsize;
  bu_map_windows(bu,wi)
    if (dot > 0) {
      if (wi_dot(wi) > tdot)		/* ok */
	wi_dot(wi) = wi_dot(wi) + len;
      if (wi_bow(wi) > tdot)		/* ok */
	wi_bow(wi) = wi_bow(wi) + len;
      else
	wi_modified(wi) = 1;
      }
    else
      wi_modified(wi) = 1;
  if (dot > 0) {
    mk_map(bu_markers(bu),mk)
      if (mk_mark(mk) > tdot)
	mk_mark(mk) = mk_mark(mk) + len;
/* mark inserted buffer for easy deletion if wrong file or whatever... */
    mk_set_mark(bu_mark1_ptr(bu), tdot, bu);
    mk_set_mark(bu_mark2_ptr(bu), tdot + len, bu);
    }

  close(unit = READ_UNIT, err=10);
  return true;
L10:
  ms_message("Error closing file ");
  ms_add_to_message(name);
  ms_error("");
  return true;
}

int q_fi_write_buffer(bu)
{

  if (bu_file_name(bu) == null)
    q_fi_write_buffer = q_fi_write_named_file(bu);
  else if (q_mp_write_file(bu,st_buffer(bu_file_name(bu)),'N',stat))
    q_fi_write_buffer = true;
  else if (stat == FI_OPEN_ERROR)
    q_fi_write_buffer = q_fi_write_named_file(bu);
  else
    q_fi_write_buffer = false;
  return
}

int q_fi_write_named_file(bu)
{

  q_fi_write_named_file = false;
  fi = st_allocate(max(FILENAMESIZE,MAX_PROMPT));
  st = st_allocate(MAX_PROMPT);
  if (q_pr_read_prompt("Write to file: ",st,len)) {
    n = 0;
    if (len == 0)
      ms_error("Aborted.");
    else if (! q_fi_find_file(FIND_UNIT,st_buffer(st),st_buffer(fi),n,false,
      				true)) {
      ms_message2("Can't write ",st);
      ms_error("");
      }
    else if (q_mp_write_file(bu,st_buffer(fi),'N',stat)) {
      bu_new_names(bu, "", st_buffer(fi));
      q_fi_write_named_file = true;
      }
    else if (stat == FI_OPEN_ERROR) {
      ms_message2("Can't write ",fi);
      ms_error("");
      }
    else
      bu_new_names(bu, "", st_buffer(fi));
    }
  st_deallocate(fi);
  st_deallocate(st);
  return
}

int q_fi_write_modif_file_buffers(void)
{

  n = 0;
  errn = 0;
  bu_map(se_buffers,bu)
    if (bu_file_name(bu) != null && mod(bu_modified(bu),2) == 1)
      if (q_mp_write_file(bu,st_buffer(bu_file_name(bu)),'N',stat))
	n = n+1;
      else
	errn = errn+1;
  if (errn > 0) {
    ms_report_number2("",errn," file could not be written!",
    				    " files could not be written!");
    ms_error("");
    q_fi_write_modif_file_buffers = false;
    }
  else {
    ms_report_number2("Wrote ",n," file."," files.");
    q_fi_write_modif_file_buffers = true;
    }
  return
}

int q_fi_write_region(bu,name,m1,m2,type,stat)
{
  byte name(ARB),type;

  stat = FI_OK;
  q_fi_write_region = true;
  if (name(1) != EOS)
    if (! q_fi_open_write(WRITE_UNIT,name,type,bu_protection(bu))) {
      stat = FI_OPEN_ERROR;
      return false;
      }
  tx_set_gap(bu,m1);
  tx = tx_address(bu,m1);
  last = tx_address(bu,m2);
  for ( ; tx <= last && ! se_error_occurred; tx = i+1) {	/* possible ^C interrupt */
    for (i = tx; i <= last; i = i+1)
      if (tx_text(i) == NEWLINE)
	break;
    if (! put(WRITE_UNIT,&tx_text(tx),i-tx,ier)) {
      ms_message("Error writing file ");
      ms_add_to_message(name);
      ms_error("");
      q_fi_write_region = false;
      stat = FI_IO_ERROR;
      break;
      }
    }
  if (se_error_occurred) {
    q_fi_write_region = false;
    stat = FI_IO_ERROR;
    }
  if (name(1) != EOS)
    close(unit = WRITE_UNIT,err=10);
  return;
L10:
  ms_message("Error closing file ");
  ms_add_to_message(name);
  ms_error("");
  stat = FI_IO_ERROR;
  return false;
}

int q_fi_open_read(lun,file,filebk,filpro)
{
  byte file(ARB);
# include "finfo.cmn"
  character*_arith(FILENAMESIZE,-,1) cfile;
#ifdef VAX
  external gpopen;
#endif

/* use character var for filename, not byte array because of bug when byte
 * array is more than 100 chars long */
  cfile = ' ';
  movc(file, %ref(cfile), ho_length(file));
  open(unit = lun, name = cfile, type = 'old',
#ifdef VAX
	useropen = gpopen, defaultfile = ' ',
#endif
    	shared, readonly, err = 10);
  filebk = ebk;
  filpro = pro;
  return true;

L10:
  return false;
}

int q_fi_open_write(lun,file,stat,filpro)
{
  byte file(ARB),stat;
# include "finfo.cmn"
  character*_arith(FILENAMESIZE,-,1) cfile;
#ifdef VAX
  external gpcre8;
#endif

/* use character var for filename, not byte array because of bug when byte
 * array is more than 100 chars long */
  cfile = ' ';
  movc(file, %ref(cfile), ho_length(file));
  pro = filpro;
  if (stat == 'N' && fi_find_version(file) == 0)
    open(unit = lun, name = cfile, type = 'new', carriagecontrol = 'list',
#ifdef VAX
	  useropen = gpcre8, defaultfile = ' ',
#endif
	  err = 10);
  else
    open(unit = lun, name = cfile, type = 'unknown', carriagecontrol = 'list',
#ifdef VAX
	  useropen = gpcre8, defaultfile = ' ',
#endif
	  err = 10);
  return true;

L10:
  return false;
}

int q_fi_delete(lun,file)
{
  byte file(ARB);
  character*_arith(FILENAMESIZE,-,1) cfile;

/* use character var for filename, not byte array because of bug when byte
 * array is more than 100 chars long */
  cfile = ' ';
  movc(file, %ref(cfile), ho_length(file));
  open(unit = lun, name = cfile, type = 'old',
#ifdef VAX
	  defaultfile = ' ',
#endif
	  err = 10);
  close(unit = lun, dispose = 'delete', err = 5);
  return true;

5
  close(unit = lun, err = 10);

L10:
  return false;
}

#ifdef VAX

/* q_fi_find_file - return matching file names one-by-one */
int q_fi_find_file(dummy, file, outfil, n, wild, clear_context)
{
  byte file(FILENAMESIZE), outfil(FILENAMESIZE), ho_clower;
  int wild, clear_context, insert_space, inquo;
  character*_arith(FILENAMESIZE,-,1) file_spec, result_spec;
  integer context, user_flags, status;
  save insert_space, file_spec, context, user_flags;
  data insert_space /false/, context /0/;
 
  if (n == 0) {
    if (clear_context)
      lib$find_file_end(context);	/* Clear file name defaults */
    if (wild)
      user_flags = 2;		/* Multiple, allow wild */
    else
      user_flags = 3;		/* Multiple, nowild */
    file_spec = ' ';
    for (i = 1; file(i) != EOS; i = i+1)
      file_spec(i:i) = char(file(i));
/* the following code works around a bug in lib$find_file - it does not
 * work properly when the same wild file spec is given to it twice in a row
 * and user_flags is set for multiple; the work-around is to alternately
 * insert or not insert a space in front of file_spec */
    if (insert_space) {
      file_spec(2:) = file_spec(1:);
      file_spec(1:1) = ' ';
      }
    insert_space = ! insert_space;
    }
  nn = n;
  status = lib$find_file(file_spec, result_spec, context, , , , user_flags);
  if ((status & 1) == 1)
    n = n + 1;
  else
    n = 0;
  if (n > 0 || nn == 0) {
    rlen = len_trim(result_spec);
    for ([inquo = false; i = 1]; i <= rlen; i = i+1) {
      if (result_spec(i:i) == '"')
	inquo = .not. inquo;
      if (inquo)
	outfil(i) = ichar(result_spec(i:i));
      else if (result_spec(i:i) == '>')
	outfil(i) = ']';
      else if (result_spec(i:i) == '<')
	outfil(i) = '[';
      else
	outfil(i) = ho_clower(ichar(result_spec(i:i)));
      }
    outfil(i) = EOS;
    vers = fi_find_version(outfil);
    if (vers != 0)
      if (fi_find_version(file) == 0)
	outfil(vers) = EOS;
      else
	outfil(vers) = ';';
    status = status & 7;		/* isolate error severity bits */
    if (status == 0 || status == 2)	/* Warning or Error severity */
      if (! q_fi_wild(outfil))
	n = 1;				/* file is legal, but non-readable */
    }
  return n > 0;
}
 
#else

/* q_fi_find_file - return matching file names one-by-one */
int q_fi_find_file(lun, file, outfil, n)
{
  byte file(FILENAMESIZE), outfil(FILENAMESIZE);
  integer lun, n,
    saven, ierr;
# include "qiofn.cmn"

  saven = n;
  if (saven == 0)
    qiofn(TT$OUT, IODET, 0, 0, ierr);
  fndfil(lun, file, outfil, n);
  if (saven == 0)
    qiofn(TT$OUT, IOATT, 0, 0, ierr);
  return n > 0;
}

#endif

/* q_fi_wild - return true if file name contains wild card chars or switches */
int q_fi_wild(file)
{
  byte file(ARB);
 
#ifdef VAX
  if (file(ho_bkscnq(file, "/*%", 1)) != EOS)
    return true;
  else {			/* look for ... */
    ndots = 0;
    for (i = 1; file(i) != EOS  &&  ndots < 3; i = i+1)
      if (file(i) == '.')
        ndots = ndots+1;
      else
        ndots = 0;
    if (ndots == 3)
      return true;
    }
#else
  if (file(ho_bkscnq(file, "/*?", 1)) != EOS)
    return true;
#endif
  return false;
}

int fi_find_version(file)
{
  byte file(ARB);

  for ([ndots = 0; i = ho_length(file)]; i > 0; i = i - 1)
    switch (file(i)) {
      case '"', ':', '>', ']':
        return 0;
      case '.':
	ndots = ndots+1;
	if (ndots == 1)
	  fi_find_version = i;
	else
	  return;
      case ';':
	return i;
      }
  return 0;
}

int q_fi_add_newline(f,rsize)
{

#ifdef VAX

#undef(character)
  integer f, rsize;
  character*20 rtype, crc, org;
 
  inquire(unit=f, recordtype=rtype, carriagecontrol=crc, organization=org,
  		recl = rsize);
  if (rtype == 'VARIABLE')
    rsize = 0;
  if (crc == 'LIST'  ||  crc == 'UNKNOWN'  ||  rtype == 'FIXED' ||
      org != 'SEQUENTIAL')
    return true;
  else if (crc == 'FORTRAN')
    return true;
  else
    return false;

#else

  integer f, cc, rtype, efbk, ffby, ier;
 
  getcha(f, rtype, rsize, cc, efbk, ffby, ier);
  if (rtype != 1)
    rsize = 0;
  if ((cc  &  2) != 0 || rtype == 1)  /* treat fixed length records as LIST */
    return true;
  else if ((cc  &  1) != 0)		/* fortran cc */
    return true;
  else
    return false;

#endif

}
$eod
$ create FILLC.MAR
$deck
;	Zilch Screen Editor,
;	Copyright (c) 1982,1987 William P. Wood, Jr.

	.title	fillc_c
;
;
;	fillc_c(char *out, unsigned int len, char c)
;
;
out=4
len=8
c=12
	.psect	icr_code,pic,usr,con,rel,lcl,shr,exe,rd,nowrt,novec,long
fillc_c::
	.word	^m<r2,r3,r4,r5>
	movc5	#0,0,c(ap),len(ap),@out(ap)		; fill the destination
	ret
	.end
$eod
$ create FINFO.CMN
$deck
declare file_info finfo;
$eod
$ create HELP.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "memory.cmn"
#include "spfiles.cmn"
#include "session.cmn"

int q_he_help(void)
{
  static const char nohelp[] = "Can't read Help file!";

  if (sp_read_buffer("Help",&sp_help,nohelp) == null) {
    ms_error(nohelp);
    return false;
    }
  else {
    pa_switch(-1);
    q_switch_to_buffer(null, "Help");
    delete_other_windows();
    ms_message("Type carriage-return to exit Help.");
    return true;
    }
}
$eod
$ create HOLLERIT.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "tables.cmn"

/* ho_length - compute length of hollerith string */
int ho_length(register const char *str)
{
   register const char *s2 = str;

   while (*str++)
      ;
   return str - s2 - 1;
}

/* ho_scopy - copy string at from(i) to to(j) */
void ho_scopy(register const char *from, int i, register char *to, int j)
{
   from += i - 1;
   to += j - 1;
   while ((*to++ = *from++) != EOS)
      ;
}

/* ho_clower - change letter to lower case */
int ho_clower(int c)
{
   return ta_clower(c);
}

/* ho_cupper - change letter to upper case */
int ho_cupper(int c)
{
   return c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c ;
}

/* q_ho_is_upper - return true if c is upper case letter */
int q_ho_is_upper(int c)
{
  return c >= 'A' && c <= 'Z';
}

/* q_ho_equal - compare str1 to str2; return true if equal, false if not */
int q_ho_equal(register const char *str1, register const char *str2)
{
   while (ta_clower(*str1) == ta_clower(*str2++))
      if (*str1++ == EOS)
	 return true;
   return false;
}

/* ho_index - find character  c  in string  str */
int ho_index(register const char *str, int c)
{
   register const char *s2 = str;

   while (*str)
      if (*str++ == c)
	 return str - s2;
   return 0;
}

/* ho_indexq - find character c in str, ignoring chars within quoted strings */
int ho_indexq(register const char *str, int c)
{
   register int index;

   for (index = ho_nuqcp(str, 1); str[index-1];
	index = ho_nuqcp(str, index+1))
      if (str[index-1] == c)
         return index;
   return 0;
}

/* ho_nuqcp - return pos of next char which isn't part of a quoted (") string */
int ho_nuqcp(register const char *buf, register int i)
{
  if (buf[i-1] != '"')
    return i;
  while (buf[i++])
    if (buf[i-1] == '"') {
      if (buf[i++] != '"')
	return i;
      }
  return i;
}

/* ho_bkscnq - return index of first break char in str,
 *	       ignore chars inside quotes */
int ho_bkscnq(register const char *str, const char *brk, int i)
{
  register int index;

  for (index = ho_nuqcp(str,i); str[index-1];
		index = ho_nuqcp(str,index+1))
    if (ho_index(brk, str[index-1]) != 0)
      break;
  return index;
}

/* ho_itoc - convert integer intg  to char string in  str */
int ho_itoc(long int intg, register char *str, int size)
{
   register long int intval;
   char c, *s;
   int d, i;

   intval = intg;
   s = str;
   *str++ = EOS;
   i = 1;
   do {					/* generate digits */
      i++;
      d = intval % 10;
      *str++ = abs(d) + '0';
      intval = (intval-d)/10;
      } while (intval != 0 && i < size);
   if (intg < 0 && i < size) {		/* then sign */
      i++;
      *str++ = '-';
      }
   do {					/* then reverse */
      c = *--str;
      *str = *s;
      *s++ = c;
      } while (str > s);
   return i - 1;
}

/* ho_itocrj - convert integer to character in a right-adjusted field */
#define MAXCHARS 20
int ho_itocrj(long int intg, char *str, int size)
{
   register char *s1;
   register const char *s2;
   char tbuf[MAXCHARS];

   s2 = tbuf + ho_itoc(intg, tbuf, MAXCHARS);
   for (s1 = str + size - 1; s2 >= tbuf && s1 >= str; )
      *s1-- = *s2--;
   while (s1 >= str)
      *s1-- = ' ';
   return size - 1;
}

/* ho_ctoi - convert string at in(i) to integer, increment index */
long int ho_ctoi(register const char *in, int *index)
{
   register const char *inp;
   long int intval;
   int d, neg;

   inp = in + *index - 1;
   while (*inp == ' ' || *inp == TAB)
      inp++;
   if (*inp == '-') {
     neg = true;
     inp++;
     }
   else
     neg = false;
   for (intval = 0; *inp; inp++) {
      d = *inp - '0';
      if (d < 0 || d > 9)		/* non-digit */
         break;
      intval = 10 * intval + d;
      }
   *index = inp - in + 1;
   return neg ? -intval : intval;
}
$eod
$ create IBMPC.C
$deck
From:	V04::ROTHAUS      "Miker"  3-AUG-1988 10:46
To:	WOOD
Subj:	IBMPC.C

Here is the C module which contains the EGA (also included in EMACSSRC.ARC):

/*
 * The routines in this file provide support for the IBM-PC and other
 * compatible terminals. It goes directly to the graphics RAM to do
 * screen output. It compiles into nothing if not an IBM-PC driver
 * Supported monitor cards include CGA, MONO and EGA.
 */

#define	termdef	1			/* don't define "term" external */

#include        <stdio.h>
#include	"estruct.h"
#include	"etype.h"
#include        "edef.h"

#if     IBMPC
#define NROW	50			/* Max Screen size.		*/
#define NCOL    80                      /* Edit if you want to.         */
#define	MARGIN	8			/* size of minimim margin and	*/
#define	SCRSIZ	64			/* scroll size for extended lines */
#define	NPAUSE	200			/* # times thru update to pause */
#define BEL     0x07                    /* BEL character.               */
#define ESC     0x1B                    /* ESC character.               */
#define	SPACE	32			/* space character		*/

#define	SCADC	0xb8000000L		/* CGA address of screen RAM	*/
#define	SCADM	0xb0000000L		/* MONO address of screen RAM	*/
#define SCADE	0xb8000000L		/* EGA/VGA address of screen RAM*/

#define MONOCRSR 0x0B0D			/* monochrome cursor		*/
#define CGACRSR 0x0607			/* CGA cursor			*/
#define EGACRSR 0x0709			/* EGA/VGA cursor		*/

#define	CDCGA	0			/* color graphics card		*/
#define	CDMONO	1			/* monochrome text card		*/
#define	CDEGA	2			/* EGA color adapter		*/
#define	CDVGA	3			/* VGA color adapter		*/
#define	CDSENSE	9			/* detect the card type		*/

#define NDRIVE	4			/* number of screen drivers	*/

int dtype = -1;				/* current display type		*/
char drvname[][8] = {			/* screen resolution names	*/
	"CGA", "MONO", "EGA", "VGA"
};
long scadd;				/* address of screen ram	*/
int *scptr[NROW];			/* pointer to screen lines	*/
unsigned int sline[NCOL];		/* screen line image		*/
int egaexist = FALSE;			/* is an EGA card available?	*/
int vgaexist = FALSE;			/* is video graphics array available? */
extern union REGS rg;			/* cpu register for use of DOS calls */

PASCAL NEAR ibmmove();
PASCAL NEAR ibmeeol();
PASCAL NEAR ibmputc();
PASCAL NEAR ibmeeop();
PASCAL NEAR ibmrev();
PASCAL NEAR ibmcres();
PASCAL NEAR spal();
PASCAL NEAR ibmbeep();
PASCAL NEAR ibmopen();
PASCAL NEAR ibmclose();
PASCAL NEAR ibmkopen();
PASCAL NEAR ibmkclose();
PASCAL NEAR scinit();
int PASCAL NEAR getboard();
PASCAL NEAR egaopen();
PASCAL NEAR egaclose();
PASCAL NEAR fnclabel();

#if	COLOR
PASCAL NEAR ibmfcol();
PASCAL NEAR ibmbcol();
int	cfcolor = -1;		/* current forground color */
int	cbcolor = -1;		/* current background color */
int	ctrans[] =		/* ansi to ibm color translation table */
	{0, 4, 2, 6, 1, 5, 3, 7};
#endif

/*
 * Standard terminal interface dispatch table. Most of the fields point into
 * "termio" code.
 */
TERM    term    = {
	NROW-1,
        NROW-1,
        NCOL,
        NCOL,
	MARGIN,
	SCRSIZ,
	NPAUSE,
        ibmopen,
        ibmclose,
	ibmkopen,
	ibmkclose,
        ttgetc,
	ibmputc,
        ttflush,
        ibmmove,
        ibmeeol,
        ibmeeop,
        ibmbeep,
	ibmrev,
	ibmcres
#if	COLOR
	, ibmfcol,
	ibmbcol
#endif
};

#if	COLOR
PASCAL NEAR ibmfcol(color)	/* set the current output color */

int color;	/* color to set */

{
	cfcolor = ctrans[color];
}

PASCAL NEAR ibmbcol(color)	/* set the current background color */

int color;	/* color to set */

{
        cbcolor = ctrans[color];
}
#endif

PASCAL NEAR ibmmove(row, col)
{
	rg.h.ah = 2;		/* set cursor position function code */
	rg.h.dl = col;
	rg.h.dh = row;
	rg.h.bh = 0;		/* set screen page number */
	int86(0x10, &rg, &rg);
}

PASCAL NEAR ibmeeol()	/* erase to the end of the line */

{
	unsigned int attr;	/* attribute byte mask to place in RAM */
	unsigned int *lnptr;	/* pointer to the destination line */
	int i;
	int ccol;	/* current column cursor lives */
	int crow;	/*	   row	*/

	/* find the current cursor position */
	rg.h.ah = 3;		/* read cursor position function code */
	rg.h.bh = 0;		/* current video page */
	int86(0x10, &rg, &rg);
	ccol = rg.h.dl;		/* record current column */
	crow = rg.h.dh;		/* and row */

	/* build the attribute byte and setup the screen pointer */
#if	COLOR
	if (dtype != CDMONO)
		attr = (((cbcolor & 15) << 4) | (cfcolor & 15)) << 8;
	else
		attr = 0x0700;
#else
	attr = 0x0700;
#endif
	lnptr = &sline[0];
	for (i=0; i < term.t_ncol; i++)
		*lnptr++ = SPACE | attr;

	if (flickcode && (dtype == CDCGA)) {
		/* wait for vertical retrace to be off */
		while ((inp(0x3da) & 8))
			;
	
		/* and to be back on */
		while ((inp(0x3da) & 8) == 0)
			;
	}			

	/* and send the string out */
	movmem(&sline[0], scptr[crow]+ccol, (term.t_ncol-ccol)*2);

}

PASCAL NEAR ibmputc(ch) /* put a character at the current position in the
		   current colors */

int ch;

{
	/* if its a newline, we have to move the cursor */
	if (ch == '\n' || ch == '\r') {
		rg.h.ah = 3;
		int86(0x10, &rg, &rg);
		if (rg.h.dh == 24) {
			ibmmove(20, 0);
			/* we must scroll the screen */
			rg.h.ah = 6;	/* scroll up */
			rg.h.al = 1;	/* # of lines to scroll by */
			rg.h.bh = cfcolor; /* attribute for blank line */
			rg.x.cx = 0;	/* upper left corner of scroll */
			rg.x.dx = 0x184f;/* lower right */
			int86(0x10, &rg, &rg);
			rg.h.dh = 23;
		}
		ibmmove(rg.h.dh + 1, 0);
		return;
	}

	rg.h.ah = 14;		/* write char to screen with current attrs */
	rg.h.al = ch;
#if	COLOR
	if (dtype != CDMONO)
		rg.h.bl = cfcolor;
	else
		rg.h.bl = 0x07;
#else
	rg.h.bl = 0x07;
#endif
	int86(0x10, &rg, &rg);
}

PASCAL NEAR ibmeeop()
{
	int attr;		/* attribute to fill screen with */

	rg.h.ah = 6;		/* scroll page up function code */
	rg.h.al = 0;		/* # lines to scroll (clear it) */
	rg.x.cx = 0;		/* upper left corner of scroll */
	rg.x.dx = (term.t_nrow << 8) | (term.t_ncol - 1);
				/* lower right corner of scroll */
#if	COLOR
	if (dtype != CDMONO)
		attr = ((ctrans[gbcolor] & 15) << 4) | (ctrans[gfcolor] & 15);
	else
		attr = 0;
#else
	attr = 0;
#endif
	rg.h.bh = attr;
	int86(0x10, &rg, &rg);
}

PASCAL NEAR ibmrev(state)	/* change reverse video state */

int state;	/* TRUE = reverse, FALSE = normal */

{
	/* This never gets used under the IBM-PC driver */
}

PASCAL NEAR ibmcres(res) /* change screen resolution */

char *res;	/* resolution to change to */

{
	int i;		/* index */

	for (i = 0; i < NDRIVE; i++)
		if (strcmp(res, drvname[i]) == 0) {
			scinit(i);
			return(TRUE);
		}
	return(FALSE);
}

PASCAL NEAR spal()	/* reset the pallette registers */

{
	/* nothin here now..... */
}

PASCAL NEAR ibmbeep()
{
#if	MWC
	ttputc(BEL);
#else
	bdos(6, BEL, 0);
#endif
}

PASCAL NEAR ibmopen()
{
	scinit(CDSENSE);
	revexist = TRUE;
        ttopen();
}

PASCAL NEAR ibmclose()

{
#if	COLOR
	ibmfcol(7);
	ibmbcol(0);
#endif
	/* if we had the EGA open... close it */
	if (dtype == CDEGA || dtype == CDVGA)
		egaclose();

	ttclose();
}

PASCAL NEAR ibmkopen()	/* open the keyboard */

{
	rg.x.ax = 0x3301;
	rg.h.dl = 0x00;
	intdos(&rg, &rg);
}

PASCAL NEAR ibmkclose() /* close the keyboard */

{
}

PASCAL NEAR scinit(type) /* initialize the screen head pointers */

int type;	/* type of adapter to init for */

{
	union {
		long laddr;	/* long form of address */
		int *paddr;	/* pointer form of address */
	} addr;
	int i;

	/* if asked...find out what display is connected */
	if (type == CDSENSE)
		type = getboard();

	/* if we have nothing to do....don't do it */
	if (dtype == type)
		return(TRUE);

	/* if we try to switch to EGA and there is none, don't */
	if (type == CDEGA && !egaexist)
		return(FALSE);

	/* if we try to switch to VGA and there is none, don't */
	if (type == CDVGA && !vgaexist )
		return(FALSE);

	/* if we had the EGA or VGA open... close it */
	if (dtype == CDEGA || dtype == CDVGA)
		egaclose();

	/* and set up the various parameters as needed */
	switch (type) {
		case CDMONO:	/* Monochrome adapter */
				scadd = SCADM;
				newsize(TRUE, 25);
				break;

		case CDCGA:	/* Color graphics adapter */
				scadd = SCADC;
				newsize(TRUE, 25);
				break;

		case CDEGA:	/* Enhanced graphics adapter */
				scadd = SCADE;
				egaopen();
				newsize(TRUE, 43);
				break;

		case CDVGA:	/* video graphics array - acts as EGA but more lines */
				scadd = SCADE;
				egaopen();
				newsize(TRUE, 50);
				break;
	}

	/* reset the $sres environment variable */
	strcpy(sres, drvname[type]);
	dtype = type;

	/* initialize the screen pointer array */
	for (i = 0; i < NROW; i++) {
		addr.laddr = scadd + (long)(NCOL * i * 2);
		scptr[i] = addr.paddr;
	}
	return(TRUE);
}

/* getboard:	Determine which type of display board is attached.
		Current known types include:

		CDMONO	Monochrome graphics adapter
		CDCGA	Color Graphics Adapter
		CDEGA	Extended graphics Adapter
		CDVGA	Vidio Graphics Array

		if MONO	set to MONO
		   CGA	set to CGA	EGAexist = FALSE VGAexist = FALSE
		   EGA	set to CGA	EGAexist = TRUE  VGAexist = FALSE
		   VGA	set to CGA	EGAexist = TRUE  VGAexist = TRUE
*/

int PASCAL NEAR getboard()

{
	int type;	/* board type to return */

	type = CDCGA;
	int86(0x11, &rg, &rg);
	if ((((rg.x.ax >> 4) & 3) == 3))
		type = CDMONO;

	/* test if EGA present */
	rg.x.ax = 0x1200;
	rg.x.bx = 0xff10;
	int86(0x10,&rg, &rg);		/* If EGA, bh=0-1 and bl=0-3 */
	egaexist = !(rg.x.bx & 0xfefc);	/* Yes, it's EGA */
	if (egaexist) {
		/* Adapter says it's an EGA. We'll get the same response
		   from a VGA, so try to tell the two apart */
		rg.x.ax = 0x1a00;	/* read display combination */
		int86(0x10,&rg,&rg);
		if (rg.h.al == 0x1a && (rg.h.bl == 7 || rg.h.bl == 8)) {
			/* Function is supported and it's a PS/2 50,60,80 with
			   analog display, so it's VGA (I hope!) */
			vgaexist = TRUE;
		} else {
			/* Either BIOS function not supported or something
			   other then VGA so set it to be EGA */
			vgaexist = FALSE;
		}
	}
	return(type);
}

PASCAL NEAR egaopen()	/* init the computer to work with the EGA or VGA */

{
	/* put the beast into EGA 43/VGA 50 line mode */
	rg.x.ax = 3;
	int86(16, &rg, &rg);

	rg.h.ah = 17;		/* set char. generator function code */
	rg.h.al = 18;		/*  to 8 by 8 double dot ROM         */
	rg.h.bl = 0;		/* block 0                           */
	int86(16, &rg, &rg);

	rg.h.ah = 18;		/* alternate select function code    */
	rg.h.al = 0;		/* clear AL for no good reason       */
	rg.h.bl = 32;		/* alt. print screen routine         */
	int86(16, &rg, &rg);

	rg.h.ah = 1;		/* set cursor size function code */
	rg.x.cx = 0x0607;	/* turn cursor on code */
	int86(0x10, &rg, &rg);

	outp(0x3d4, 10);	/* video bios bug patch */
	outp(0x3d5, 6);
}

PASCAL NEAR egaclose()

{
	/* put the beast into 80 column mode */
	rg.x.ax = 3;
	int86(16, &rg, &rg);
}

PASCAL NEAR scwrite(row, outstr, forg, bacg)	/* write a line out*/

int row;	/* row of screen to place outstr on */
char *outstr;	/* string to write out (must be term.t_ncol long) */
int forg;	/* forground color of string to write */
int bacg;	/* background color */

{
	unsigned int attr;	/* attribute byte mask to place in RAM */
	unsigned int *lnptr;	/* pointer to the destination line */
	int i;

	/* build the attribute byte and setup the screen pointer */
#if	COLOR
	if (dtype != CDMONO)
		attr = (((ctrans[bacg] & 15) << 4) | (ctrans[forg] & 15)) << 8;
	else
		attr = (((bacg & 15) << 4) | (forg & 15)) << 8;
#else
	attr = (((bacg & 15) << 4) | (forg & 15)) << 8;
#endif
	lnptr = &sline[0];
	for (i=0; i<term.t_ncol; i++)
		*lnptr++ = (outstr[i] & 255) | attr;

	if (flickcode && (dtype == CDCGA)) {
		/* wait for vertical retrace to be off */
		while ((inp(0x3da) & 8))
			;
	
		/* and to be back on */
		while ((inp(0x3da) & 8) == 0)
			;
	}

	/* and send the string out */
	movmem(&sline[0], scptr[row],term.t_ncol*2);
}

#if	FLABEL
PASCAL NEAR fnclabel(f, n)	/* label a function key */

int f,n;	/* default flag, numeric argument [unused] */

{
	/* on machines with no function keys...don't bother */
	return(TRUE);
}
#endif
#else
ibmhello()
{
}
#endif

$eod
$ create INDENT.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "memory.cmn"
#include "session.cmn"

void advance_over_white_space(void)
{
  char c;
  bufferp bu;
  textind tx;

  bu = se_current_buffer;
  for (tx = wi_dot(se_current_window); tx <= bu_size(bu); tx++) {
    c = tx_text(tx_address(bu,tx));
    if (c != ' ' && c != TAB)
      break;
    }
  wi_dot(se_current_window) = tx;
}

void delete_white_space(void)
{
  char c;
  bufferp bu;
  textind tx;

  bu = se_current_buffer;
  advance_over_white_space();
  for (tx = wi_dot(se_current_window) - 1; tx > 0; tx--) {
    c = tx_text(tx_address(bu,tx));
    if (c == ' ' || c == TAB)
      delete_previous_character();
    else
      break;
    }
}

void do_indent(textind n)
{
  mp_beginning_of_line();
  if (! q_mp_at_comment()) {
    set_indent(current_column() + n);
    delete_white_space();
    if (! q_eol())
      tab_to_column(bu_indent(se_current_buffer));
    }
  next_line();
}

textind current_indent(void)
{
  textind t, indent;

  t = wi_dot(se_current_window);
  mp_beginning_of_line();
  indent = current_column();
  wi_dot(se_current_window) = t;
  return indent;
}

textind current_column(void)
{
  bufferp bu;
  textind tx, t, col;

  t = wi_dot(se_current_window);
  beginning_of_line();
  bu = se_current_buffer;
  col = 0;
  for (tx = wi_dot(se_current_window); tx < t; tx++)
    if (tx_text(tx_address(bu,tx)) == TAB)
      col += 8-mod(col,8);
    else
      col++;
  wi_dot(se_current_window) = t;
  return col + 1;
}

void goto_column(textind n)
{
  bufferp bu;
  textind tx, col;
  char c;

  beginning_of_line();
  bu = se_current_buffer;
  col = 0;
  for (tx = wi_dot(se_current_window); tx <= bu_size(bu) && col+1 < n; tx++) {
    c = tx_text(tx_address(bu,tx));
    if (c == TAB)
      col += 8-mod(col,8);
    else if (c == NEWLINE)
      break;
    else
      col++;
    }
  wi_dot(se_current_window) = tx;
}

void set_indent(textind n)
{
  bu_indent(se_current_buffer) = max(mp_minimum_indent(se_current_buffer), n);
}

void tab_to_column(textind n)
{
  textind i, tabcol;

  for (i = current_column(); i < n; i++) {
    tabcol = i-1+8-mod(i-1,8);
    if (tabcol < n) {
      i = tabcol;
      insert_character(TAB);
      }
    else
      insert_character(' ');
    }
}
$eod
$ create INSERT.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "session.cmn"
#include "insert.cmn"
#include "mappings.cmn"
#include "memory.cmn"

void in_enter(void)
{
  stringp st;
# include "terminal.cmn"

  in_cr = false;
  if (te_in)
    in_deol = false;
  else
    in_deol = true;
  st = st_allocate(st_length(wi_mode_line(se_current_window)) + 5);
  ho_scopy("<I> ", 1, st_buffer(st), 1);
  st_scopy(wi_mode_line(se_current_window), st+4);
  wi_mode_line(se_current_window) = st;
  wi_modified(se_current_window) = 1;
  in_reenter();
  bi_use_keymap(INSERT_MODE);
}

void in_reenter(void)
{
  int modif, i;
  textind tdot, col;

  modif = bu_modified(se_current_buffer);
  tdot = wi_dot(se_current_window);
  if (in_cr)
    for (i = 1; i <= wi_size(se_current_window); i++)
      insert_character(NEWLINE);
  else if (in_deol)
    delete_region_to_buffer("insert-tmp",tdot,
    					find_eol(se_current_buffer,tdot));
  else {
    col = current_column();
    insert_character(NEWLINE);
    tab_to_column(col);
    }
  in_nchars = wi_dot(se_current_window) - tdot;
  wi_dot(se_current_window) = tdot;
  bu_modified(se_current_buffer) = modif;
  sc_fill_new();
}

void in_exit(void)
{
  in_post_inserted_text();
  st_deallocate(wi_mode_line(se_current_window));
  wi_mode_line(se_current_window) = bu_name(se_current_buffer);
  wi_modified(se_current_window) = 1;
  bi_use_keymap(CONTROL_MODE);
}

void in_post_inserted_text(void)
{
  int modif;
  textind tdot;

  mp_mark = 0;
  modif = bu_modified(se_current_buffer);
  if (in_deol) {
    tdot = wi_dot(se_current_window);
    yank_buffer("insert-tmp");
    wi_dot(se_current_window) = tdot;
    }
  else if (in_nchars > 0)
    delete_region(wi_dot(se_current_window),
		  wi_dot(se_current_window) + in_nchars);
  bu_modified(se_current_buffer) = modif;
}

void in_escape(void)
{
  if (q_mp_empty())
    in_exit();
  else
    mp_pop();
}

void in_carriage_return(void)
{
# include "terminal.cmn"

  insert_character(NEWLINE);
  in_post_inserted_text();
  if (wi_size(se_current_window) > 1 && !(te_in || in_cr)) {
    in_cr = true;
    in_deol = false;
    }
  in_reenter();
}

void in_increase_indent(void)
{
  mp_beginning_of_line();
  if (! q_mp_at_comment()) {
    delete_white_space();
    set_indent(bu_indent(se_current_buffer) + se_indent);
    tab_to_column(bu_indent(se_current_buffer));
    }
  end_of_line();
}

void in_decrease_indent(void)
{
  mp_beginning_of_line();
  if (! q_mp_at_comment()) {
    delete_white_space();
    set_indent(bu_indent(se_current_buffer) - se_indent);
    tab_to_column(bu_indent(se_current_buffer));
    }
  end_of_line();
}

void in_self_insert(void)
{
# include "pushb.cmn"
# include "screen.cmn"
  char c;

  c = pu_last_key_struck;
  if (bu_case(se_current_buffer) == 1)
    if (c >= 'a' && c <= 'z')
      c = c - 040;
  if (wi_modified(se_current_window) == 0) {
    insert_character(c);
    wi_modified(se_current_window) = 0;
    sc_add_to_line(sc_cursor_y, &c, 1);
    }
  else
    insert_character(c);
}

void in_delete_previous_character(void)
{
# include "screen.cmn"
  register char c;

  if (wi_dot(se_current_window) > 1) {
    c = tx_text(tx_address(se_current_buffer, wi_dot(se_current_window) - 1));
    if (c == NEWLINE) {
      if (se_cross_lines)
	delete_previous_character();
      }
    else if (c >= ' ' && c <= '~') {
      if (wi_modified(se_current_window) == 0 &&
			      sc_new_length(sc_cursor_y) < sc_width) {
	delete_previous_character();
	wi_modified(se_current_window) = 0;
	sc_new_length(sc_cursor_y) = sc_new_length(sc_cursor_y) - 1;
	sc_modified(sc_cursor_y) = true;
	}
      else
	delete_previous_character();
      }
    else
      delete_previous_character();
    }
}
$eod
$ create INSERT.CMN
$deck
declare int in_nchars;

declare char
	in_cr,
	in_deol;
$eod
$ create IOBUFFER.C
$deck
/* Zilch Screen Editor,
 *	Copyright (c) 1982,1983,1984,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "terminal.cmn"
#include "syscodes.h"

#if VMS
# include "descr.h"

void ti_initialize(void)
{
  long int plen, pid, biocnt, bytcnt, astcnt;
  int status;
  char ttnam[63], process_name[16];
  vms_char_descr(d_ttnam, ttnam, 63);
  static vms_char_descr(d_sys$command, "SYS$COMMAND", sizeof("SYS$COMMAND")-1);

  ti_flush_iofc = IO$_WRITEVBLK | IO$M_NOFORMAT;
  ti_in_type_ahead_iofc = IO$_READVBLK | IO$M_TRMNOECHO | IO$M_NOFILTR |
	IO$M_NOECHO | IO$M_TIMED;
  ti_in_character_iofc = IO$_READVBLK | IO$M_TRMNOECHO | IO$M_NOFILTR |
	IO$M_NOECHO;
  icr_trnlog_str(&d_sys$command, &d_ttnam);
  ti_channel = 0;
  status = 0;
  plen = sizeof(process_name);
  if (get_process_info(process_name, &plen, &pid, &biocnt, &bytcnt, &astcnt)) {
    if (astcnt >= 3 && biocnt >= 3 &&
    				bytcnt >= BUFFER_SIZE + MBX_SIZE + 2048) {
      sprintf(mbx.name, "Z_%08x", pid);
      status = sys$crembx(0, &mbx.channel, MBX_SIZE,
			  min(4*MBX_SIZE, bytcnt - BUFFER_SIZE - 2048),
			  0xFF0F, 0, &d_mbx_name);
      if (status)
	status = sys$assign(&d_ttnam, &ti_channel, 0, &d_mbx_name);
      if (status) {
	ef_in_mask = (1 << TI_IN_EFN) + (1 << MBX_IN_EFN);
	mbx_read();
	}
      }
    }
  if (! status) {
    mbx.channel = 0;
    ef_in_mask = 1 << TI_IN_EFN;
    status = sys$assign(&d_ttnam, &ti_channel, 0, 0);
    }
  ti_get_characteristics();
  ti_disable_ctrl();
}

void ti_disable_ctrl(void)
{
  long int di_mask[2] = { 0, 0x8 };

  if (ttclass == dc$_term) {
    lib$disable_ctrl(0x100000, ti_ctrl_mask);		/* disable ^T */
    status = sys$qiow(0, ti_channel,			/* enable ^C AST */
		  IO$_SETMODE | IO$M_OUTBAND, iosb,
		  0, 0, ti_ctrl_ast, di_mask, 0, 0, 0, 0);
    ttchar_save = ttchar;
    ttxchar_save = ttxchar;
    ttchar = (ttchar | TT$M_NOBRDCST | TT$M_MECHFORM) & (! TT$M_MECHTAB);
    if (mbx.channel != 0) {
      ttchar = ttchar | TT$M_MBXDSABL;
      ttxchar = ttxchar | TT2$M_BRDCSTMBX;
      }
    status = sys$qiow( , %val(ti_channel), %val(IO$_SETMODE), iosb,
		       , , characteristics, %val(12), , , , );
    ttchar = ttchar_save;
    ttxchar = ttxchar_save;
    }
  return;

  entry ti_enable_ctrl
  if (ttclass == dc$_term) {
    status = sys$qiow( , %val(ti_channel), %val(IO$_SETMODE), iosb,
		       , , characteristics, %val(12), , , , );
    status = sys$qiow( , %val(ti_channel),		/* disable ^C AST */
		  %val(IO$_SETMODE | IO$M_OUTBAND), iosb,
		  , , %val(0), di_mask, %val(0), , , );
    lib$enable_ctrl(ti_ctrl_mask);			/* enable ^T */
    }
  return
}

void ti_ctrl_ast(void)
{
# include "memory.cmn"
# include "pushb.cmn"
# include "session.cmn"
# include "screen.cmn"

  if (se_count > 1) {				/* abort repeating commands */
    se_count = 0;
    sc_error_occurred = true;
    se_error_occurred = true;
    }
  else if (pu_buffer != null)
    if (bu_size(pu_buffer) > 0) {		/* abort pushed back commands */
      sc_error_occurred = true;
      se_error_occurred = true;
      }
  else if (se_interrupt_enabled) {		/* handling interrupts */
    sc_error_occurred = true;
    se_error_occurred = true;
    }
  return;
}

void ti_finish(void)
{

  ti_enable_ctrl();
  status = sys$dassgn(%val(ti_channel));
  if (mbx.channel != 0)
    status = sys$dassgn(%val(mbx.channel));
  return
}

void ti_get_characteristics(void)
{
  int first;
  save first;
  data first /true/;

  if (first) {
    first = false;
    status = sys$qiow( , %val(ti_channel), %val(IO$_SENSEMODE), iosb,
		  , , characteristics, %val(12), , , , );
    if (ttclass != dc$_term) {
      ti_channel = 0;
      te_type = VT100;
      ti_fast = true;
      ti_lffill = 0;
      ti_width = 80;
      ti_length = 24;
      }
    else {
      if (tttype == TT$_VT52)
	te_type = VT52;
      else if ((ttxchar & TT2$M_DECCRT) != 0)
	te_type = VT100;
      else if (tttype == TT$_VT100 ||
	       tttype == TT$_VT101 ||
	       tttype == TT$_VT102 ||
	       tttype == TT$_VT105 ||
	       tttype == TT$_VT125 ||
	       tttype == TT$_VT131 ||
	       tttype == TT$_VT132 ||
	       tttype == TT$_VT200_SERIES)
	te_type = VT100;
      else
	te_type = ADM3A;
/* ti_fast should be set true at speeds over 2400 baud. */
      if (ttspeed > TT$C_BAUD_2400)
	ti_fast = true;
      else
	ti_fast = false;
      ti_lffill = lffill;
      if (ti_lffill > 24 || ti_lffill < 0)
	ti_lffill = 24;
      ti_width = ttwidth;
      ti_length = ttlength;
      }
    }
  return
}
 
void ti_outch(const char *output, int count)
{
  data ti_count/0/;

  for (ip = 1; ip <= count; ip = ip+n) {
    if (ti_count >= BUFFER_SIZE)
      ti_flush();
    n = min(count+1-ip, BUFFER_SIZE - ti_count);
    movc(output(ip), ti_buffer[ti_count], n);
    ti_count = ti_count + n;
    }
  return
}

void ti_flush(void)
{

  if (ti_count > 0) {
    sys$qiow( , %val(ti_channel), %val(ti_flush_iofc), , , , ti_buffer,
 	%val(ti_count), , %val(0), , );
    ti_count = 0;
    }
  return
}

void ti_kill(void)
{

  ti_count = 0;
  return
}

pint q_ti_in_type_ahead(c)
{
  char c;

  sys$qiow( , %val(ti_channel), %val(ti_in_type_ahead_iofc),
		iosb, , , c, %val(1), %val(0), , , );
  if (trm_offset + trm_size > 0) {
    if (c == 033)
      ti_interpret_escape(c);
    return true;
    }
  return false;
}

void ti_queue_character_read(void)
{
  integer errcnt;
  save errcnt;
  data errcnt /0/;

  ti_character = 031;				/* ^Y */
  if (! sys$qio(%val(TI_IN_EFN), %val(ti_channel), %val(ti_in_character_iofc),
	  iosb, , , ti_character, %val(1), , , , )) {
    errcnt++;
    if (errcnt > 6)
      ti_exit();
    ti_character = 0;				/* indicates QIO error */
    iosb_status = 1;
    }
  return
}

void ti_get_character(c)
{
  char c;

  if (! iosb_status) {
L10: sys$wflor(%val(TI_IN_EFN), %val(ef_in_mask));
    if (! iosb_status) {
      mbx_handler();
      goto L10;
      }
    }
  c = ti_character;
  if (c == 033)
    ti_interpret_escape(c);
  return
}

void ti_interpret_escape(c)
{
# include "bind.cmn"
  byte c, ta_characteristics(8), ta_character;
  integer*2 ta_count;
  equivalence (ta_characteristics(1), ta_count),
	      (ta_characteristics(3), ta_character)
  integer*4 delta(2);
  data delta/_arith(20,*,-100000), -1/		/* wait in 100ths of seconds */

  if (bind.alternate_escape != EOS) {
    sys$qiow( , %val(ti_channel), %val(IO$_SENSEMODE | IO$M_TYPEAHDCNT),
		  , , , ta_characteristics, %val(8), , , , );
    if (ta_count == 0) {
      sys$setimr(%val(0), delta, , );
      sys$waitfr(%val(0));
      sys$qiow( , %val(ti_channel), %val(IO$_SENSEMODE | IO$M_TYPEAHDCNT),
		    , , , ta_characteristics, %val(8), , , , );
      }
    if (ta_count != 0)
      if (bind.alternate_escape_followers[ta_character])
	c = bind.alternate_escape;
    }
  return
}

void ti_exit(void)
{

  ti_kill();
  te_finish();
  ti_flush();
  ti_finish();
  dcl_finish();
  checkpoint_modified_files();
  ed_save_session();
  stop _
"Zilch - QIO error! Attempted to checkpoint modified files. Exiting...";
}

void mbx_handler(void)
{
# include "memory.cmn"
# include "session.cmn"
# include "screen.cmn"
%	#include '($msgdef)'
  int mbread;
  character date*23;
  static const char bell[] = "\7",
		    crlf[] = "\15\12";
  static char bname[] = "Broadcast  9-Jul-1984 11:56:07.00";
  equivalence (date, bname(11))

  mbread = false;
  if (! mbx.iosb.status)
    ;
  else if (mbx.bdcst.type == msg$_trmbrdcst && mbx.iosb.byte_count >= 2) {
    lib$sys_asctim( , date);
    mlen = mbx.bdcst.size;
    if (q_bu_pop_up_message(mbx.bdcst.msg, mlen, bname)) {
      sc_fill_line(sc_size,sc_buffer(1,sc_size,sc_old),
			sc_old_length(sc_size));
      sc_update(&zero);
      ti_outch(bell, 1);
      }
    else {
      send_tty(crlf, 2);
      send_tty(mbx.bdcst.msg, mlen);
      }
    ti_flush();
    }
  else if (mbx.iosb.byte_count < 2 ||
      (mbx.bdcst.type != msg$_trmhangup && mbx.bdcst.type != msg$_trmunsolic)) {
    bu = bu_find_by_name("Session log");
    if (bu != null) {
      t = bu_size(bu) + 1;
      mlen = mbx.iosb.byte_count;
      if (bu_gap_size(bu) < mlen)
	tx_more_memory_please(bu,4*4*512+mlen);
      tx_insert_buffer(bu, bu_size(bu) + 1, mbx.buffer, mlen);
      mbx_read();
      mbread = true;
      tx_insert_character(bu, NEWLINE, bu_size(bu) + 1);
      bu_map_windows(bu,wi)
	if (wi_dot(wi) == t) {			/* display new stuff in window */
	  wi_dot(wi) = bu_size(bu) + 1;
	  t2 = wi_dot(wi);
	  for (i = 1; i < wi_size(wi); i = i+1)
	    t2 = find_bol(bu, max(1, t2 - 1));
	  if (wi_bow(wi) < t2)
	    wi_set_bow(wi,t2);
	  }
      bu_modified(bu) = 0;
      if (! mbx.iosb.status && ! iosb_status) {
	sc_fill_line(sc_size,sc_buffer(1,sc_size,sc_old),
			  sc_old_length(sc_size));
	sc_update(&zero);
	}
      }
    }
  if (! mbread)
    mbx_read();
  return
}

void mbx_read(void)
{
  external mbx_ast();

  status = sys$qio(%val(MBX_IN_EFN), %val(mbx.channel), %val(IO$_READVBLK),
	     mbx.iosb, mbx_ast, , mbx.buffer, %val(MBX_SIZE), , , , );
  return
}

void mbx_ast(void)
{
%	#include '($msgdef)'

  if (! mbx.iosb.status)
    ;
  else if (mbx.bdcst.type == msg$_trmhangup && mbx.iosb.byte_count >= 2) {
    checkpoint_modified_files();
    ed_save_session();
    }
  return
}

#endif
$eod
$ create KEY.BND
$deck
  # Zilch Screen Editor, Copyright (c) 1982,1983,1984,1986,1987 William P. Wood, Jr.
  # Keyboard bindings and function definitions for standard Zilch
  # This file is %included by ZBIND.BND

%include				[]key1.bnd
%include				[]key2.bnd
$eod
$ create KEY1.BND
$deck
  # Zilch Screen Editor
  #   Copyright (c) 1982,1983,1984,1986,1987,1988 William P. Wood, Jr.
  # Keyboard bindings and function definitions for standard Zilch
  # This file is %included by KEY.BND
  # It contains all the standard Zilch functions.  New functions may be added
  # as follows:
  #	%include key1.bnd
  #	%include NEWFUNCS.bnd
  #	%include key2.bnd

%mode					control		# {control,insert,0-9}
  # Begin initial code
  define(header,implicit integer (a-p,r-z); implicit logical (q)
    include "session.cmn"
    include "bind.cmn"
    include "pushb.cmn"
    include "memory.cmn")

  define(unbound_key_sequence,
      if (cmd < 1000)
	call ms_error(EOS)
      else if (cmd < 2000)
	call ky_macro(cmd-1000)
      else if (cmd < 3000) {
	hugcol = abs(hugcol)
	call ma_invoke(cmd-1999)
	}
      else if (cmd < 4000) {
	call ma_replace(cmd-2999)
	call ms_report_number("Renamed macro 0 to macro ",cmd-3000,EOS)
	}
      else if (cmd < 5000) {
	call bi_use_keymap(cmd-4000)
	call ms_report_number("Mode ",cmd-4000,EOS)
	}
      else
	call ms_error(EOS))
  define(qio_error, if (q_fi_write_modif_file_buffers()) exit)
  define(qio_error_in_insert_mode, se_count = 1; call in_exit)
  define(control_y_interrupt, call redraw)
  define(end_function_definition,next)
  define(exit,goto (10,20), exitla)

    subroutine ky_edit
    header
    byte c, c2, find_next_character
    save checkpoint_frequency
    data checkpoint_frequency /400/

    st = st_allocate(MAX_PROMPT)
    exitla = 1
    hugcol = 0
    call pa_ready(se_current_page)
  20
    if (exitla == 2) {
      exitla = 1
      call pa_switch(pa_number(paold))
      }
    repeat {
      if (bu_size(pu_buffer) == 0) {
	se_command_count = se_command_count+1
	if (se_command_count >= checkpoint_frequency)
	  if (pu_last_key_struck != RUBOUT) {
	    call checkpoint_modified_files
	    se_command_count = 0
	    }
	}
      cmd = bi_get_command()
      se_count = 2
      while (se_count > 1 && ! se_error_occurred) {
	se_count = se_count - 1
	hugcol = - max(0,hugcol)
  # End initial code

repeat_count				0-9
	hugcol = abs(hugcol)
	call ky_repeat_count(se_count,cmd)
redraw					r
	call redraw
exit					^M		# Carriage return
	exit
write_all_modified_files_and_exit	^Z
	if (q_fi_write_modif_file_buffers())
	  exit
write_all_modified_files		wa
	call q_fi_write_modif_file_buffers
write_current_buffer			^T
	call q_fi_write_buffer(se_current_buffer)
write_named_file			ww
	call q_fi_write_named_file(se_current_buffer)
read_named_file				wr
	call q_fi_read_named_file(se_current_buffer,0)
insert_named_file			wi
	call q_fi_read_named_file(se_current_buffer,wi_dot(se_current_window))
goto_beginning_of_file			t
	call beginning_of_file
goto_last_lines_of_file			e
	call goto_last_lines_of_file
previous_character			h
	call previous_character
next_character				l
	call next_character
previous_line				k
	call scroll_previous_line
next_line				j
	call scroll_next_line
previous_line_and_hug_column		i
	hugcol = abs(hugcol)
	call scroll_previous_line_col(hugcol)
next_line_and_hug_column		u
	hugcol = abs(hugcol)
	call scroll_next_line_col(hugcol)
scroll_one_line_down			^K
	call scroll_one_line_down
	if (! q_dot_is_visible())
	  call previous_line
scroll_one_line_up			^J
	call scroll_one_line_up
	if (! q_dot_is_visible())
	  call next_line
previous_half_screen			g
	call previous_half_screen
next_half_screen			b
	call next_half_screen
previous_screen				y
	call previous_screen
next_screen				n
	call next_screen
previous_word				o
	call previous_word
next_word				p
	call next_word
previous_section			f
	call mp_previous_procedure
next_section				v
	call mp_next_procedure
ends_of_line				m
	call ends_of_line
kill_through_end_of_line		^U
	call kill_through_end_of_line
add_kill_after_cursor			^R
	call yank_kill
set_mark1				<
	call mk_set_mark(bu_mark1_ptr(se_current_buffer),
		wi_dot(se_current_window),se_current_buffer)
	call ms_message("Mark 1 set.")
set_mark2				>
	call mk_set_mark(bu_mark2_ptr(se_current_buffer),
		wi_dot(se_current_window),se_current_buffer)
	call ms_message("Mark 2 set.")
set_mark1				,
set_mark2				.
change_case				x\^
	call case_change
write_text				^P
	call write_text
save_text				s
	call save_text
extract_text				^E
	call extract_text
delete_text				^D
	call delete_text
add_text_after_cursor			^A
	call add_text_after_cursor
save_location				=
	call save_location
exchange_dot_and_save_location		*
	call exchange_dot_and_save_location
goto_save_location			\^
	call goto_save_location
get_current_indent			^I		# Tab
	call set_indent(current_indent())
indent_line				^B
	call do_indent(se_indent)
exdent_line				^V
	call do_indent(-se_indent)
switch_to_page				\#
	if (q_pr_read_prompt("Page number? ",st,len)) {
	  i = 1
	  call switch_to_page(ho_ctoi(st_buffer(st),i))
	  }
previous_page				\-
	call pa_previous_page
next_page				+
	call pa_next_page
list_buffers				wl
	if (exitla == 1) {
	  paold = se_current_page
	  if (q_buffer_list())
	    exitla = 2
	  }
	else
	  call ms_error("Can't enter Buffer list!")
fill_window				wf
	call wi_fill
equalize_window				wq
	call wi_equalize
visit_file				wv
	if (q_pr_read_prompt("Visit file: ",st,len))
	  call multi_visit_file(st_buffer(st),false,true)
	call pa_ready(se_current_page)
change_file				wc
	if (q_pr_read_prompt("Change to file: ",st,len))
	  call multi_visit_file(st_buffer(st),true,true)
	call pa_ready(se_current_page)
change_buffer				wx
	if (q_pr_read_prompt("Change to buffer: ",st,len))
	  call q_switch_to_buffer(null, st_buffer(st))
	call bu_ready(se_current_buffer)
	call wi_ready(se_current_window)
visit_buffer				wb
	if (q_pr_read_prompt("Visit buffer: ",st,len))
	  call q_pop_to_buffer(null, st_buffer(st))
	call bu_ready(se_current_buffer)
	call wi_ready(se_current_window)
enlarge_window				we
	if (! q_enlarge_window())
	  call ms_message("Can't enlarge window!")
shrink_window				ws
	if (! q_shrink_window())
	  call ms_message("Can't shrink window!")
set_minimum_pushed_size_of_window	w\#
	wi_min_size(se_current_window) = wi_size(se_current_window)
	call ms_report_number2("Window size will not be pushed below ",
	  wi_min_size(se_current_window), " line.", " lines.")
split_window				wh
	if (! q_split_current_window())
	  call ms_error("Can't split window!")
previous_window				wp
	call previous_window
next_window				wn
	call next_window
delete_window				wd
	if (! q_delete_window())
	  call ms_error("Can't delete window!")
delete_other_windows			wo
	call delete_other_windows
delete_next_window					/* not bound */
	if (wi_next(se_current_window) != NULL) {
	  call next_window
	  call q_delete_window
	  }
beginning_of_window			wt
	call beginning_of_window
toggle_buffer_case			w\^
	call bu_switch_case
change_mappings				wm
	call mp_change_mappings
start_remembering			[
	hugcol = abs(hugcol)
	call ma_begin
stop_remembering			]
	hugcol = abs(hugcol)
	call ma_end
	se_count = se_count + 1
	cmd = bi_get_command()
write_macros				xw
	if (q_pr_read_prompt("Write macros to file (<CR> for default): ",st,
									len)) {
	  if (len == 0)
	    call st_scopy(se_macros, st)
	  if (! q_ma_write_macros(st_buffer(st))) {
	    call ms_message2("Can't write ",st)
	    call ms_error(EOS)
	    }
	  else {
	    call ms_message2("Wrote macros to ",st)
	    if (len != 0)
	      call ed_save_string(st, se_macros)
	    }
	  }
read_macros				xg
	if (q_pr_read_prompt("Get macros from file (<CR> for default): ",st,
									len)) {
	  if (len == 0)
	    call st_scopy(se_macros, st)
	  if (! q_ma_read_macros(st_buffer(st))) {
	    call ms_message2("Can't read ",st)
	    call ms_error(EOS)
	    }
	  else {
	    call ms_message2("Read macros from ",st)
	    if (len != 0)
	      call ed_save_string(st, se_macros)
	    }
	  }
udk_0 					xm
udk_0 					x0
udk_replace_0				xr0
udk_1 					x1
udk_replace_1				xr1
udk_2 					x2
udk_replace_2				xr2
udk_3 					x3
udk_replace_3				xr3
udk_4 					x4
udk_replace_4				xr4
udk_5 					x5
udk_replace_5				xr5
udk_6 					x6
udk_replace_6				xr6
udk_7 					x7
udk_replace_7				xr7
udk_8 					x8
udk_replace_8				xr8
udk_9 					x9
udk_replace_9				xr9
search_forward				/
	call q_search_forward(se_count)
search_reverse				\\
	call q_search_reverse(se_count)
query_replace_string			c
	call query_replace_string(se_count)
enter_dcl				dcl
	call dcl_call
execute_dcl_command			xdcl
	call dcl_xcall
help					?
	if (exitla == 1) {
	  paold = se_current_page
	  if (q_he_help())
	    exitla = 2
	  }
	else
	  call ms_error("Can't enter Help!")
display_buffer_size			x\#
	call up_display_buffer_size
enter_calc_mode				xc
	call calc
checkpoint_modified_files		!
	if (se_count > 1) {
	  checkpoint_frequency = se_count
	  se_count = 1
	  call ms_report_number("A checkpoint will occur after every ",
	  	checkpoint_frequency, " commands.")
	  }
	else {
	  call ms_message("Checkpointed 0 files.")
	  call checkpoint_modified_files
	  se_command_count = 0
	  }
display_window_status			%
	call wi_status(se_current_window)
delete_and_enter_insert_mode		\177		# Rubout
	for ( ; se_count > 0; se_count = se_count - 1)
	  if (se_cross_lines)
	    call delete_previous_character
	  else if (! q_bol())
	    call delete_previous_character
	call in_enter
delete_white_space			^F
	se_count = 1
	call delete_white_space
	call in_enter
enter_insert_mode			^[		# Escape
	se_count = 1
	call in_enter
macro_x					\40		# Space
	^[\40						# Enter insert, space
enter_overstrike_mode			~
	se_count = 1
	st2 = st_allocate(st_length(wi_mode_line(se_current_window)) + 5)
	call ho_scopy('<O> ', 1, st_buffer(st2), 1)
	call st_scopy(wi_mode_line(se_current_window), st2+4)
	wi_mode_line(se_current_window) = st2
	wi_modified(se_current_window) = 1
	call bi_use_keymap(OVERSTRIKE_MODE)

%mode					insert
in_self_insert				\ -~
	call in_self_insert
in_newline				^M		# Carriage return
	call in_carriage_return
kill_to_beginning_of_line		^U
	call kill_to_beginning_of_line
add_kill_before_cursor			^R
	call yank_buffer("kill")
add_text_before_cursor			^A
	call add_text_before_cursor
in_delete_previous_character		\177		# Rubout
	call in_delete_previous_character
in_delete_white_space			^F
	call in_post_inserted_text
	call delete_white_space
	call in_reenter
in_previous_character			^H
	call in_post_inserted_text
	call previous_character
	call in_reenter
in_next_character			^L
	call in_post_inserted_text
	call next_character
	call in_reenter
in_previous_line			^K
	call in_post_inserted_text
	call scroll_previous_line
	call in_reenter
in_next_line				^J
	call in_post_inserted_text
	call scroll_next_line
	call in_reenter
in_previous_word			^T
	call in_post_inserted_text
	call previous_word
	call in_reenter
in_next_word				^P
	call in_post_inserted_text
	call next_word
	call in_reenter
tab_to_indent				^I		# Tab
	if (current_column() < bu_indent(se_current_buffer))
	  call tab_to_column(bu_indent(se_current_buffer))
	else
	  call insert_character(TAB)
set_indent_at_current_column		^D
	call set_indent(current_column())
in_increase_indent			^E
	call in_increase_indent
in_decrease_indent			^W
	call in_decrease_indent
exit_insert_mode			^[		# Escape
	se_count = 1
	if (q_bi_in_mode(INSERT_MODE))
	  call in_escape
exit_insert_mode_without_popping_mappings	^Z
	se_count = 1
	if (q_bi_in_mode(INSERT_MODE))
	  call in_exit
get_mapping				\\
	call mp_get_mapping
stop_remembering			^]

%mode					overstrike
overstrike				\ -~
	c = pu_last_key_struck
	if (bu_case(se_current_buffer) == 1)
	  if (pu_last_key_struck >= 'a' && pu_last_key_struck <= 'z')
	    c = pu_last_key_struck - 8%40
	c2 = find_next_character()
	if (c2 != NEWLINE)
	  if (c2 != TAB)
	    call delete_next_character
	  else if (mod(current_column(), 8) == 0)
	    call delete_next_character
	call insert_character(c)
overstrike				\\\0-\177
newline					^M		# Carriage-return
	call insert_character(NEWLINE)
overstrike_tab				^I		# TAB
	dot = wi_dot(se_current_window)
	curcol = current_column() - 1
	call goto_column(curcol+8-mod(curcol,8) + 1)
	call delete_region(dot, wi_dot(se_current_window))
	call insert_character(TAB)
delete_previous_character		\177		# Rubout
	if (se_cross_lines)
	  call delete_previous_character
	else if (! q_bol())
	  call delete_previous_character
next_character				^L
previous_character			^H
next_line_and_hug_column		^J
previous_line_and_hug_column		^K
exit_overstrike_mode			^[		# Escape
	se_count = 1
	if (q_bi_in_mode(OVERSTRIKE_MODE)) {
	  call st_deallocate(wi_mode_line(se_current_window))
	  wi_mode_line(se_current_window) = bu_name(se_current_buffer)
	  wi_modified(se_current_window) = 1
	  call bi_use_keymap(CONTROL_MODE)
	  }
exit_overstrike_mode			^Z
stop_remembering			^]

%mode					control
self_insert						# not bound
	c = pu_last_key_struck
	if (bu_case(se_current_buffer) == 1)
	  if (pu_last_key_struck >= 'a' && pu_last_key_struck <= 'z')
	    c = pu_last_key_struck - 8%40
	call insert_character(c)
open_line						# not bound
	call insert_character(NEWLINE)
	call previous_character
delete_next_character					# not bound
	if (se_cross_lines)
	  call delete_next_character
	else if (! q_eol())
	  call delete_next_character
kill_to_end_of_line					# not bound
	call kill_to_end_of_line
goto_end_of_file					# not bound
	call goto_end_of_file
beginning_of_line					# not bound
	call beginning_of_line
end_of_line						# not bound
	call end_of_line
increment_page						# not bound
	call switch_to_page(pa_number(se_current_page) + 1)
message							# not bound
	if (q_pr_read_prompt("Message? ",st,len))
	  call ms_user_message(st_buffer(st), len)
illegal_operation					# not bound
	call ms_error(EOS)
null_operation						# not bound
	continue
$eod
$ create KEY2.BND
$deck
  # Zilch Screen Editor, Copyright (c) 1982,1983,1984,1986,1987 William P. Wood, Jr.
  # This file is %included by KEY.BND
  # It contains the second part of the standard Zilch bindings

	end_function_definition	#MAKEBIND isn't smart enough to put this at end

  # Begin final code
	}
      }
  10
    call st_deallocate(st)
    return
    end

    subroutine ky_repeat_count(count,cmd)
    header

    if (pu_last_key_struck >= '0' && pu_last_key_struck <= '9')
      call pu_push_back_character(pu_last_key_struck)
    if (q_get_tty_number(n,"Repeat count: ")) {
      count = n + 1
      cmd = bi_get_command()
      }
    return
    end

    subroutine ky_macro(num)
    header

    if (num < 0 || num >= NUM_MACROS)
      goto 10
    else if (bind.macros[num] == null) {
  10  call ms_report_number("Undefined macro: ", num, EOS)
      call ms_error(EOS)
      }
    else {
      mlen = bi_mem(bind.macros[num])
      call pu_push_back_buf(bi_mem(bind.macros[num] + 1), mlen)
      }
    return
    end

    subroutine ky_bind_keys
    header
    include "terminal.cmn"

    if (bind.keypad == KEYPAD_APPLICATION)
      te_application_keypad = true
    else
      te_application_keypad = false
    return
    end

  # End final code
$eod
$ create MACRO.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "macro.cmn"

void ma_initialize(void)
{
  int i;

  for (i = 0; i < MAX_MACROS; i++) {
    ma_len[i] = 0;
    ma_start[i] = 0;
    }
  ma_next = 0;
  ma_defining_macro = false;
}

void ma_begin(void)
{
  if (ma_defining_macro)
    ms_error("Already remembering... previous characters lost!");
  else
    ms_message("Remembering...");
  ma_defining_macro = true;
  ma_delete(0);
  ma_start[0] = ma_next;
}

void ma_end(void)
{
# include "pushb.cmn"

  /* if pu_tty_c is < 0 then this "macro end" command came from a pushed back
   * macro, so ignore it. */
  if (ma_defining_macro && pu_tty_c >= 0) {
    ma_defining_macro = false;
    ms_message("Keyboard macro defined.");
    }
}

void ma_invoke(int mnumb)
{
  if (ma_defining_macro && mnumb == 0) {
    ms_error("You can't call a keyboard macro while defining it!");
    ma_delete(0);
    }
  else
    pu_push_back_buf(ma_text+ma_start[mnumb], ma_len[mnumb]);
}

void ma_delete(int mnumb)
{
  int i;

  if (ma_len[mnumb] > 0) {
    movc(ma_text+ma_start[mnumb]+ma_len[mnumb],
    	      ma_text+ma_start[mnumb],ma_next-ma_start[mnumb]-ma_len[mnumb]);
    ma_next = ma_next-ma_len[mnumb];
    for (i = 0; i < MAX_MACROS; i++) {
      if (ma_len[i] > 0 && ma_start[i] > ma_start[mnumb])
	ma_start[i] = ma_start[i]-ma_len[mnumb];
      }
    ma_len[mnumb] = 0;
    }
}

void ma_replace(int mnumb)
{
  if (ma_defining_macro) {
    ms_error("You can't rename a keyboard macro while defining it!");
    ma_delete(0);
    }
  else if (mnumb > 0) {
    ma_delete(mnumb);
    ma_start[mnumb] = ma_start[0];
    ma_len[mnumb] = ma_len[0];
    ma_len[0] = 0;
    }
}

/* assume bsize >= MAX_MACROS */
void ma_save_macros(char *buf, int *nc, int bsize)
{
  int mnumb;

  *nc = 0;
  for (mnumb = 0; mnumb < MAX_MACROS; mnumb++) {
    if (ma_len[mnumb] > 0)
      if (*nc + ma_len[mnumb] + (MAX_MACROS - mnumb) <= bsize) {
	movc(ma_text+ma_start[mnumb], buf + *nc, ma_len[mnumb]);
	*nc += ma_len[mnumb];
	}
    buf[*nc++] = -1;
    }
}

void ma_restore_macros(const char *buf, int nc)
{
  int i, mnumb;

  i = 0;
  ma_next = 0;
  for (mnumb = 0; mnumb < MAX_MACROS; mnumb++) {
    ma_start[mnumb] = ma_next;
    ma_len[mnumb] = 0;
    for ( ; i < nc; i++)
      if (buf[i] == -1) {
    	i++;
	break;
	}
      else if (ma_next < MACRO_SIZE) {
	ma_text[ma_next++] = buf[i];
	ma_len[mnumb] += 1;
	}
      else
	ma_len[mnumb] = 0;
    ma_next = ma_start[mnumb] + ma_len[mnumb];
    }
}

int q_ma_write_macros(const char *file)
{
  int mnumb, err;

  if (! q_fi_open_write(WRITE_UNIT, file, 'N', 0xFFFF))
    return false;
  for (mnumb = 0; mnumb < MAX_MACROS; mnumb++)
    if (! q_fi_put(WRITE_UNIT, ma_text+ma_start[mnumb], ma_len[mnumb], &err)) {
      q_fi_close(WRITE_UNIT);
      return false;
      }
  return q_fi_close(WRITE_UNIT);
}

int q_ma_read_macros(const char *file)
{
  int mnumb;
  file_info finfo;

  if (ma_defining_macro) {
    ms_error("You can't read macros while defining a macro!");
    ma_delete(0);
    return false;
    }
  if (! q_fi_open_read(READ_UNIT, file, &finfo))
    return false;
  ma_next = 0;
  for (mnumb = 0; mnumb < MAX_MACROS; mnumb++) {
    ma_start[mnumb] = ma_next;
    if (! q_fi_get(READ_UNIT,ma_text+ma_next,MACRO_SIZE-ma_next,ma_len+mnumb))
      ma_len[mnumb] = 0;
    else
      ma_next = ma_next + ma_len[mnumb];
    }
  return q_fi_close(READ_UNIT);
}
$eod
$ create MACRO.CMN
$deck
declare int
	ma_next,
	ma_len[MAX_MACROS],
	ma_start[MAX_MACROS];

declare char
	ma_defining_macro,
	ma_text[MACRO_SIZE];
$eod
$ create MAIN.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1987 William P. Wood, Jr. */

#include "symbols.h"

int main(int argc, const char *argv[])
{
#if VMS
/*
 *	We can't use C command line processing because it deletes any
 *	quotation marks in the command line, which may be needed for DECNET
 *	file names.
 */
# include "descr.h"
  char cline[MAX_COMMAND];
  vms_char_descr(d_cline, cline, MAX_COMMAND-1);
  const char *clinep[] = { argv[0], cline };
  short int len;

  if ((lib$get_foreign(&d_cline, 0, &len) & 1) == 1) {
    len = max(0, len);
    cline[len] = EOS;
    }
  else {
    len = 0;
    cline[0] = EOS;
    }

  zilch(2, clinep);

#else

  zilch(argc, argv);

#endif

  return EXIT_GOOD;
}
$eod
$ create MAPPINGS.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "spfiles.cmn"
#include "memory.cmn"
#include "mappings.cmn"
#include "session.cmn"

static int q_mp_get_first_word(textind *wb, textind *we)
{
  textind dot, end;

  dot = wi_dot(se_current_window);
  end = bu_size(se_current_buffer) + 1;
  beginning_of_line();
  wo_skip_non_word(end, 1, false, 1);
  *wb = wi_dot(se_current_window);
  wo_skip_word(end, 1, 1);
  *we = wi_dot(se_current_window);
  wi_dot(se_current_window) = dot;
  return *wb != *we;
}

static void mp_ratfiv_block(void)
{
  static const char s[] = "\t{\33\60\60\t}\33\60-";

  mp_mark = wi_dot(se_current_window);
  mp_save_indent = bu_indent(se_current_buffer);
  mp_push_character(END_OF_MAPPING);
  mp_push_string(s);
  mp_pop();
}

static void mp_pascal_block(void)
{
  textind wb, we;

  static const char s1[] = "\tbegin\33\60\60\tend (* ",
		    s2[] = " *);\33\60-",
		    s3[] = "\tbegin\33\60+\tend;\33-0";

  mp_mark = wi_dot(se_current_window);
  mp_save_indent = bu_indent(se_current_buffer);
  mp_push_character(END_OF_MAPPING);
  if (q_mp_get_first_word(&wb, &we)) {
    mp_push_string(s2);
    mp_push_region(se_current_buffer, wb, we);
    mp_push_string(s1);
    }
  else
    mp_push_string(s3);
  mp_pop();
}

static void mp_get_block(void)
{
  switch (bu_type(se_current_buffer)) {
    case RATFIV:
    case C:
      mp_ratfiv_block();
      break;
    case PASCAL:
      mp_pascal_block();
      break;
    default:
      ms_error("");
      break;
    }
}

static void mp_cancel(void)
{
  char c;

  if (mp_mark == 0)
    ms_error("Can't cancel mapping!");
  else {
    if (mp_mark > 0)
      for (mp_nextc(&c); c != END_OF_MAPPING; mp_nextc(&c))
	;
    else
      mp_mark = -mp_mark;
    if (wi_dot(se_current_window) > mp_mark)
      delete_region(wi_dot(se_current_window),mp_mark);
    mp_mark = 0;
    set_indent(mp_save_indent);
    }
}

static int q_mp_next_pascal_procedure(void)
{
  beginning_of_line();
  if (q_sr_buffer_search_forward(se_current_buffer, "(**", 3,
  				wi_dot(se_current_window),
  				bu_size(se_current_buffer),
  				&wi_dot(se_current_window))) {
    end_of_line();
    return true;
    }
  return false;
}

static int q_mp_previous_pascal_procedure(void)
{
  beginning_of_line();
  if (q_sr_buffer_search_reverse(se_current_buffer, "(**", 3,
				1,
  				wi_dot(se_current_window),
  				&wi_dot(se_current_window)))
    return true;
  return false;
}

static int q_mp_is_fortran_eop(void)
{
  textind loc;

  loc = wi_dot(se_current_window);
  mp_beginning_of_line();
  if (loc == wi_dot(se_current_window)) {
    wi_dot(se_current_window) = wi_dot(se_current_window) + 3;
    advance_over_white_space();
    if (q_eol())
      return true;
    else if (q_mp_at_comment())
      return true;
    }
  return false;
}

static int q_mp_next_fortran_procedure(void)
{
  beginning_of_line();
  while (q_sr_buffer_search_forward(se_current_buffer, "end", 3,
  				wi_dot(se_current_window),
  				bu_size(se_current_buffer),
  				&wi_dot(se_current_window))) {
    if (q_mp_is_fortran_eop()) {
      end_of_line();
      return true;
      }
    else
      next_line();
    }
  return false;
}

static int q_mp_previous_fortran_procedure(void)
{
  beginning_of_line();
  while (q_sr_buffer_search_reverse(se_current_buffer, "end", 3,
				1,
  				wi_dot(se_current_window),
  				&wi_dot(se_current_window))) {
    if (q_mp_is_fortran_eop())
      return true;
    else
      beginning_of_line();
    }
  return false;
}

static int q_mp_next_c_procedure(void)
{
  static char eop[] = "\n}";

  eop[0] = NEWLINE;
  beginning_of_line();
  if (q_sr_buffer_search_forward(se_current_buffer, eop, 2,
  				wi_dot(se_current_window),
  				bu_size(se_current_buffer),
  				&wi_dot(se_current_window))) {
    wi_dot(se_current_window) = wi_dot(se_current_window) + 2;
    end_of_line();
    return true;
    }
  return false;
}

static int q_mp_previous_c_procedure(void)
{
  static char eop[] = "\n}";

  eop[0] = NEWLINE;
  beginning_of_line();
  if (q_sr_buffer_search_reverse(se_current_buffer, eop, 2,
				1,
  				wi_dot(se_current_window),
  				&wi_dot(se_current_window)))
    return true;
  return false;
}

static int q_mp_next_paragraph(void)
{
  beginning_of_line();
  for ( ; ; ) {
    advance_over_white_space();
    if (q_eol())
      return true;
    next_line();
    }
}

static int q_mp_previous_paragraph(void)
{
  beginning_of_line();
  while (wi_dot(se_current_window) > 1) {
    advance_over_white_space();
    if (q_eol()) {
      do {
	previous_line();
	advance_over_white_space();
	} while (q_eol() && wi_dot(se_current_window) != 1);
      return true;
      }
    previous_line();
    }
  return false;
}

static bufferp mp_mappings(int typ)
{
  bufferp mappings;

  switch (typ) {
    case FORTRAN:
      mappings = sp_read_buffer("formap", &sp_formap,
				    "Can't read Fortran mapping file!");
      break;
    case RATFIV:
      mappings = sp_read_buffer("ratmap", &sp_ratmap,
				    "Can't read Ratfiv mapping file!");
      break;
    case PASCAL:
      mappings = sp_read_buffer("pasmap", &sp_pasmap,
				    "Can't read Pascal mapping file!");
      break;
    case C:
      mappings = sp_read_buffer("cmap", &sp_cmap,
				    "Can't read C mapping file!");
      break;
    case TEXT:
      mappings = sp_read_buffer("textmap", &sp_textmap,
				    "Can't read Text mapping file!");
      break;
    default:
      mappings = null;
      break;
    }
  return mappings;
}

void mp_initialize(void)
{
  if (mp_stack == null) {
    mp_stack = bu_find_by_name("mapping stack");
    if (mp_stack == null)
      mp_stack = bu_new("mapping stack", "");
    }
  mp_mark = 0;
}

void mp_get_mapping(void)
{
  bufferp bu, maping;
  textind loc, col;
  static char search[] = "\12 ";

  bu = se_current_buffer;
  search[1] = get_tty_character();
  switch (search[1]) {
    case RUBOUT:
      mp_cancel();
      break;
    case '[':
      mp_get_block();
      break;
    default:
      if (bu_mappings(bu) == null)
	bu_mappings(bu) = mp_mappings(bu_type(bu));
      maping = bu_mappings(bu);
      if (maping != null) {
	if (q_sr_buffer_search_forward(maping,search,2,1,
      					bu_size(maping),&loc)) {
	  mp_mark = wi_dot(se_current_window);
	  mp_save_indent = bu_indent(bu);
	  mp_push_character(END_OF_MAPPING);
	  mp_push_region(maping, loc+2, find_eol(maping, loc+2));
	  if (search[1] == '{') {		/* comment mapping */
	    switch (bu_type(bu)) {
	      case FORTRAN:
	      case RATFIV:
		col = 49;
	      default:
		col = 41;
	      }
	    if (current_column() >= col)
	      insert_character(' ');
	    else
	      tab_to_column(col);
	    }
	  mp_pop();
	  }
	else
	  insert_character(search[1]);
	}
      else
	insert_character(search[1]);
      break;
    }
}

void mp_pop(void)
{
  bufferp bu;
  char c;

  bu = se_current_buffer;
  mp_nextc(&c);
  if (c == INDENT_FOLLOWS) {
    mp_nextc(&c);
    set_indent((textind) c);
    mp_nextc(&c);
    }
  while (c != END_OF_MAPPING && c != 033) {
    if (c == TAB)
      if (current_column() <= bu_indent(bu))
	tab_to_column(bu_indent(bu));
      else
	insert_character(' ');
    else if (c == CR)
      in_carriage_return();
    else if (c == '\\') {
      mp_nextc(&c);
      if (c == END_OF_MAPPING)
	break;
      insert_character(c);
      }
    else if (c == MP_PROMPT) {
      stringp st = st_allocate(MAX_PROMPT);
      int i = 0;
      for (mp_nextc(&c); c != END_OF_MAPPING && c != MP_PROMPT;
						mp_nextc(&c))
	if (i < MAX_PROMPT)
	  *st_buffer(st + i++) = c;
      ms_message3("", st, i, i+1);
      st_deallocate(st);
      }
    else if (bu_case(bu) == 1)
      if (bu_type(bu) == RATFIV && (c == '{' || c == '}'))
	insert_character(c - 040);
      else
	insert_character(ho_cupper(c));
    else
      insert_character(c);
    mp_nextc(&c);
    }
  if (c == 033) {
    mp_nextc(&c);
    if (c == '+')
      in_increase_indent();
    else if (c == '-')
      in_decrease_indent();
    mp_nextc(&c);
    if (c == '+')
      set_indent(bu_indent(bu) + se_indent);
    else if (c == '-')
      set_indent(bu_indent(bu) - se_indent);
    mp_nextc(&c);
    if (c != END_OF_MAPPING) {
      mp_push_character(c);
      mp_push_character(bu_indent(bu));
      mp_push_character(INDENT_FOLLOWS);
      }
    }
  if (c == END_OF_MAPPING)
    if (mp_mark <= 0)
      mp_mark = 0;
    else
      mp_mark = -mp_mark;
}

void mp_set_mappings(bufferp bu, int type)
{
  char ftype[4];
  int i, j;

  if (type == 0) {
    i = ho_indexq(st_buffer(bu_name(bu)), '.');
    if (i == 0)
      ftype[0] = EOS;
    else
      for (i--, j = 0; j < 4; j++) {
	ftype[j] = *st_buffer(bu_name(bu)+i+j);
	if (ftype[j] == EOS)
	  break;
	else if (ftype[j] == ';' || ftype[j] == '<') {
	  ftype[j] = EOS;
	  break;
	  }
	}
    if (q_ho_equal(ftype, ".for") || q_ho_equal(ftype, ".ftn"))
      type = FORTRAN;
    else if (q_ho_equal(ftype, ".rat"))
      type = RATFIV;
    else if (q_ho_equal(ftype, ".pas"))
      type = PASCAL;
    else if (q_ho_equal(ftype, ".c") || q_ho_equal(ftype, ".cpp") ||
		q_ho_equal(ftype, ".cp"))
      type = C;
    else
      type = TEXT;
    }
  bu_type(bu) = type;
  bu_indent(bu) = (type == FORTRAN ? 9 : 1);
  bu_mappings(bu) = null;
}

int mp_minimum_indent(bufferp bu)
{
  return bu_type(bu) == FORTRAN ? 7 : 1;
}

void mp_change_mappings(void)
{
  int type, len;
  stringp st;

  type = 0;
  st = st_allocate(MAX_PROMPT);
  if (q_pr_read_prompt("Mapping type (Pascal, Fortran, Ratfiv, C, Text)? ",
			st, &len)) {
    if (q_ho_equal(st_buffer(st),"fortran"))
      type = FORTRAN;
    else if (q_ho_equal(st_buffer(st),"pascal"))
      type = PASCAL;
    else if (q_ho_equal(st_buffer(st),"ratfiv"))
      type = RATFIV;
    else if (q_ho_equal(st_buffer(st),"c"))
      type = C;
    else if (q_ho_equal(st_buffer(st),"text"))
      type = TEXT;
    else {
      ms_message2("Illegal mapping type: ",st);
      ms_error("");
      }
    if (type != 0) {
      mp_set_mappings(se_current_buffer, type);
      ms_message2("Mapping type is now ", st);
      }
    }
  st_deallocate(st);
}

int q_mp_empty(void)
{
  return bu_size(mp_stack) == 0;
}

void mp_next_procedure(void)
{
  int found;

  beginning_of_line();
  while (wi_dot(se_current_window) > 1) {
    advance_over_white_space();
    if (! q_eol())
      break;
    previous_line();
    }
  switch (bu_type(se_current_buffer)) {
    case RATFIV:
    case FORTRAN:
      found = q_mp_next_fortran_procedure();
      break;
    case PASCAL:
      found = q_mp_next_pascal_procedure();
      break;
    case C:
      found = q_mp_next_c_procedure();
      break;
    default:
      found = q_mp_next_paragraph();
      break;
    }
  if (found) {
    while (wi_dot(se_current_window) <= bu_size(se_current_buffer) && q_eol()) {
      wi_dot(se_current_window) = wi_dot(se_current_window) + 1;
      advance_over_white_space();
      }
    beginning_of_line();
    }
  else
    end_of_file();
  line_to_top_of_window();
}

void mp_previous_procedure(void)
{
  textind dot;
  int found, n, i;

  dot = wi_dot(se_current_window);
  n = 1;
  do {
    for (i = 1; i <= n; i++)
      switch (bu_type(se_current_buffer)) {
	case RATFIV:
	case FORTRAN:
	  found = q_mp_previous_fortran_procedure();
	  break;
	case PASCAL:
	  found = q_mp_previous_pascal_procedure();
	  break;
	case C:
	  found = q_mp_previous_c_procedure();
	  break;
	default:
	  found = q_mp_previous_paragraph();
	  break;
	}
    if (found)
      mp_next_procedure();
    else
      beginning_of_file();
    n = n + 1;
    } while(wi_dot(se_current_window) != 1 && wi_dot(se_current_window) >= dot);
}

int q_mp_at_comment(void)
{
  textind tx, cc;
  bufferp bu;
  int status;
  char c, c2;

  status = false;
  tx = wi_dot(se_current_window);
  bu = se_current_buffer;
  if (tx <= bu_size(bu)) {
    c = tx_text(tx_address(bu,tx));
    switch (bu_type(bu)) {
      case FORTRAN:
	cc = current_column();
	if (cc > 72 || c == '!' || (cc == 1 && (ho_clower(c) == 'c' || c == '*')))
	  status = true;
	break;
      case RATFIV:
	if (c == '#')
	  status = true;
	break;
      case PASCAL:
	if (c == '{' || c == '}')
	  status = true;
	else if (tx + 1 <= bu_size(bu)) {
	  c2 = tx_text(tx_address(bu,tx+1));
	  if ((c == '(' && c2 == '*') || (c == '*' && c2 == ')'))
	    status = true;
	  }
	break;
      case C:
	if (tx + 1 <= bu_size(bu)) {
	  c2 = tx_text(tx_address(bu,tx+1));
	  if ((c == '/' && c2 == '*') ||
	      (c=='*' && (c2=='/' || c2==' ' || c2==TAB || c2==NEWLINE)) ||
	      (c == '/' && c2 == '/'))		/* for C++ */
	    status = true;
	  }
	break;
      case TEXT:
	if (c == '!')
	  status = true;
	break;
      }
    }
  return status;
}

void mp_beginning_of_line(void)
{
  textind tx;
  bufferp bu;
  char c;

  beginning_of_line();
  bu = se_current_buffer;
  tx = wi_dot(se_current_window);
  switch (bu_type(bu)) {
    case FORTRAN:
      if (! q_mp_at_comment()) {
	goto_column(6);
	tx = wi_dot(se_current_window);
	if (tx <= bu_size(bu)) {
	  c = tx_text(tx_address(bu,tx));
	  if (c != ' ' && c != TAB && c != NEWLINE && current_column() == 6)
	    tx = tx+1;
	  else {
	    advance_over_white_space();
	    tx = wi_dot(se_current_window);
	    if (current_column() == 9 && tx <= bu_size(bu)) {
	      c = tx_text(tx_address(bu,tx));
	      if (c >= '1' && c <= '9')
		tx = tx + 1;
	      }
	    }
	  }
	}
      break;
    case RATFIV:
      for ( ; tx <= bu_size(bu); tx = tx+1) {
	c = tx_text(tx_address(bu,tx));
	if (c < '0' || c > '9')
	  break;
	}
      break;
    case TEXT:
      if (tx <= bu_size(bu))
	if (tx_text(tx_address(bu,tx)) == '$')	/* for DCL command files */
	  tx = tx+1;
      break;
    }
  wi_dot(se_current_window) = tx;
  advance_over_white_space();
}

int q_mp_read_file(bufferp bu, const char *name, textind dot, int setpro)
{
  return q_fi_read_file(bu, name, dot, setpro);
}

int q_mp_write_file(bufferp bu, const char *name, int type, int *stat)
{
  int status;

  status = q_fi_write_region(bu, name, 1, bu_size(bu), type, stat);
  if (status) {
    bu_modified(bu) = 0;
    ms_message("Wrote ");
    ms_add_to_message(name);
    if (type == 'N')		/* NEW file - not writing checkpoint file */
      ch_delete(bu);
    }
  return status;
}
$eod
$ create MAPPINGS.CMN
$deck
declare textind
	mp_mark;

declare textind
	mp_save_indent;

declare bufferp
	mp_stack
#ifdef initialize
		= null
#endif
	;
$eod
$ create MAPPINGS.H
$deck
#define FORTRAN 1
#define RATFIV 2
#define PASCAL 3
#define TEXT 4
#define C 6
#define END_OF_MAPPING -1
#define INDENT_FOLLOWS -2
#define MP_PROMPT 020
#define mp_push_region(bu,p1,p2) pu_push_region(mp_stack,bu,p1,p2)
#define mp_push_string(str) pu_push_string(mp_stack,str)
#define mp_push_character(c) pu_push_character(mp_stack,c)
#define mp_nextc(c) pu_nextc(mp_stack,c)
$eod
$ create MARK.C
$deck
/* Zilch Screen Editor,
 * Copyright (c) 1982,1983,1984,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "session.cmn"
#include "memory.cmn"

void case_change(void)
{
  register bufferp bu;
  register textind m1, m2;

  bu = se_current_buffer;
  if (bu_mark1(bu) != 0 && bu_mark2(bu) != 0) {
    m1 = min(bu_mark1(bu), bu_size(bu)+1);
    m2 = min(bu_mark2(bu), bu_size(bu)+1);
    tx_case_change(bu, min(m1, m2), max(m1, m2) - 1);
    }
  else
    ms_error("Both marks must be set!");
}

void save_text(void)
{
  register bufferp bu;
  register textind m1, m2;

  bu = se_current_buffer;
  if (bu_mark1(bu) != 0 && bu_mark2(bu) != 0) {
    m1 = min(bu_mark1(bu), bu_size(bu)+1);
    m2 = min(bu_mark2(bu), bu_size(bu)+1);
    if (q_copy_region_to_buffer("Save", m1, m2))
      ms_report_number2("Saved ", abs(m1 - m2),
	  " character.", " characters.");
    }
  else
    ms_error("Both marks must be set!");
}

void extract_text(void)
{
  register bufferp bu;
  register textind m1, m2;

  bu = se_current_buffer;
  if (bu_mark1(bu) != 0 && bu_mark2(bu) != 0) {
    m1 = min(bu_mark1(bu), bu_size(bu)+1);
    m2 = min(bu_mark2(bu), bu_size(bu)+1);
    delete_region_to_buffer("Save", m1, m2);
    ms_report_number2("Extracted ", abs(m1 - m2),
						" character.", " characters.");
    mk_set_mark(bu_mark1_ptr(bu), 0, bu);
    mk_set_mark(bu_mark2_ptr(bu), 0, bu);
    }
  else
    ms_error("Both marks must be set!");
}

void delete_text(void)
{
  register bufferp bu;
  register textind m1, m2;

  bu = se_current_buffer;
  if (bu_mark1(bu) != 0 && bu_mark2(bu) != 0) {
    m1 = min(bu_mark1(bu), bu_size(bu)+1);
    m2 = min(bu_mark2(bu), bu_size(bu)+1);
    delete_region(m1, m2);
    ms_report_number2("Deleted ", abs(m1 - m2),
						" character.", " characters.");
    mk_set_mark(bu_mark1_ptr(bu), 0, bu);
    mk_set_mark(bu_mark2_ptr(bu), 0, bu);
    }
  else
    ms_error("Both marks must be set!");
}

void add_text_after_cursor(void)
{
  register bufferp bu;

  bu = se_current_buffer;
  mk_set_mark(bu_mark1_ptr(bu), wi_dot(se_current_window), bu);
  yank_buffer("Save");
  mk_set_mark(bu_mark2_ptr(bu), wi_dot(se_current_window), bu);
  wi_dot(se_current_window) = bu_mark1(bu);
}

void add_text_before_cursor(void)
{
  register bufferp bu;

  bu = se_current_buffer;
  mk_set_mark(bu_mark1_ptr(bu), wi_dot(se_current_window), bu);
  yank_buffer("Save");
  mk_set_mark(bu_mark2_ptr(bu), wi_dot(se_current_window), bu);
}

void save_location(void)
{
  register bufferp bu;

  bu = se_current_buffer;
  mk_set_mark(bu_save_dot_ptr(bu), wi_dot(se_current_window), bu);
  mk_set_mark(bu_save_bow_ptr(bu), wi_bow(se_current_window), bu);
  ms_message("Current location saved.");
}

void exchange_dot_and_save_location(void)
{
  register bufferp bu;

  bu = se_current_buffer;
  wi_dot(se_current_window) = min(bu_size(bu)+1,
    mk_set_mark(bu_save_dot_ptr(bu), wi_dot(se_current_window), bu));
  wi_set_bow(se_current_window, find_bol(bu,
    mk_set_mark(bu_save_bow_ptr(bu), wi_bow(se_current_window), bu)));
}

void goto_save_location(void)
{
  register bufferp bu;

  bu = se_current_buffer;
  wi_dot(se_current_window) = min(bu_size(bu)+1, bu_save_dot(bu));
  wi_set_bow(se_current_window, find_bol(bu,bu_save_bow(bu)));
}

void write_text(void)
{
  register bufferp bu;
  stringp st;
  register textind m1, m2;
  int len, stat;

  bu = se_current_buffer;
  if (bu_mark1(bu) != 0 && bu_mark2(bu) != 0) {
    st = st_allocate(MAX_PROMPT);
    if (q_pr_read_prompt(
  "Where to print (eg. HQ:FILE.OUT, or RETURN for local printer): ",st,&len)) {
      m1 = min(bu_mark1(bu), bu_size(bu)+1);
      m2 = min(bu_mark2(bu), bu_size(bu)+1);
      if (len == 0) {
	ho_scopy("SYS$COMMAND", 1, st_buffer(st), 1);
	te_printer_on();
	ti_flush();
	se_interrupt_enabled = true;  /* allow printer output to be aborted */
	}
      if (q_fi_write_region(bu, st_buffer(st), min(m1, m2), max(m1, m2)-1,
								'N', &stat)) {
	if (len > 0) {
	  ms_message("Wrote ");
	  ms_add_to_message(st_buffer(st));
	  }
	}
      else {
	ms_message2("Can't write ",st);
	ms_error("");
	}
      if (len == 0) {
	se_interrupt_enabled = false;
	te_printer_off();
	ti_flush();
	redraw();
	}
      }
    st_deallocate(st);
    }
  else
    ms_error("Both marks must be set!");
}

markp mk_new(textind mark)
{
  register markp mk;

  mk = me_allocate(mk_sizeof);
  mk_next(mk) = null;
  mk_mark(mk) = mark;
  return mk;
}

markp mk_link(register markp mk, register bufferp bu)
{
  register markp mk2;

  mk_map(bu_markers(bu), mk2)
    if (mk2 == mk)
      return mk;
  mk_next(mk) = bu_markers(bu);
  bu_markers(bu) = mk;
  return mk;
}

markp mk_unlink(register markp mk, register bufferp bu)
{
  register markp mk2, prev;

  prev = null;
  mk_map(bu_markers(bu), mk2)
    if (mk2 == mk) {
      if (prev == null)
	bu_markers(bu) = mk_next(mk);
      else
	mk_next(prev) = mk_next(mk);
      break;
      }
    else
      prev = mk2;
  mk_next(mk) = null;
  return mk;
}

/* If a mark is 0 or 1, it needn't be in the buffer's list of marks
 * because its value can't change.  This routine sets a mark, and unlinks
 * or links it into the buffer's mark list depending on the new mark value
 */
textind mk_set_mark(register markp mk, textind mark, register bufferp bu)
{
  textind savemark;

  savemark = mk_mark(mk);
  mk_mark(mk) = mark;
  if (mark > 1)
    mk_link(mk, bu);
  else
    mk_unlink(mk, bu);
  return savemark;
}
$eod
$ create MARK.H
$deck
#define mk_next(mk) me_mem(mk)		/* next marker in list */
#define mk_mark(mk) me_mem(1+mk)	/* number of marked character in buffer */
#define mk_sizeof 2
#define mk_map(mk1, mk2) for (mk2 = mk1; mk2 != null; mk2 = mk_next(mk2))
$eod
$ create MEMORY.CMN
$deck
#ifdef VMS			/* VMS generates better code this way... */
#define me_mem(me) (memory.me_memory[me])
#define tx_text(tx) (memory.tx_texxt[tx])
#else
#define me_mem(me) *(memory.me_memory + (me))
#define tx_text(tx) *(memory.tx_texxt + (tx))
#endif

#define st_buffer(st) (memory.st_buff + (st))

declare union {
	intp me_memory[1];
	char st_buff[1];			/* string buffer */
	char tx_texxt[1];			/* text buffer */
	} memory;

declare int zero
#ifdef initialize
		= 0
#endif
	;
$eod
$ create MESSAGE.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "session.cmn"
#include "memory.cmn"
#include "screen.cmn"

void ms_message(const char *mess)
{
  ms_message2(mess, null);
}

void ms_message3(const char *mess, stringp st, int stlen, textind dot)
{
  char c;
  int i, j, len, ichar;

  if (! se_error_occurred) {
    len = ho_length(mess);
    sc_fill_line(sc_size, mess, len);
    sc_cursor_x = len + 1;
    if (st != null) {
      for (i = 0; i < stlen; ) {
	c = *st_buffer(st + i++);
	if (c >= ' ' && c <= '~') {
	  len++;
	  sc_add_to_line(sc_size,&c,1);
	  }
	else if (c == TAB) {
	  for (j = len + 8 - mod(len, 8); len < j; len++)
	    sc_add_to_line(sc_size," ",1);
	  }
	else if (c >= 0 && c <= 037) {
	  len += 2;
	  sc_add_to_line(sc_size,"^",1);
	  c |= 0100;
	  sc_add_to_line(sc_size,&c,1);
	  }
	else {
	  len += 4;
	  sc_add_to_line(sc_size,"\\",1);
	  ichar = c;
	  c = '0' + (ichar & 0300)/0100;
	  sc_add_to_line(sc_size,&c,1);
	  c = '0' + (ichar & 070)/010;
	  sc_add_to_line(sc_size,&c,1);
	  c = '0' + (ichar & 07);
	  sc_add_to_line(sc_size,&c,1);
	  }
	if (dot == i)
	  sc_cursor_x = len + 1;
	}
      }
    sc_cursor_x = min(sc_width, sc_cursor_x);
    }
}

void ms_message2(const char *mess, stringp st)
{
  if (! se_error_occurred) {
    sc_fill_line(sc_size, mess, ho_length(mess));
    if (st != null)
      sc_add_to_line(sc_size, st_buffer(st), st_length(st));
    sc_cursor_x = min(sc_width, sc_new_length(sc_size)+1);
    }
}

void ms_user_message(char *msg, int len)
{
  int i;

  for (i = 0; i < len; i++)
    if (msg[i] == '%') {
      if (i + 4 < MAX_PROMPT) {
	ho_itocrj((100*(wi_dot(se_current_window)-1))/ _
			    max(1, bu_size(se_current_buffer)), msg + i, 4);
	msg[i + 3] = '%';
	if (i + 4 > len)
	  msg[i + 4] = EOS;
	}
      break;
      }
  if (msg[0] == '!')
    ms_error(msg + 1);
  else
    ms_message(msg);
}

void ms_add_to_message(const char *mess)
{
  if (! se_error_occurred) {
    sc_add_to_line(sc_size, mess, ho_length(mess));
    sc_cursor_x = min(sc_width, sc_new_length(sc_size)+1);
    }
}

void ms_error(const char *mess)
{
  int len;

  if (! se_error_occurred) {
    len = ho_length(mess);
    if (len > 0) {
      sc_fill_line(sc_size, mess, len);
      sc_cursor_x = min(sc_width, sc_new_length(sc_size)+1);
      }
    }
  sc_error_occurred = se_error_occurred = true;
}

void ms_report_number(const char *s1, long int n, const char *s2)
{
  char num[15];

  if (! se_error_occurred) {
    ms_message2(s1, null);
    ho_itoc(n, num, 15);
    ms_add_to_message(num);
    ms_add_to_message(s2);
    }
}

void ms_report_number2(const char *s1,long int n,const char *ss,const char *sp)
{
  if (n == 1)
    ms_report_number(s1, n, ss);
  else
    ms_report_number(s1, n, sp);
}
$eod
$ create MOVC.MAR
$deck
;	Zilch Screen Editor,
;	Copyright (c) 1982,1987 William P. Wood, Jr.

	.title	movc_c
;
;
;	void movc_c(const char *in, char *out, unsigned short int len)
;
;
in=4
out=8
len=12
	.psect	icr_code,pic,usr,con,rel,lcl,shr,exe,rd,nowrt,novec,long
movc_c::
	.word	^m<r2,r3,r4,r5>
	movc3	len(ap),@in(ap),@out(ap)		; copy the string
	ret
	.end
$eod
$ create NODEINFO.CMN
$deck
static int
	nodes_generated,
	nodes_examined,
	nodes_inserted,
	nodes_replaced;
$eod
$ create NOTES.
$deck
move zero to memory.cmn?
check get and put have &nc, &ier
modify scr coords to be 0-based, not 1-based
put dcl's zilch.log in zilch startup dir? maybe not - no access on network
change ifdefs to ifs etc.
change all chars to ints?
go over all .cmn, replace chars with ints where really logicals
many st_allocates can be replaced by automatic declarations.
bug in mappings - * should be comment in col 2 only for C mappings?
&tx_text needs a macro.
is long int or textind appropriate?
check uses of textind should be textp?
ms_ funcs always need strings; others?
static chars!
do i=1,n -> for
repeat-until
check for switch statements - need break
check for ' should be " and v-v
check for array indexes converted properly from 1 to 0-based
remember the || &&
remember to check for pass-by-value VS pass-by-reference
	st_buffer esp.
	tx_text
$eod
$ create PAGE.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "memory.cmn"
#include "session.cmn"
#include "page.cmn"

void pa_switch(int n)
{
  register pagep pa;
  register windowp wn;
  windowp wi, prev;

  pa_map(se_pages,pa)
    if (pa_number(pa) == n)
      goto L10;
  pa = pa_new(n);	/* page doesn't exist; make a copy of current page */
  prev = null;
  wi_map(se_windows,wi) {
    wn = wi_copy(wi);
    if (prev == null)
      pa_windows(pa) = wn;
    else
      wi_next(prev) = wn;
    wi_prev(wn) = prev;
    prev = wn;
    if (wi == se_current_window)
      pa_current_window(pa) = wn;
    }
L10:
  pa_make_current(pa);
}

void pa_make_current(pagep pa)
{
  register windowp wi, wi2;

  wi_map(se_windows,wi)				/* save window locations */
    wi_map_sub_windows(wi, wi2)
      if (wi_buffer(wi2) != null) {
	bu_dot(wi_buffer(wi2)) = wi_dot(wi2);
	bu_bow(wi_buffer(wi2)) = wi_bow(wi2);
	if (wi2 == wi)
	  bu_current(wi_buffer(wi2)) = 1;
	else
	  bu_current(wi_buffer(wi2)) = 0;
	}
  pa_update;
  se_current_page = pa;
  se_current_window = pa_current_window(pa);
  wi_map(se_windows,wi)
    wi_modified(wi) = 1;
}

void pa_generate(register int n)
{
  register pagep pa;

  if (n == pa_highest_n)		/* optimize for last page... */
    n++;
  else {
    for (n++; ; n++) {			/* find new page number */
      pa_map(se_pages, pa)
	if (pa_number(pa) == n)
	  goto L10;
      break;
L10:  ;
      }
    }
  pa_make_current(pa_new(n));
}

pagep pa_new(int n)
{
  register pagep pan;
  pagep pa, prev;

  pan = me_allocate(pa_sizeof);
  if (n > pa_highest_n || pa_last_page == null) {  /* optimize for last page... */
    prev = pa_last_page;
    pa_last_page = pan;
    pa_highest_n = n;
    }
  else
    for (prev = null, pa = se_pages; pa != null; prev = pa, pa = pa_next(pa))
      if (n <= pa_number(pa))
	break;
  if (prev == null) {
    pa_next(pan) = se_pages;
    se_pages = pan;
    }
  else {
    pa_next(pan) = pa_next(prev);
    pa_next(prev) = pan;
    }
  pa_number(pan) = n;
  pa_windows(pan) = null;
  pa_current_window(pan) = null;
  return pan;
}

void switch_to_page(int n)
{
  pa_switch(n);
  ms_report_number("Page ", n, "");
  pa_ready(se_current_page);
}

void pa_ready(pagep pa)
{
  register windowp wi;

  wi_map(pa_windows(pa),wi) {
    bu_ready(wi_buffer(wi));
    wi_ready(wi);
    }
}

void pa_next_page(void)
{
  register pagep pa;

  pa_map(pa_next(se_current_page), pa)
    if (pa_number(pa) >= 0)
      break;
  if (pa == null)
    ms_error("This is the last page!");
  else
    switch_to_page(pa_number(pa));
}

void pa_previous_page(void)
{
  register pagep pa;

  for (pa = pa_prev(se_current_page); pa != null; pa = pa_prev(pa))
    if (pa_number(pa) >= 0)
      break;
  if (pa == null)
    ms_error("This is the first page!");
  else
    switch_to_page(pa_number(pa));
}

pagep pa_prev(pagep page)
{
  register pagep pa, prev;

  for (pa = se_pages, prev = null; pa != page; prev = pa, pa = pa_next(pa))
    ;
  return prev;
}
$eod
$ create PAGE.CMN
$deck
declare int
	pa_highest_n
#ifdef initialize
			= 0
#endif
	;

declare pagep
	pa_last_page
#ifdef initialize
			= null
#endif
	;
$eod
$ create PAGE.H
$deck
#define pa_next(pa) me_mem(pa)
#define pa_number(pa) me_mem(1+pa)
#define pa_windows(pa) me_mem(2+pa)
#define pa_current_window(pa) me_mem(3+pa)
#define pa_sizeof 4
#define pa_map(pa1, pa2) for (pa2 = pa1; pa2 != null; pa2 = pa_next(pa2))
#define pa_update (pa_current_window(se_current_page) = se_current_window)
$eod
$ create PROMPT.BND
$deck
  # Zilch Screen Editor
  #   Copyright (c) 1982,1983,1984,1986,1987 William P. Wood, Jr.
  # Prompt bindings and function definitions for standard Zilch
  # This file is %included by ZBIND.BND

%mode					prompt
  define(header,implicit integer (a-p,r-z); implicit logical (q)
    include "memory.cmn")

  define(unbound_key_sequence,
	q_status = false)
  define(qio_error,	# not really for QIO error;
			# had to do here since cannot bind to NULL
	if (pusize == -1) {			# read from user, not pushback
	  pusize = bu_size(pu_buffer)
	  bu_size(pu_buffer) = 0
	  })
  define(qio_error_in_insert_mode,		# can't happen here
	continue)
  define(control_y_interrupt,
	continue)				# rebound below
  define(end_function_definition,
	next)

  function q_pr_read_prompt(pr, st, len)
  header
  include "session.cmn"
  include "pushb.cmn"
  include "screen.cmn"
  include "prompt.cmn"
  byte pr(ARB)
  byte c, get_tty_character
  logical q_status

  q_pr_read_prompt = true
  se_in_prompt = true
  sc_cursor_y = sc_size
  mode = bi_use_keymap(PROMPT_MODE)
  len = 0
  dot = 1
  *st_buffer(st) = EOS
  q_status = true
  pusize = -1
  recall_current = mod(recall_last, MAX_RECALL) + 1
  recall_len(recall_current) = 0
  recall(1, recall_current) = EOS
  for (call ms_message(pr) ; ; call ms_message3(pr,st,len,dot)) {
	if (! q_status) {
	  call ms_error(EOS)
	  q_status = true
	  }
	cmd = bi_get_command()

pr_self_insert				\1-\177
	q_status = q_pr_self_insert(st_buffer(st),len,dot,pu_last_key_struck)
exit_prompt_mode			^M
	if (pusize == -1)		# not reading partial prompt from user?
	  break
	bu_size(pu_buffer) = pusize	# return to push-back buffer
	pusize = -1
pr_kill_to_beginning_of_line		^U
	call pr_kill_to_beginning_of_line(st_buffer(st),len,dot)
pr_delete_previous_character		\177
	call pr_delete_previous_character(st_buffer(st),len,dot)
pr_previous_line			^B
	recall_current = recall_current - 1
	if (recall_current == 0)
	  recall_current = MAX_RECALL
	if (recall_len(recall_current) == -1)
	  recall_current = mod(recall_last, MAX_RECALL) + 1
	len = recall_len(recall_current)
	dot = len+1
	call movc(recall(1, recall_current), st_buffer(st), len+1)
pr_next_line						# not bound
	repeat
	  recall_current = mod(recall_current, MAX_RECALL) + 1
	  until (recall_len(recall_current) != -1)
	len = recall_len(recall_current)
	dot = len+1
	call movc(recall(1, recall_current), st_buffer(st), len+1)
pr_previous_character			^D
	dot = max(1, dot-1)
pr_next_character			^F
	dot = min(len+1, dot+1)
pr_end_of_line				^E
	dot = len+1
pr_beginning_of_line			^H
	dot = 1
pr_add_text_before_cursor		^A
	q_status = q_pr_add_text_before_cursor(st,len,dot)
pr_abort				^G
	call ms_error("Aborted.")
	q_pr_read_prompt = false
	break
pr_special_character			\\
	call ms_message3(pr,st,len,dot)
	c = get_tty_character()
	if (c == '@')
	  c = 0
	else if (c == 8%31)
	  call redraw
	else if (c >= '0' && c <= '9') {		# get octal value
	  n = 0
	  repeat {
	    c = n*8 + (c - '0')
	    n = c
	    q_status = q_pr_self_insert(st_buffer(st),len,dot,c)
	    call ms_message3(pr,st,len,dot)
	    if (q_status)
	      call pr_delete_previous_character(st_buffer(st),len,dot)
	    else
	      call ms_error(EOS)
	    c = get_tty_character()
	    } until (c < '0' || c > '9')
	  call pu_push_back_character(c)
	  c = n
	  }
	if (q_status)
	  q_status = q_pr_self_insert(st_buffer(st),len,dot,c)
	else
	  q_status = true
pr_control_y				^Y
	call redraw
	q_status = q_pr_self_insert(st_buffer(st),len,dot,pu_last_key_struck)
	end_function_definition	#MAKEBIND isn't smart enough to put this at end
	}

  if (pusize != -1)
    bu_size(pu_buffer) = pusize
  mode = bi_use_keymap(mode)
  se_in_prompt = false
  if (q_pr_read_prompt && len > 0)	# add new entry to recall buffer...
    if (! q_cmpc(recall(1, recall_last), recall_len(recall_last),
      						st_buffer(st), len, neq)) {
      recall_last = mod(recall_last, MAX_RECALL) + 1
      recall_len(recall_last) = len
      call movc(st_buffer(st), recall(1, recall_last), len+1)
      }
  return
  end

  subroutine pr_add_to_recall(recall_st)
  header
  include "prompt.cmn"
  byte recall_st(ARB)

  len = ho_length(recall_st)
  len = min(MAX_PROMPT - 1, len + 1 + recall_len(recall_last)) -
  							recall_len(recall_last)
  if (len > 1) {
    if (recall_len(recall_last) >= 0)			# starts out as -1
      recall(recall_len(recall_last) + 1, recall_last) = ' '
    call movc(recall_st,recall(recall_len(recall_last) + 2,recall_last),len-1)
    recall_len(recall_last) = recall_len(recall_last) + len
    recall(recall_len(recall_last) + 1, recall_last) = EOS
    }
  return
  end

  function q_pr_self_insert(buf,len,dot,char)
  header
  byte buf(ARB), char

  if (len+1 < MAX_PROMPT) {
    len = len+1
    call movc(buf(dot), buf(dot+1), len-dot)
    buf(len+1) = EOS
    buf(dot) = char
    dot = dot+1
    }
  else
    return(false)
  return(true)
  end

  function q_pr_add_text_before_cursor(st,len,dot)
  header

  bu = bu_find_by_name("Save")
  if (bu != null)
    if (len+bu_size(bu) < MAX_PROMPT) {
      n = bu_size(bu)
      call movc(st_buffer(st+dot-1), st_buffer(st+dot+n-1), len+1-dot)
      len = len + n
      *st_buffer(st+len) = EOS
      call tx_copy_text_to_string(bu,1,n,st+dot-1)
      dot = dot + n
      }
    else
      return(false)
  return(true)
  end

  subroutine pr_delete_previous_character(buf,len,dot)
  header
  byte buf(ARB)

  if (dot > 1) {
    dot = dot - 1
    call movc(buf(dot+1), buf(dot), len-dot)
    buf(len) = EOS
    len = len - 1
    }
  return
  end

  subroutine pr_kill_to_beginning_of_line(buf,len,dot)
  header
  byte buf(ARB)

  if (dot > 1) {
    len = len + 1 - dot
    call movc(buf(dot), buf(1), len)
    buf(len+1) = EOS
    dot = 1
    }
  return
  end

  function q_pr_ask(q,defans,aborted)
  header
  byte q(ARB),ho_clower
  logical defans,aborted

  st = st_allocate(MAX_PROMPT)
  aborted = ! q_pr_read_prompt(q,st,len)
  q_pr_ask = (! aborted) && (ho_clower(*st_buffer(st)) == 'y' ||
				(defans && ho_clower(*st_buffer(st)) != 'n'))
  call st_deallocate(st)
  return
  end
$eod
$ create PROMPT.CMN
$deck
#define MAX_RECALL 7

common /prompt/ recall, recall_len, recall_last

  byte recall(MAX_PROMPT, MAX_RECALL)		# circular recall buffer
  integer recall_len(MAX_RECALL), recall_last

  data recall_len /MAX_RECALL*-1/, recall_last /1/
$eod
$ create PROTO.COM
$deck
$ if p1 .nes. "" then list/noprompt 'p1'.c (/%{/-1g+2)>>proto.h
$ if p1 .eqs. "" then list/noprompt *.c (/%{/-1g+2)>proto.h
$ x/save=nl:/ini=sys$input proto.h
10000c;\12\12
10000c\12;\12
[/staticmt]1000xm
$eod
$ create PROTO.H
$deck
intp me_allocate(int size);
void me_deallocate(intp ptr);
int bi_use_keymap(int mode);
int bi_get_command(void);
int bi_allocate(int n);
int bi_new(int k);
int bi_make_bindings(int fnc, register const char *key);
void bi_bind_to_key(int fnc, register const char *key);
int q_bi_in_mode(int mode);
int q_switch_to_buffer(register bufferp bu, const char *na);
int q_pop_to_buffer(bufferp bu, const char *na);
int q_visit_file(const char *na, int switch_buffer, int nf);
void multi_visit_file(const char *na, int switch_buffer, int clear_context);
void bu_ready(register bufferp bu);
int q_bu_find_window(const char *na);
int q_bu_pop_up_message(register const char *msg, int mlen, const char *na);
bufferp bu_find_by_file_name(const char *na);
bufferp bu_find_by_name(const char *na);
bufferp bu_new(const char *name, const char *fname);
bufferp bu_new_sub_buffer(bufferp parent, int id);
bufferp bu_delete_sub_buffer(register bufferp bu);
void bu_new_names(register bufferp bu, const char *name, const char *fname);
bufferp bu_make_name(const char *file);
void bu_clear_text(register bufferp bu);
int q_buffer_list(void);
void bu_list_page(register bufferp bu, pagep pacurrent);
void bu_switch_case(void);
int q_co_parse(const char **comand, char *arg, int comma_is_white);
int q_co_matswi(const char *swtch, const char *templ, int *ler, const char *errmsg, long int *n, char *cbuf, int csize);
void co_error(const char *swtch, int i, const char *errmsg);
int cs_adm3a_clear(void);
int cs_adm3a_replace(int old, int new, int neq);
int cs_adm3a_delete(void);
int cs_adm5_replace(int old, int new, int neq);
int cs_vt100_clear(void);
int cs_vt100_replace(int old, int new, int neq);
int cs_vt100_insert(int newlen, int neq, int cheap, int idc);
int cs_vt100_delete(int cheap, int idc);
int cs_vt52_clear(void);
int cs_vt52_replace(int old, int new, int neq);
int q_he_help(void);
int ho_length(register const char *str);
void ho_scopy(register const char *from, int i, register char *to, int j);
int ho_clower(int c);
int ho_cupper(int c);
int q_ho_is_upper(int c);
int q_ho_equal(register const char *str1, register const char *str2);
int ho_index(register const char *str, int c);
int ho_indexq(register const char *str, int c);
int ho_nuqcp(register const char *buf, register int i);
int ho_bkscnq(register const char *str, const char *brk, int i);
int ho_itoc(long int intg, register char *str, int size);
int ho_itocrj(long int intg, char *str, int size);
long int ho_ctoi(register const char *in, int *index);
void advance_over_white_space(void);
void delete_white_space(void);
void do_indent(textind n);
textind current_indent(void);
textind current_column(void);
void goto_column(textind n);
void set_indent(textind n);
void tab_to_column(textind n);
void in_enter(void);
void in_reenter(void);
void in_exit(void);
void in_post_inserted_text(void);
void in_escape(void);
void in_carriage_return(void);
void in_increase_indent(void);
void in_decrease_indent(void);
void in_self_insert(void);
void in_delete_previous_character(void);
int main(int argc, const char *argv[]);
void case_change(void);
void save_text(void);
void extract_text(void);
void delete_text(void);
void add_text_after_cursor(void);
void add_text_before_cursor(void);
void save_location(void);
void exchange_dot_and_save_location(void);
void goto_save_location(void);
void write_text(void);
markp mk_new(textind mark);
markp mk_link(register markp mk, register bufferp bu);
markp mk_unlink(register markp mk, register bufferp bu);
textind mk_set_mark(register markp mk, textind mark, register bufferp bu);
void pa_switch(int n);
void pa_make_current(pagep pa);
void pa_generate(register int n);
pagep pa_new(int n);
void switch_to_page(int n);
void pa_ready(pagep pa);
void pa_next_page(void);
void pa_previous_page(void);
pagep pa_prev(pagep page);
void pu_initialize(void);
void pu_push_region(bufferp but, bufferp buf, textind p1, textind p2);
void pu_push_string(bufferp bu, register const char *str);
void pu_push_character(bufferp bu, int c);
void pu_push_back_character(int c);
void pu_push_back_buf(register const char *buf, int len);
void pu_nextc(bufferp bu, char *c);
bufferp sp_read_buffer(const char *na, stringp *fp, const char *err);
stringp st_allocate(int size);
void st_deallocate(stringp ptr);
void st_display(stringp st);
void st_scopy(stringp s1, stringp s2);
int st_length(stringp st);
void te_initialize(void);
int q_te_set_type(char *type);
int q_te_set_width(int width);
int q_te_set_length(int length);
void te_pos(int irow, int icol);
void te_clear(void);
void te_init_sequence(void);
void te_finish(void);
void te_output_number(register int n);
void te_scroll_up_lines(int top, int bot, register int nlines);
void te_scroll_down_lines(int top, int bot, register int nlines);
void te_erase_to_end_of_line(int old, int new);
void te_set_window(int top, int bot);
void te_reverse_video(void);
void te_reverse_video_off(void);
void te_printer_on(void);
void te_printer_off(void);
textp tx_address(bufferp bu, textind x);
void tx_set_gap(bufferp bu, textind x);
void tx_movc(textp from, textp to, textind len);
void tx_delete(bufferp bu, textind tx1, textind tx2);
void tx_insert_character(bufferp bu, int  c, textind tx);
void tx_add_character(bufferp bu, int c);
void tx_insert_buffer(bufferp bu, textind tx, const char *buf, int len);
void tx_copy_text(bufferp buf,textind from,bufferp but,textind to,textind len);
void tx_more_memory_please(bufferp bu, textind size);
int q_tx_search_forward(bufferp bu,textind t1,textind t2,const char *buf,const char *mask,int len,textind *loc);
int q_tx_search_reverse(bufferp bu,textind t1,textind t2,const char *buf,const char *mask,int len,textind *loc);
void tx_case_change(bufferp bu, textind t1, textind t2);
void tx_copy_text_to_string(bufferp bu, textind t1, textind t2, stringp st);
void send_string_to_terminal(const char *buf);
void send_message_to_terminal(const char *buf);
int get_tty_character(void);
int q_get_tty_number(long int *n, const char *pr);
int q_split_current_window(void);
void wi_switch_to_buffer(windowp wi, bufferp bu);
int q_pop_up_window(void);
windowp wi_new(int size);
int q_enlarge_window(void);
int q_shrink_window(void);
void next_window(void);
void previous_window(void);
int q_delete_window(void);
void delete_other_windows(void);
void beginning_of_window(void);
void wi_fill(void);
void wi_display(register windowp w);
void wi_equalize(void);
windowp wi_copy(windowp wi);
void wi_status(register windowp wi);
void wi_ready(windowp wi);
void next_word(void);
void previous_word(void);
void wo_skip_non_word(int end, int inc, int cross, int class);
void wo_skip_word(int end, int inc, int class);
void ma_initialize(void);
void ma_begin(void);
void ma_end(void);
void ma_invoke(int mnumb);
void ma_delete(int mnumb);
void ma_replace(int mnumb);
void ma_save_macros(char *buf, int *nc, int bsize);
void ma_restore_macros(const char *buf, int nc);
int q_ma_write_macros(const char *file);
int q_ma_read_macros(const char *file);
void ms_message(const char *mess);
void ms_message3(const char *mess, stringp st, int stlen, textind dot);
void ms_message2(const char *mess, stringp st);
void ms_add_to_message(const char *mess);
void ms_error(const char *mess);
void ms_report_number(const char *s1, long int n, const char *s2);
void ms_report_number2(const char *s1,long int n,const char *ss,const char *sp);
void checkpoint_modified_files(void);
int q_ch_buffer(bufferp bu);
int q_ch_name(bufferp bu, char *name);
int q_ch_gen_name(const char *buname, char *chname);
void ch_delete(bufferp bu);
int q_ch_recover(bufferp bu);
void delete_region(textind t1, textind t2);
void yank_buffer(const char *buffer);
int q_copy_region_to_buffer(const char *buffer, textind t1, textind t2);
void delete_region_to_buffer(const char *buffer, textind t1, textind t2);
void next_character(void);
void previous_character(void);
void next_line(void);
void scroll_next_line(void);
void scroll_next_line_col(textind hug);
void previous_line(void);
void scroll_previous_line(void);
void scroll_previous_line_col(textind hug);
void scroll_one_line_up(void);
void scroll_one_line_down(void);
void next_half_screen(void);
void previous_half_screen(void);
void previous_screen(void);
void next_screen(void);
textind find_bol(bufferp bu, textind loc);
void beginning_of_line(void);
textind find_eol(bufferp bu, textind loc);
void end_of_line(void);
void ends_of_line(void);
void line_to_top_of_window(void);
int q_bol(void);
int q_eol(void);
void beginning_of_file(void);
void goto_last_lines_of_file(void);
void goto_end_of_file(void);
void end_of_file(void);
void insert_character(int c);
void insert_string(const char *buf);
void delete_previous_character(void);
void delete_next_character(void);
void kill_to_beginning_of_line(void);
void kill_through_end_of_line(void);
void kill_to_end_of_line(void);
void yank_kill(void);
int q_dot_is_visible(void);
int find_next_character(void);
void se_initialize(void);
int q_se_define_word_class(const char *list, int start_class);
void sc_update(volatile int *readc);
void up_display_buffer_size(void);
long int get_process_info(char *process_name,long int *plen,long int *pid,long int *biocnt,long int *bytcnt,long int *astcnt);
void dcl_call(void);
void dcl_finish(void);
void dcl_xcall(void);
void ed_save_session(void);
void zilch(int argc, const char *argv[]);
int q_sr_get_search_string(const char *pr);
int q_search_forward(long int count);
int q_search_reverse(long int count);
void sr_replace(const char *buf, int len);
int q_sr_buffer_search_forward(bufferp bu,char *str,int len,textind from,textind to,textind *loc);
int q_sr_buffer_search_reverse(bufferp bu,char *str,int len,textind from,textind to,textind *loc);
void mp_initialize(void);
void mp_get_mapping(void);
void mp_pop(void);
void mp_set_mappings(bufferp bu, int type);
int mp_minimum_indent(bufferp bu);
void mp_change_mappings(void);
int q_mp_empty(void);
void mp_next_procedure(void);
void mp_previous_procedure(void);
int q_mp_at_comment(void);
void mp_beginning_of_line(void);
int q_mp_read_file(bufferp bu, const char *name, textind dot, int setpro);
int q_mp_write_file(bufferp bu, const char *name, int type, int *stat);
$eod
$ create PROTOASM.H
$deck
/* Prototypes for asssembler, or macro, routines */

#if VMS

#define movc movc_c
void movc(const char *in, char *out, unsigned short int len);
#define q_cmpc q_cmpc_c
int q_cmpc(const char *s1, unsigned int l1, const char *s2,
		unsigned int l2, int *neq);
#define fillc fillc_c
fillc(char *out, unsigned int len, char c);
#define secnds secnds_c		/* gasp! FORTRAN! */
secnds(float secs);

#endif

#if MSDOS

#include <mem.h>

#define movc(in, out, len) memcpy(out, in, len)

#endif
$eod
$ create PUSHB.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "pushb.cmn"
#include "memory.cmn"

void pu_initialize(void)
{
  pu_buffer = bu_new("push-back", "");
}

void pu_push_region(bufferp but, bufferp buf, textind p1, textind p2)
{
  tx_copy_text(buf, p1, but, 1, p2-p1);
  bu_modified(but) = 0;
}

void pu_push_string(bufferp bu, register const char *str)
{
  const char *s;

  for (s = str, str += ho_length(str); str-- > s; )
    tx_insert_character(bu, *str, 1);
  bu_modified(bu) = 0;
}

void pu_push_character(bufferp bu, int c)
{
  tx_insert_character(bu, c, 1);
  bu_modified(bu) = 0;
}

void pu_push_back_character(int c)
{
  tx_insert_character(pu_buffer, - c, 1);
  bu_modified(pu_buffer) = 0;
}

void pu_push_back_buf(register const char *buf, int len)
{
  for (buf += len; len-- > 0; )
    tx_insert_character(pu_buffer, - (*--buf), 1);
  bu_modified(pu_buffer) = 0;
}

void pu_nextc(bufferp bu, char *c)
{
  if (bu_size(bu) > 0) {
    *c = tx_text(tx_address(bu, 1));
    tx_delete(bu, 1, 1);
    bu_modified(bu) = 0;
    }
}
$eod
$ create PUSHB.CMN
$deck
declare int
	pu_buffer;

declare char
	pu_tty_c,
	pu_last_key_struck;
$eod
$ create REGION.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "session.cmn"
#include "memory.cmn"

void delete_region(textind t1, textind t2)
{
  tx_delete(se_current_buffer, min(t1, t2), max(t1, t2)-1);
}

void yank_buffer(const char *buffer)
{
  bufferp bu;

  bu = bu_find_by_name(buffer);
  if (bu == null) {
    ms_message("Non-existent buffer: \"");
    ms_add_to_message(buffer);
    ms_add_to_message("\"");
    ms_error("");
    }
  else if (bu == se_current_buffer)
    ms_error("Can't insert a buffer into itself!");
  else {
    wi_dot(se_current_window) = wi_dot(se_current_window)+1;/* make it inc dot */
    tx_copy_text(bu, 1, se_current_buffer,
		      wi_dot(se_current_window)-1, bu_size(bu));
    wi_dot(se_current_window) = wi_dot(se_current_window)-1;/* end fake-out */
    }
}

int q_copy_region_to_buffer(const char *buffer, textind t1, textind t2)
{
  bufferp bu;

  bu = bu_find_by_name(buffer);
  if (bu == null)
    bu = bu_new(buffer, "");
  else if (bu == se_current_buffer) {
    ms_error("Can't insert a buffer into itself!");
    return false;
    }
  else {
    bu_clear_text(bu);
    tx_more_memory_please(bu, abs(t1-t2));
    }
  tx_copy_text(se_current_buffer, min(t1,t2), bu, 1, abs(t1-t2));
  bu_modified(bu) = 0;
  return true;
}

void delete_region_to_buffer(const char *buffer, textind t1, textind t2)
{
  if (q_copy_region_to_buffer(buffer, t1, t2))
    delete_region(t1, t2);
}
$eod
$ create SCREEN.CMN
$deck
#define sc_old_length(index) (sc_old_len[(index)-1])
#define sc_new_length(index) (sc_new_len[(index)-1])
declare int
	sc_size,
	sc_width,
	sc_cursor_x,
	sc_cursor_y,
	sc_old_len[SCREEN_SIZE + 1],
	sc_new_len[SCREEN_SIZE];

#define sc_modified(index) (sc_mod[(index)-1])
declare char
	sc_error_occurred,
	sc_redraw,
	sc_mod[SCREEN_SIZE];

declare char
	sc_buffer [2] [SCREEN_SIZE + 1] [SCREEN_WIDTH + 1];
$eod
$ create SCREEN.H
$deck
#define sc_old 0
#define sc_new 1
#define sc_reverse_video(line, screen) (sc_buffer[screen][line-1][0])
$eod
$ create SCREEN.RAT
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "session.cmn"
#include "screen.cmn"
#include "memory.cmn"
#include "terminal.cmn"

void sc_initialize(void)
{

  sc_size = min(ti_length, SCREEN_SIZE);
  sc_width = ti_width;
  sc_error_occurred = false;
  for (i = 1; i <= SCREEN_SIZE; i++) {
    sc_new_length(i) = 0;
    sc_reverse_video(i,sc_old) = false;
    sc_reverse_video(i,sc_new) = false;
    }
  redraw();
  return
}

void sc_fill_line(n,txt,len)
{
  byte txt(ARB);

  sc_modified(n) = true;
  sc_new_length(n) = min(len,sc_width);
  if (len > 0) {
    movc(txt,sc_buffer(1,n,sc_new),sc_new_length(n));
    if (len >= sc_width)
      sc_buffer(sc_width,n,sc_new) = '$';
    }
  return
}

void sc_add_to_line(int n, const char *txt, int len)
{
  byte txt(ARB);

  sc_modified(n) = true;
  l = min(len, sc_width - sc_new_length(n));
  if (l > 0) {
    movc(txt,sc_buffer(sc_new_length(n)+1,n,sc_new),l);
    sc_new_length(n) = sc_new_length(n) + l;
    if (sc_new_length(n) >= sc_width)
      sc_buffer(sc_width,n,sc_new) = '$';
    }
  return
}

void redraw(void)
{

  sc_redraw = true;
  return
}

void sc_fill_new(void)
{
  int seedot;
  static const char blanks54[54] =
		    "                                                      ";

  n = 1;
  wi_map(se_windows,wi) {
    seedot = true;
    if (wi_modified(wi) == 0)
      if (! q_sc_find_cursor(wi,n)) {
	seedot = false;
	wi_modified(wi) = 1;
	}
    if (wi_modified(wi) == 0)
      n = n + wi_size(wi);
    else {
      sc_fill_window(wi,n,seedot,sc_buffer(0,1,sc_new));
      n = n + wi_size(wi);
      sc_new_length(n) = 0;
      sc_modified(n) = true;
      if (wi_mode_line(wi) == null)
	sc_reverse_video(n,sc_new) = false;
      else {
	if (te_rv)
	  sc_reverse_video(n,sc_new) = true;
	else {
	  sc_reverse_video(n,sc_new) = false;
	  sc_fill_line(n,blanks54,54);
	  }
	sc_add_to_line(n,
	    st_buffer(wi_mode_line(wi)),
	    ho_length(st_buffer(wi_mode_line(wi))));
	}
      }
    n = n+1;
    wi_modified(wi) = 0;
    }
  return
}


#define addchar(c) {		\
    if (nc < sc_width) {	\
      nc = nc+1			\
      buffer(nc,i) = c		\
      }				\
    }

/* inline coding of tx_address */
#define nextc(tx, c) {				\
	      if (tx >= gap)			\
		c = tx_text(tx + gapsiz)	\
	      else				\
		c = tx_text(tx)}

#define nextc_inc(tx, c) {			\
	      if (tx >= gap)			\
		c = tx_text((tx++) + gapsiz)	\
	      else				\
		c = tx_text(tx++)}

void sc_fill_window(wi, n, seedot, buffer)
{
  byte char, buffer(0:SCREEN_WIDTH,_incr(SCREEN_SIZE));
  int seedot;

  bu = wi_buffer(wi);
  base = bu_base(bu);
  gap = bu_gap(bu);
  gapsiz = bu_gap_size(bu);
  dot = base + wi_dot(wi);
  do {
    if (! seedot) {
      tx = base + wi_dot(wi);
      for (i = (wi_size(wi)-1)/2; i >= 0 && tx > base; i = i-1)
	for (tx = tx-1; tx > base; tx = tx-1) {
	  nextc(tx,char);
	  if (char == NEWLINE)
	    break;
	  }
      wi_bow(wi) = tx+1-base;
      }
    seedot = false;
    tx = base + wi_bow(wi);
    for (i = n; i <= n+wi_size(wi)-1; i++) {
      sc_reverse_video(i,sc_new) = false;
      sc_modified(i) = true;
      nc = 0;
      for ( ; ; ) {
	if (tx == dot) {
	  seedot = true;
	  if (wi == se_current_window && ! se_in_prompt) {
	    sc_cursor_x = min(sc_width,nc+1);
	    sc_cursor_y = i;
	    }
	  }
	nextc_inc(tx,char);
	if (char >= ' ' && char <= '~') {
	  addchar(char);
	  }
	else if (char == NEWLINE) {
	  break;
	  }
	else if (char == TAB) {
	  for (j = min(nc + 8 - mod(nc, 8), sc_width); nc < j; )
	    addchar(' ');
	  }
	else if (char >= 0 && char <= 037) {
	  addchar('^');
	  addchar(char+0100);
	  }
	else {
	  addchar('\');
	  ichar = char;
	  addchar('0' + (ichar & 0300)/0100);
	  addchar('0' + (ichar & 070)/010);
	  addchar('0' + (ichar & 07));
	  }
	}
      if (nc == sc_width)
	buffer(nc,i) = '$';
      sc_new_length(i) = nc;
      }
    } while (! seedot);
  return
}

int q_sc_dot_is_visible(wi,bu)
{
  char c;

  if (wi_bow(wi) > wi_dot(wi))
    return false;
  else {
    dot = bu_base(bu) + wi_dot(wi);
    tx = bu_base(bu) + wi_bow(wi);
    for (i = 1; i <= wi_size(wi); i++) {
      tx_find_newline(tx,bu_gap(bu),bu_gap_size(bu),&tx_text(0));
      if (dot < tx)
	return true;
      }
    return false;
    }
}

int q_sc_find_cursor(wi,n)
{
  char c;

  if (wi_bow(wi) > wi_dot(wi))
    return false;
  else {
    bu = wi_buffer(wi);
    base = bu_base(bu);
    gap = bu_gap(bu);
    gapsiz = bu_gap_size(bu);
    dot = base + wi_dot(wi);
    tx = base + wi_bow(wi);
    for (i = n; i <= n+wi_size(wi)-1; i++) {
      bl = tx;
      tx_find_newline(tx,gap,gapsiz,&tx_text(0));
      if (dot < tx) {				/* find cursor */
	if (wi == se_current_window && ! se_in_prompt) {
	  sc_cursor_y = i;
	  sc_cursor_x = 0;
	  for (tx = bl; tx < dot; ) {
	    nextc_inc(tx,c);
	    if (c >= ' ' && c <= '~')
	      sc_cursor_x = sc_cursor_x+1;
	    else if (c == TAB)
	      sc_cursor_x = sc_cursor_x+8-mod(sc_cursor_x,8);
	    else if (c >= 0 && c <= 037)
	      sc_cursor_x = sc_cursor_x+2;
	    else
	      sc_cursor_x = sc_cursor_x+4;
	    }
	  sc_cursor_x = min(sc_cursor_x + 1,sc_width);
	  }
	return true;
	}
      }
    return false;
    }
}
$eod
$ create SEARCH.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "session.cmn"
#include "memory.cmn"

static void sr_compile(char *s, char *m, int len)
{
  int i;

  for (i = 0; i < len; i++) {
    if (s[i] >= 'A' && s[i] <= 'Z')
      s[i] += 040;			/* convert to lower case */
    if (s[i] >= 'a' && s[i] <= 'z')
      *m++ = 040;			/* mask converts text to lower */
    else
      *m++ = 0;
    }
}

int q_sr_get_search_string(const char *pr)
{
  stringp st;
  int len, status;

  st = st_allocate(MAX_PROMPT);
  status = q_pr_read_prompt(pr, st, &len);
  if (status)
    if (len == 0) {
      if (se_search_length == 0) {
	ms_error("No previous search string!");
	status = false;
	}
      }
    else {					/* new search string */
      movc(st_buffer(st), st_buffer(se_search_string), len);
      se_search_length = len;
      }
  st_deallocate(st);
  if (status)
    sr_compile(st_buffer(se_search_string), st_buffer(se_search_mask),
			  se_search_length);
  return status;
}

int q_search_forward(long int count)
{
  int status;

  status = q_sr_get_search_string("Search for: ");
  if (status)
    for ( ; count > 0; count--) {
      status = q_tx_search_forward(se_current_buffer,
		  wi_dot(se_current_window), bu_size(se_current_buffer),
		  st_buffer(se_search_string),
		  st_buffer(se_search_mask), se_search_length,
		  &wi_dot(se_current_window));
      if (! status) {
	ms_error("Can't find it!");
	break;
	}
      else
	wi_dot(se_current_window) = wi_dot(se_current_window)+se_search_length;
      }
  return status;
}

int q_search_reverse(long int count)
{
  int status;

  status = q_sr_get_search_string("Reverse search for: ");
  if (status)
    for ( ; count > 0; count = count - 1) {
      status = q_tx_search_reverse(se_current_buffer, 1,
		  wi_dot(se_current_window)-2,
		  st_buffer(se_search_string),
		  st_buffer(se_search_mask), se_search_length,
		  &wi_dot(se_current_window));
      if (! status) {
	ms_error("Can't find it!");
	break;
	}
      else
	wi_dot(se_current_window) = wi_dot(se_current_window)+se_search_length;
      }
  return status;
}

void sr_replace(const char *buf, int len)
{
  bufferp bu;
  int beg, i, upfirs, upall;

  upfirs = false;
  upall = false;
  bu = se_current_buffer;
  beg = wi_dot(se_current_window) - se_search_length;
  if (se_search_length > 0)
    if (q_ho_is_upper(tx_text(tx_address(bu, beg)))) {
      upfirs = true;
      if (se_search_length > 1)
	if (q_ho_is_upper(tx_text(tx_address(bu, beg+1))))
	  upall = true;
      }
  delete_region(wi_dot(se_current_window), beg);
  for (i = 0; i < len; i++)
    if (upall || (i == 0 && upfirs))
      insert_character(ho_cupper(buf[i]));
    else
      insert_character(buf[i]);
}

int q_sr_buffer_search_forward(bufferp bu,char *str,int len,textind from,textind to,textind *loc)
{
  int status;

  sr_compile(str, st_buffer(se_search_mask), len);
  status = q_tx_search_forward(bu, from, to, str,
  				st_buffer(se_search_mask), len, loc);
  return status;
}

int q_sr_buffer_search_reverse(bufferp bu,char *str,int len,textind from,textind to,textind *loc)
{
  int status;

  sr_compile(str, st_buffer(se_search_mask), len);
  status = q_tx_search_reverse(bu, from, to, str,
  				st_buffer(se_search_mask), len, loc);
  return status;
}
$eod
$ create SECNDS.FOR
$deck
	real function secnds_c(secs)
	real secs

	secnds_c = secnds(secs)
	return
	end
$eod
$ create SESSION.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "session.cmn"

void se_initialize(void)
{
  se_pages = null;
  se_current_page = pa_new(0);
  se_buffers = null;
  se_current_window = null;
  se_save = null;
  se_restore = null;
  se_macros = null;
  se_command_count = 0;
  se_count = 0;
  se_search_string = st_allocate(MAX_PROMPT);
  se_search_mask = st_allocate(MAX_PROMPT);
  se_search_length = 0;
  se_error_occurred = false;
  se_interrupt_enabled = false;
  se_in_prompt = false;
  se_cross_lines = false;
  se_recover = false;
  se_default_case = 0;				/* lower/upper case */
  se_indent = 2;

/* define default classes; also note that Q_MP_GET_FIRST_WORD uses class 1,
 * SO DON'T MESS WITH CLASS 1 (class 1 is "A-Za-z~0-9"). */

  q_se_define_word_class("A-Za-z~0-9,0-9~.A-Za-z,)", 1);

/* if you need to change the default class definitions, add a second call
 * which starts defining at class 2, for example:
 *
 *	q_se_define_word_class("A-Z,0-9", 2)
 *
 * defines two classes, uppercase A through Z and 0-9.
 * This way Q_MP_GET_FIRST_WORD will still be able to use class 1, but classes 2
 * and above will be used for the user's word searches.
 */
}

/* Q_SE_DEFINE_WORD_CLASS defines the meaning of a "word" for word movement
 * commands. There may be up to MAX_WORD_CLASS definitions of what a word means.
 * There are two routines that scan over words, called WO_SKIP_WORD and
 * WO_SKIP_NON_WORD.  They each take as an argument what word class to use.
 * These routines are both called by the user-level routines NEXT_WORD and
 * PREVIOUS_WORD.  They work by first scanning over characters that aren't
 * in any class, then determining a class to use based on the character
 * which stopped the scan, then scanning over characters in that class.
 * Class 0 is special.  It contains, for each character, the number of the
 * class that the character is in, and 0 if the character is not in a class.
 * In fact, a character may be in more than one class, but it's PRIMARY
 * class is the one indicated by Class 0;  when NEXT_WORD and PREVIOUS_WORD
 * check what class a character is in, they check Class 0.  If a character
 * is in a class that is not it's primary class, then it cannot be used
 * to start a scan in that class, but once a scan is started, it will be
 * scanned over.  It is possible for a character to have a secondary class
 * but not a primary class, in which case it can participate in scans but
 * never start one, since its primary class is class 0.
 * For example, the following class definitions scan over numbers and words:
 *
 *	A-Za-z~0-9,0-9~.A-Za-z
 *
 * The first class definition is "A-Za-z~0-9".  That means that A through Z and
 * little a through little z are primary class members, while 0-9 are secondary
 * class members. The ~ (tilde) separates the primary and secondary class
 * members.  This class scans over words beginning with A-Z or a-z until
 * encountering a character which is not A-Z, a-z, or 0-9.
 * The second class definition is "0-9~.A-Za-z".  It is separated from the
 * first class definition by a comma.  This class scans over numbers
 * beginning with 0-9 until encountering a character which is not a period,
 * A-Z, or a-z.  Note that period is not a primary member in either class,
 * but is a secondary member of the second class.  This means that it cannot
 * start a scan, but can be scanned over if the number starts with 0-9.
 */
int q_se_define_word_class(const char *list, int start_class)
{
  int j, lastc, c, class, do_range, secondary_class;

  for (j = -128; j <= 127; j++)			/* initialize Class 0 */
    se_word_definition(j, 0) = 0;		/* no primary class to start */
  for (class = start_class; class <= MAX_WORD_CLASS; class++) {
    for (j = -128; j <= 127; j++)
      se_word_definition(j, class) = 0;	  /* no chars in this class yet */
    do_range = -1;		/* first time through - ignore leading " */
    secondary_class = false;	/* first define primary class members */
    for ( ; ; list++) {
      switch (*list) {
	case EOS:				/* done */
	  goto L20;
	case ',':				/* new class starting... */
	  list++;
	  goto L10;
	case '"':
	  if (list[1] == '"') {
	    list++;
	    c = '"';
	    break;
	    }
	  else
	    continue;			/* ignore isolated double quotes */
	case '-':			/* range, eg. A-Z */
	  if (do_range != 0)
	    c = *list;
	  else
	    do_range = 1;
	  break;
	case '~':			/* Now define secondary chars */
	  secondary_class = true;
	  break;
	case '^':			/* control character */
	  c = ho_cupper(* ++list) - 0100;
	  break;
	case '\\':			/* literal or octal number */
	  list++;
	  if (*list >= '0' && *list <= '9') {
	    c = 0;
	    do {
	      c = c*8 + (c - '0');
	      list++;
	      } while (*list >= '0' && *list <= '9');
	    list--;
	    }
	  else if (*list == 'n' || *list == 'N')
	    c = NEWLINE;
	  else if (*list == 't' || *list == 'T')
	    c = TAB;
	  else
	    c = *list;
	  break;
	default:				/* add to class */
	  c = *list;
	  break;
	}
      switch (do_range) {
	case -1:
	case  0:
	  do_range = 0;
	  lastc = c;
	  se_word_definition(c, class) = class;
	  if (! secondary_class)
	    se_word_definition(c, 0) = class;
	  break;
	case 1:
	  do_range = 2;
	  break;
	case 2:
	  do_range = 0;
	  for (j = lastc; j <= c; j++) {
	    se_word_definition(j, class) = class;
	    if (! secondary_class)
	      se_word_definition(j, 0) = class;
	    }
	  lastc = c;
	  break;
	}
      }
L10:
    ;
    }
L20:
  if (class > MAX_WORD_CLASS)
    return false;
  return true;
}
$eod
$ create SESSION.CMN
$deck
declare stringp
	se_save,
	se_restore,
	se_macros,
	se_search_string,
	se_search_mask;

declare bufferp
	se_buffers;

declare windowp
	se_current_window;

declare pagep
	se_pages,
	se_current_page;

declare long int
	se_command_count,
	se_count;

declare int
	se_default_case,
	se_indent,
	se_search_length;

declare int
	se_error_occurred,
	se_interrupt_enabled,
	se_in_prompt,
	se_cross_lines,
	se_recover;

#define MAX_WORD_CLASS 10
#define se_word_definition(c, class) (se_word_def[class][128+(c)])
declare char
	se_word_def [MAX_WORD_CLASS+1] [256];
$eod
$ create SESSION.H
$deck
#define se_current_buffer wi_buffer(se_current_window)
#define se_windows pa_windows(se_current_page)
$eod
$ create SPFILES.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "memory.cmn"

bufferp sp_read_buffer(const char *na, stringp *fp, const char *err)
{
  bufferp bu;

  if (*fp == null)
    return null;
  bu = bu_find_by_name(na);
  if (bu == null) {
    bu = bu_new(na, "");
    if (! q_mp_read_file(bu, st_buffer(*fp), 0, false)) {
      st_deallocate(*fp);
      *fp = null;
      ms_error(err);
      return null;
      }
    }
  return bu;
}
$eod
$ create SPFILES.CMN
$deck
declare stringp
			sp_help
#ifdef initialize
				= null
#endif
			, sp_pasmap
#ifdef initialize
				= null
#endif
			, sp_formap
#ifdef initialize
				= null
#endif
			, sp_ratmap
#ifdef initialize
				= null
#endif
			, sp_textmap
#ifdef initialize
				= null
#endif
			, sp_cmap
#ifdef initialize
				= null
#endif
				;
$eod
$ create STRING.C
$deck
/*	Zilch Screen Editor
 *	Copyright (c) 1982,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "memory.cmn"

stringp st_allocate(int size)
{
  return CHARS_PER_INT*me_allocate((size - 1)/CHARS_PER_INT + 1);
}

void st_deallocate(stringp ptr)
{
  me_deallocate(ptr/CHARS_PER_INT);
}

void st_display(stringp st)
{
  send_message_to_terminal(st_buffer(st));
}

void st_scopy(stringp s1, stringp s2)
{
  ho_scopy(st_buffer(s1), 1, st_buffer(s2), 1);
}

int st_length(stringp st)
{
  return ho_length(st_buffer(st));
}
$eod
$ create SYMBOLS.H
$deck
#if VMS				/* VMS is predefined by VMS C */
# define TURBOC 0
# define MSDOS 0
#else
# define TURBOC 1
# define MSDOS 1
#endif

#ifdef initialize		/* allocating storage in EXTERN.C */
#define declare
#else				/* otherwise just declaring the storage */
#define declare extern
#endif

typedef long int intp;		/* data type of pointers into memory */
typedef intp stringp;		/* pointer to strings */
typedef intp bufferp;		/* pointer to buffers */
typedef intp windowp;		/* pointer to windows */
typedef intp pagep;		/* pointer to pages */
typedef intp markp;		/* pointer to marks */
typedef intp textp;		/* pointer to text in text buffer */
typedef long int textind;	/* index into text buffer */

#if VAX
#define SCREEN_SIZE 52		/* max screen length */
#define SCREEN_WIDTH 132	/* max screen width */
#define MAX_PROMPT 513
#define MAX_COMMAND 513
#endif
#if MSDOS
#define SCREEN_SIZE 25		/* max screen length */
#define SCREEN_WIDTH 80		/* max screen width */
#define MAX_PROMPT 129
#define MAX_COMMAND 129
#endif
#define EOS '\0'
#define ARB 1
#define CR 015
#define LF 012
#define NEWLINE 012
#define TAB 011
#define CONTROL_U 025
#define CONTROL_Q 021
#define RUBOUT 0177
#define CHARS_PER_INT sizeof(intp)
#define MAXINT 0x7fffffffL
#define MACRO_SIZE 512
#define MAX_MACROS 10
/* #define EOF -10 */
#define RECORDTOOLONG -40
#define READ_UNIT 1
#define WRITE_UNIT 2
#define FIND_UNIT 3
#define false 0
#define true 1
#define null 0

#include <stddef.h>
#include "proto.h"
#include "protoasm.h"		/* Assembler, or Macro, routine prototypes */
#include "session.h"
#include "buffer.h"
#include "window.h"
#include "bind.h"
#include "screen.h"
#include "page.h"
#include "mappings.h"
#include "mark.h"
#include "fileio.h"
#include "text.h"
/*include "[.seq]seq.sym" */

#ifndef abs
#define abs(x) ((x) < 0 ? -(x) : (x))
#endif
#ifndef min
#define min(x, y) ((x) < (y) ? (x) : (y))
#endif
#ifndef max
#define max(x, y) ((x) > (y) ? (x) : (y))
#endif
#define mod(x, y) ((x) % (y))

#ifdef VMS
#define EXIT_GOOD 1
#define EXIT_BAD 2
#define NODESIZE 256
#define DEVSIZE 256
#define UICSIZE 256
#define NAMESIZE 256
#define EXTSIZE 41
#define VERSIZE 7
#define FILENAMESIZE 256
#endif

#ifdef MSDOS
#define EXIT_GOOD 0
#define EXIT_BAD 1
#define NODESIZE 1
#define DEVSIZE 3
#define UICSIZE 61
#define NAMESIZE 9
#define EXTSIZE 5
#define VERSIZE 1
#define FILENAMESIZE 75
#endif
$eod
$ create SYSCODES.H
$deck
#if VMS
#include <ssdef.h>
#include <iodef.h>
#include <ttdef.h>
#include <tt2def.h>
#include <dcdef.h>
#include <dvidef.h>
#endif
$eod
$ create TABLES.CMN
$deck
/* ta_clower(c) converts c to lower case */
#define ta_clower(c)	ta_clow[128 + (c)]

/* ta_lower(c) does the same except neg chars are converted to zero */
#define ta_lower(c)	ta_low[128 + (c)]

declare const char
	ta_clow[256]		/* converts chars to lower case */
# ifdef initialize
= {-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,
   -115,-114,-113,-112,-111,-110,-109,-108,-107,-106,-105,-104,-103,
   -102,-101,-100, -99, -98, -97, -96, -95, -94, -93, -92, -91, -90,
    -89, -88, -87, -86, -85, -84, -83, -82, -81, -80, -79, -78, -77,
    -76, -75, -74, -73, -72, -71, -70, -69, -68, -67, -66, -65, -64,
    -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53, -52, -51,
    -50, -49, -48, -47, -46, -45, -44, -43, -42, -41, -40, -39, -38,
    -37, -36, -35, -34, -33, -32, -31, -30, -29, -28, -27, -26, -25,
    -24, -23, -22, -21, -20, -19, -18, -17, -16, -15, -14, -13, -12,
    -11, -10,  -9,  -8,  -7,  -6,  -5,  -4,  -3,  -2,  -1,
      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,
     13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,
     26,  27,  28,  29,  30,  31, ' ', '!', '"', '#', '$', '%', '&',
   '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3',
    '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@',
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    '[', '\\', ']', '^', '_', '`',
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    '{', '|', '}', '~', 127 }
#endif
	;

declare const char
	ta_low[256]		/* converts chars to lower case */
# ifdef initialize
 = {  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,
     13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,
     26,  27,  28,  29,  30,  31, ' ', '!', '"', '#', '$', '%', '&',
   '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3',
    '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@',
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    '[', '\\', ']', '^', '_', '`',
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    '{', '|', '}', '~', 127 }
#endif
	;
$eod
$ create TECON.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1983,1984,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "terminal.cmn"

static void te_output_number(register int n)
{
  char ot[3];

  if (n < 10) {
    ot[0] = n + '0';
    ti_outch(ot, 1);
    }
  else if (n < 100) {
    ot[0] = n/10 + '0';
    ot[1] = mod(n, 10) + '0';
    ti_outch(ot, 2);
    }
  else {
    ot[0] = n/100 + '0';
    ot[1] = mod(n/10, 10) + '0';
    ot[2] = mod(n, 10) + '0';
    ti_outch(ot, 3);
    }
}

static void te_set_window(int top, int bot)
{
# define len_vt100_set_window 2
  static char vt100_set_window[] = "\33[";

  ti_outch(vt100_set_window, len_vt100_set_window);
  if (top > 1)
    te_output_number(top);
  ti_outch(";", 1);
  if (bot != 0)
    te_output_number(bot);
  ti_outch("r", 1);
  te_pos_x = 1;
  te_pos_y = top;
}

void te_initialize(void)
{
  ti_kill();
  switch (te_type) {
    case VT100:
      te_size_x = 80;
      te_size_y = 24;
      te_rv = true;
      te_in = true;
      te_application_keypad = false;
      break;
    case ADM3A:
    case ADM5:
    case VT52:
      te_size_x = 80;
      te_size_y = 24;
      te_rv = false;
      te_in = false;
      te_application_keypad = false;
      break;
    }
  te_pos_x = te_size_x + 1;		/* invalidate cursor position */
}

int q_te_set_type(char *type)
{
  if (q_ho_equal(type, "vt100"))
    te_type = VT100;
  else if (q_ho_equal(type, "adm3a"))
    te_type = ADM3A;
  else if (q_ho_equal(type, "adm5"))
    te_type = ADM5;
  else if (q_ho_equal(type, "vt52"))
    te_type = VT52;
  else
    return false;
  te_initialize();
  return true;
}

int q_te_set_width(int width)
{
  int result;

  result = false;
  switch (te_type) {
    case VT100:
      if (width >= 1)
	if (width <= 80) {
	  te_size_x = 80;
	  result = true;
	  }
	else if (width <= 132) {
	  te_size_x = 132;
	  result = true;
	  }
      break;
    case ADM3A:
    case ADM5:
    case VT52:
      if (width >= 1 && width <= 80) {
	te_size_x = 80;
	result = true;
	}
      break;
    }
  te_pos_x = te_size_x + 1;		/* invalidate cursor position */
  return result;
}

int q_te_set_length(int length)
{
  switch (te_type) {
    case VT100:
      if (length >= 1)
	if (length <= SCREEN_SIZE) {
	  te_size_y = max(ti_length, length); /* te_size_y is max screen len */
	  return true;
	  }
      break;
    case ADM3A:
    case ADM5:
    case VT52:
      if (length >= 1)
	if (length <= 24) {
	  te_size_y = 24;
	  return true;
	  }
      break;
    }
  return false;
}

/* Position the cursor */
void te_pos(int irow, int icol)
{
  int dif;
  static const char bspaces[] = "\10\10\10";
  char c;

  if (te_pos_x >= te_size_x || te_pos_x != icol || te_pos_y != irow) {
    dif = te_pos_x - icol;
    if (te_pos_x < te_size_x && te_pos_y == irow && dif > 0 && dif < 4)
      ti_outch(bspaces, dif);
    else {
      switch (te_type) {
	case ADM3A:
	case ADM5:
	  ti_outch("\33=", 2);
	  c = irow + 31;
	  ti_outch(&c, 1);
	  c = icol + 31;
	  ti_outch(&c, 1);
	  break;
	case VT52:
	  ti_outch("\33Y", 2);
	  c = irow + 31;
	  ti_outch(&c, 1);
	  c = icol + 31;
	  ti_outch(&c, 1);
	  break;
	case VT100:
	  ti_outch("\33[", 2);
	  te_output_number(irow);
	  ti_outch(";", 1);
	  te_output_number(icol);
	  ti_outch("H", 1);
	  break;
	}
      }
    te_pos_x = icol;
    te_pos_y = irow;
    }
}

void te_clear(void)
{
  switch (te_type) {
    case ADM3A:
    case ADM5:
      ti_outch("\33;\32", 3);
      break;
    case VT100:
      ti_outch("\33[2J\33[H", 7);
      break;
    case VT52:
      ti_outch("\33H\33J", 4);
      break;
    }
  te_pos_x = 1;
  te_pos_y = 1;
}

void te_init_sequence(void)
{
# include "screen.cmn"
# define len_vt100_init 26
  static char vt100_init[] = "\33<\33[?6h\33[;r\33>\33[?7l\33[?1l\33[m";
					/* enter ANSI mode,
					 * set origin mode - relative,
					 * set full screen scroll region,
					 * key pad - numeric,
					 * no auto wrap,
					 * cursor mode reset,
					 * normal text attributes */
# define len_vt100_application 2
  static char vt100_application[] = "\33=";	/* key pad - application */
# define len_vt100_set_80 5
  static char vt100_set_80[] = "\33[?3l";	/* set terminal width to 80 */
# define len_vt100_set_132 5
  static char vt100_set_132[] = "\33[?3h";	/* set terminal width to 132 */
# define len_vt52_init 2
  static char vt52_init[] = "\33>";		/* key pad - numeric */
# define len_vt52_application 2
  static char vt52_application[] = "\33=";	/* key pad - application */

  switch (te_type) {
    case VT100:
      ti_outch(vt100_init, len_vt100_init);
      if (te_application_keypad)
	ti_outch(vt100_application, len_vt100_application);
      if (sc_width <= 80 && ti_width > 80)
	ti_outch(vt100_set_80, len_vt100_set_80);
      else if (sc_width > 80 && ti_width <= 80)
	ti_outch(vt100_set_132, len_vt100_set_132);
      break;
    case VT52:
      ti_outch(vt52_init, len_vt52_init);
      if (te_application_keypad)
	ti_outch(vt52_application, len_vt52_application);
      break;
    }
  te_pos_x = te_size_x + 1;		/* invalidate cursor position */
}

void te_finish(void)
{
# include "screen.cmn"
# define len_vt100_finish 11
  static char vt100_finish[] = "\33[?6l\33[;r\33>";
      					/* set origin mode - absolute,
					 * set full screen scroll region,
					 * key pad - numeric */
# define len_vt100_set_80 5
  static char vt100_set_80[] = "\33[?3l";  /* set terminal width to 80 */
# define len_vt100_set_132 5
  static char vt100_set_132[] = "\33[?3h"; /* set terminal width to 132 */
# define len_vt52_finish 2
  static char vt52_finish[] = "\33>";	/* key pad - numeric */

  switch (te_type) {
    case VT100:
      ti_outch(vt100_finish, len_vt100_finish);
      if (ti_width <= 80 && sc_width > 80)
	ti_outch(vt100_set_80, len_vt100_set_80);
      else if (ti_width > 80 && sc_width <= 80)
	ti_outch(vt100_set_132, len_vt100_set_132);
      break;
    case VT52:
      ti_outch(vt52_finish, len_vt52_finish);
      break;
    }
  te_pos_x = te_size_x + 1;		/* invalidate cursor position */
}

void te_scroll_up_lines(int top, int bot, register int nlines)
{
# define len_vt100_cursor_down 2
  static char vt100_cursor_down[] = "\33[";
  static char lfnull[] = "\12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";

  switch (te_type) {
    case VT100:
      te_set_window(top, bot);
      ti_outch(vt100_cursor_down, len_vt100_cursor_down);
      te_output_number(bot - top);
      ti_outch("B", 1);
      for ( ; nlines > 0; nlines--)
	ti_outch(lfnull, 1);
      te_set_window(1, 0);
      break;
    case ADM3A:
    case ADM5:
    case VT52:
      /* can only be scroll screen */
      te_pos(te_size_y, 1);
      for ( ; nlines > 0; nlines--)
	ti_outch(lfnull, 1 + ti_lffill);
      break;
    }
}

void te_scroll_down_lines(int top, int bot, register int nlines)
{
# define len_vt100_reverse_index 2
  static char vt100_reverse_index[] = "\33M";

  te_set_window(top, bot);
  for ( ; nlines > 0; nlines--)
    ti_outch(vt100_reverse_index, len_vt100_reverse_index);
  te_set_window(1, 0);
}

void te_erase_to_end_of_line(int old, int new)
{
# define len_adm5_erase_to_eol 2
# define len_vt100_erase_to_eol 3
# define len_vt52_erase_to_eol 2
  static char adm5_erase_to_eol[] = "\33T";
  static char vt100_erase_to_eol[] = "\33[K";
  static char vt52_erase_to_eol[] = "\33K";
  static char blanks80[80] =
"                                                                                ";
  register int i;

  i = min(old, te_size_x) - min(new, te_size_x);
  switch (te_type) {
    case VT100:
      if (i >= len_vt100_erase_to_eol)
	ti_outch(vt100_erase_to_eol, len_vt100_erase_to_eol);
      else if (i > 0) {
	ti_outch(blanks80, i);
	te_pos_x = te_pos_x+i;
	}
      break;
    case VT52:
      if (i >= len_vt52_erase_to_eol)
	ti_outch(vt52_erase_to_eol, len_vt52_erase_to_eol);
      else if (i > 0) {
	ti_outch(blanks80, i);
	te_pos_x = te_pos_x+i;
	}
      break;
    case ADM5:
      if (i >= len_adm5_erase_to_eol)
	ti_outch(adm5_erase_to_eol, len_adm5_erase_to_eol);
      else if (i > 0) {
	ti_outch(blanks80, i);
	te_pos_x = te_pos_x+i;
	}
      break;
    case ADM3A:
      if (i > 0) {
	ti_outch(blanks80, i);
	te_pos_x = te_pos_x+i;
	}
      break;
    }
}

void te_reverse_video(void)
{
# define len_vt100_reverse_video 4
  static char vt100_reverse_video[] = "\33[7m";

  switch (te_type) {
    case VT100:
      ti_outch(vt100_reverse_video, len_vt100_reverse_video);
      break;
    }
}

void te_reverse_video_off(void)
{
# define len_vt100_reverse_video_off 3
  static char vt100_reverse_video_off[] = "\33[m";

  switch (te_type) {
    case VT100:
      ti_outch(vt100_reverse_video_off, len_vt100_reverse_video_off);
      break;
    }
}

void te_printer_on(void)
{
# define len_vt100_printer_on 4
  static char vt100_printer_on[] = "\33[5i";

  switch (te_type) {
    case VT100:
      ti_outch(vt100_printer_on, len_vt100_printer_on);
      break;
    }
}

void te_printer_off(void)
{
# define len_vt100_printer_off 4
  static char vt100_printer_off[] = "\33[4i";

  switch (te_type) {
    case VT100:
      ti_outch(vt100_printer_off, len_vt100_printer_off);
      break;
    }
}
$eod
$ create TERMINAL.CMN
$deck
#define ADM3A 1
#define VT100 2
#define ADM5 3
#define VT52 4

declare int
	te_pos_x,
	te_pos_y,
	te_size_x,
	te_size_y,
	te_type;

declare char
	te_rv,			/* terminal has reverse video */
	te_in,			/* terminal has insert line */
	te_application_keypad;	/* set keypad to application mode */


#if VMS
#define BUFFER_SIZE 512

declare int
	ti_channel,
	ti_count,
	ti_ctrl_mask,
	ti_lffill,
	ti_width,
	ti_length,
	ti_flush_iofc,
	ti_in_type_ahead_iofc,
	ti_in_character_iofc,
	ti_fast;

declare char
	ti_buffer[BUFFER_SIZE],
	ti_character;


#define MBX_SIZE 256

declare struct {
	int channel;
	struct {
		short int status;
		short int byte_count;
		variant_union {
			long int sender_pid;
			long int receiver_pid;
			long int protection_mask;
			} iosb_variant;
		} iosb;
	variant_union {
		char buffer[MBX_SIZE];
		struct {
			short int type;
			short int unit;
			unsigned char controller_name_length;
			char controller_name[15];
			short int size;
			char msg[MBX_SIZE - 22];
			} bdcst;
		} message_variant;
	char name[11];
	} mbx;


#define TI_IN_EFN 1
#define MBX_IN_EFN 2

declare int
	ef_in_mask;


declare char
	characteristics[12]

declare struct {
	short int status;
	variant_union {
		unsigned char ttspeed;
		short int trm_offset;
		} iosb_variant;
	char filler_1;
	unsigned char lffill;
	short int trm_size;
	} iosb;

declare struct {
	char class;
	char type;
	short int width;
	variant_union {
		long int characteristics;
		variant_struct {
			char filler_1[3];
			unsigned char length;
			} ttchar_variant_1;
		} ttchar_variant_2;
	long int extended_characteristics;
	} ttchar;

declare char
	ttclass,
	tttype,
	ttlength,
	ttspeed,
	lffill

  integer*2 iosb_status,ttwidth,trm_offset,trm_size
  integer*4 ttchar,ttxchar
  equivalence (characteristics(1), ttclass),
	      (characteristics(2), tttype),
	      (characteristics(3), ttwidth),
	      (characteristics(5), ttchar),
	      (characteristics(8), ttlength),
	      (characteristics(9), ttxchar)
  equivalence (iosb(1), iosb_status),
	      (iosb(3), ttspeed),
	      (iosb(3), trm_offset),
	      (iosb(7), trm_size),
	      (iosb(6), lffill)
#endif
$eod
$ create TEXT.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "session.cmn"
#include "memory.cmn"

textp tx_address(bufferp bu, textind x)
{
  textp i;

  i = x + bu_base(bu);
  if (i >= bu_gap(bu))
    return i+bu_gap_size(bu);
  else
    return i;
}

void tx_set_gap(bufferp bu, textind x)
{
  textp gap, loc;

  gap = bu_gap(bu);
  loc = bu_base(bu)+x;
  if (gap < loc)
    tx_movc(gap+bu_gap_size(bu), gap, loc-gap);
  else if (gap > loc)
    tx_movc(loc, loc+bu_gap_size(bu), gap-loc);
  bu_gap(bu) = loc;
}

void tx_movc(textp from, textp to, textind len)
{
  textind i;

  if (from >= to)
    for (i = 0; i < len; i += 65535)
      movc(&tx_text(from+i), &tx_text(to+i), min(len-i, 65535));
  else
    for (i = len; i > 0; i -= 65535)
      movc(&tx_text(from+max(0, i-65535)), &tx_text(to+max(0, i-65535)),
      								min(i, 65535));
}

void tx_delete(bufferp bu, textind tx1, textind tx2)
{
  textind len;
  windowp wi;
  markp mk;

  tx_set_gap(bu, tx1);
  len = tx2 - tx1 + 1;
  if (len > 0) {
    bu_gap_size(bu) = bu_gap_size(bu) + len;
    bu_modified(bu) = 1;
    bu_size(bu) = bu_size(bu) - len;
    bu_map_windows(bu, wi) {
      if (wi_dot(wi) > tx2)		/* ok */
	wi_dot(wi) = wi_dot(wi) - len;
      else if (wi_dot(wi) > tx1)	/* ok */
	wi_dot(wi) = tx1;
      if (wi_bow(wi) > tx2)		/* ok */
	if (wi_bow(wi) == tx2 + 1)
	  wi_bow(wi) = find_bol(bu, wi_bow(wi) - len);
	else {
	  wi_bow(wi) = wi_bow(wi) - len;
	  continue;
	  }
      else if (wi_bow(wi) > tx1)	/* ok */
	wi_bow(wi) = find_bol(bu, tx1);
      wi_modified(wi) = 1;
      }
    mk_map(bu_markers(bu), mk)
      if (mk_mark(mk) > tx2)
	mk_mark(mk) = mk_mark(mk) - len;
      else if (mk_mark(mk) > tx1)
	mk_mark(mk) = tx1;
    }
}

void tx_insert_character(bufferp bu, int c, textind tx)
{
  windowp wi;
  markp mk;

  if (bu_gap_size(bu) <= 0)
    tx_more_memory_please(bu, 1);
  tx_set_gap(bu, tx);
  tx_text(bu_gap(bu)) = c;
  bu_gap(bu) = bu_gap(bu) + 1;
  bu_gap_size(bu) = bu_gap_size(bu) - 1;
  bu_modified(bu) = 1;
  bu_size(bu) = bu_size(bu) + 1;
  bu_map_windows(bu, wi) {
    if (wi_dot(wi) > tx)		/* ok */
      wi_dot(wi) = wi_dot(wi) + 1;
    if (wi_bow(wi) > tx)		/* ok */
      wi_bow(wi) = wi_bow(wi) + 1;
    else
      wi_modified(wi) = 1;
    }
  mk_map(bu_markers(bu), mk)
    if (mk_mark(mk) > tx)
      mk_mark(mk) = mk_mark(mk) + 1;
}

#ifdef INTERFACE
void tx_add_character(bufferp bu, int c)
{
  if (bu_gap_size(bu) <= 0)
    tx_more_memory_please(bu, 1);
  tx_text(bu_gap(bu)) = c;
  bu_gap(bu) = bu_gap(bu) + 1;
  bu_gap_size(bu) = bu_gap_size(bu) - 1;
  bu_size(bu) = bu_size(bu) + 1;
}
#endif

void tx_insert_buffer(bufferp bu, textind tx, const char *buf, int len)
{
  windowp wi;
  markp mk;

  if (bu_gap_size(bu) < len)
    tx_more_memory_please(bu, len);
  if (len > 0) {
    tx_set_gap(bu, tx);
    movc(buf, &tx_text(bu_gap(bu)), len);
    bu_gap(bu) = bu_gap(bu) + len;
    bu_gap_size(bu) = bu_gap_size(bu) - len;
    bu_modified(bu) = 1;
    bu_size(bu) = bu_size(bu) + len;
    bu_map_windows(bu, wi) {
      if (wi_dot(wi) > tx)		/* ok */
	wi_dot(wi) = wi_dot(wi) + len;
      if (wi_bow(wi) > tx)		/* ok */
	wi_bow(wi) = wi_bow(wi) + len;
      else
	wi_modified(wi) = 1;
      }
    mk_map(bu_markers(bu), mk)
      if (mk_mark(mk) > tx)
	mk_mark(mk) = mk_mark(mk) + len;
    }
}

void tx_copy_text(bufferp buf,textind from,bufferp but,textind to,textind len)
{
  windowp wi;
  markp mk;

  if (len > bu_gap_size(but))
    tx_more_memory_please(but, len);
  if (len > 0) {
    tx_set_gap(but, to);
    tx_set_gap(buf, from);
    tx_movc(tx_address(buf, from), bu_gap(but), len);
    bu_gap(but) = bu_gap(but) + len;
    bu_gap_size(but) = bu_gap_size(but) - len;
    bu_modified(but) = 1;
    bu_size(but) = bu_size(but) + len;
    bu_map_windows(but, wi) {
      if (wi_dot(wi) > to)		/* ok */
	wi_dot(wi) = wi_dot(wi) + len;
      if (wi_bow(wi) > to)		/* ok */
	wi_bow(wi) = wi_bow(wi) + len;
      else
	wi_modified(wi) = 1;
      }
    mk_map(bu_markers(but), mk)
      if (mk_mark(mk) > to)
	mk_mark(mk) = mk_mark(mk) + len;
    }
}

void tx_more_memory_please(bufferp bu, textind size)
{
  stringp st;
  textind gapoff, len;
  int i;

  if (size == 0 || bu_gap_size(bu) < size || bu_gap_size(bu) > 2*(size + 4*512)){
    if (size != 0)
      size += 4*512;
    st = st_allocate(size + bu_size(bu) + SCREEN_SIZE - 2);
    gapoff = bu_gap(bu) - (bu_base(bu) + 1);
    if (gapoff > 0)
      tx_movc(bu_base(bu)+1, st, gapoff);
    len = bu_size(bu) - gapoff;
    if (len > 0)
      tx_movc(bu_gap(bu) + bu_gap_size(bu),
			  st + gapoff + size, len);
    for (i = 0; i < SCREEN_SIZE-2; i++)       /* bit of hocus-pocus here... */
      tx_text(st+bu_size(bu)+size+i) = NEWLINE; /* makes things easier */
    st_deallocate(bu_base(bu) + 1);
    bu_base(bu) = st - 1;
    bu_gap_size(bu) = size;
    bu_gap(bu) = st + gapoff;
    }
}

int q_tx_search_forward(bufferp bu,textind t1,textind t2,const char *buf,const char *mask,int len,textind *loc)
{
  textp tx, end;
  int j;

  if (bu_gap(bu) > bu_base(bu) + t1)
    tx_set_gap(bu, t1);
  for (tx = tx_address(bu, t1), end = tx_address(bu, t2+1);
			tx+len <= end; tx++) {
    for (j = 0; j < len; j++)
      if (buf[j] != (mask[j] | tx_text(j+tx)))
	goto L10;
    *loc = tx - bu_base(bu) - bu_gap_size(bu);
    return true;
L10:
    ;
    }
  return false;
}

int q_tx_search_reverse(bufferp bu,textind t1,textind t2,const char *buf,const char *mask,int len,textind *loc)
{
  textp tx, beg;
  int j;

  if (t2 > 0) {
    if (bu_gap(bu) < bu_base(bu) + t2 + 1)
      tx_set_gap(bu, t2 + 1);
    for (tx = tx_address(bu, t2+1-len), beg = tx_address(bu, t1);
			  tx >= beg; tx--) {
      for (j = 0; j < len; j++)
	if (buf[j] != (mask[j] | tx_text(j+tx)))
	  goto L10;
      *loc = tx - bu_base(bu);
      return true;
L10:
      ;
      }
    }
  return false;
}

void tx_case_change(bufferp bu, textind t1, textind t2)
{
  textp tx;
  windowp wi;
# include "tables.cmn"

  if (t2 >= t1) {
    while (t1 <= t2) {
      tx = tx_address(bu, t1++);
      if (bu_case(bu) == 1)
	tx_text(tx) = ho_cupper(tx_text(tx));
      else
	tx_text(tx) = ta_clower(tx_text(tx));
      }
    bu_modified(bu) = 1;
    bu_map_windows(bu, wi)
      if (wi_bow(wi) <= t2)
	wi_modified(wi) = 1;
    }
}

void tx_copy_text_to_string(bufferp bu, textind t1, textind t2, stringp st)
{
  while (t1 <= t2)
    *st_buffer(st++) = tx_text(tx_address(bu, t1++));
}
$eod
$ create TEXT.H
$deck
#define m_tx_address(bu, x) \
      (x + bu_base(bu) + (x + bu_base(bu) >= bu_gap(bu) ? bu_gap_size(bu) : 0))
$eod
$ create TTY.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1983,1984,1986,1987 William P. Wood, Jr. */

#include "symbols.h"

static void send_tty(const char *buf, int len)
{
# include "terminal.cmn"
  static const char lf[] =
		    "\12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";

  for ( ; len-- > 0; buf++)
    if (*buf == *lf)
      ti_outch(lf, 1 + ti_lffill);
    else
      ti_outch(buf, 1);
  te_pos_x = te_size_x+1;		/* invalidate cursor position */
}

void send_string_to_terminal(const char *buf)
{
  send_tty(buf, ho_length(buf));
  ti_flush();
}

void send_message_to_terminal(const char *buf)
{
  static const char crlf[] = "\15\12";

#if ! VAX
  send_tty(crlf,2);
#endif
  send_tty(buf,ho_length(buf));
#if VAX
  send_tty(crlf,2);
#endif
  ti_flush();
}

int get_tty_character(void)
{
# include "memory.cmn"
# include "session.cmn"
# include "macro.cmn"
# include "pushb.cmn"
# include "terminal.cmn"
  char c;
  static int was_type_ahead = false;

  if (se_error_occurred) {
    se_error_occurred = false;
    bu_clear_text(pu_buffer);			/* purge push-back-buffer */
    sc_update(&zero);				/* force screen update */
    while (q_ti_in_type_ahead(&pu_tty_c))	/* purge type-ahead */
      ;
    was_type_ahead = false;
    ti_queue_character_read();
    ti_get_character(&pu_tty_c);
    c = pu_tty_c;
    }
  else if (bu_size(pu_buffer) > 0) {
    pu_nextc(pu_buffer,&pu_tty_c);
    c = abs(pu_tty_c);
    }
  else {
    if (! was_type_ahead)
      goto L10;
    if (! q_ti_in_type_ahead(&pu_tty_c)) {
      was_type_ahead = false;
L10:  ti_queue_character_read();
      sc_update(&iosb_status);		/* now we update the screen! */
      if (iosb_status)
	was_type_ahead = true;
      ti_get_character(&pu_tty_c);
      }
    c = pu_tty_c;
    }
  if (ma_defining_macro)
    if (pu_tty_c >= 0)		     /* pu_tty_c < 0 - pushed back character */
      if (ma_next >= MACRO_SIZE) {
	ms_error("Keyboard macro overflow!");
	ma_delete(0);
	}
      else {
	ma_text[ma_next++] = c;
	ma_len[0] += 1;
	}
  pu_last_key_struck = c;
  return c;
}

int q_get_tty_number(long int *n, const char *pr)
{
  long int local_n;
  int neg, result, d;
  char c;

  local_n = 0;
  ms_message(pr);
  c = get_tty_character();
  if (c == '-') {
    neg = true;
    ms_message(pr);
    ms_add_to_message("-");
    c = get_tty_character();
    }
  else
    neg = false;
  result = false;
  for ( ; (d = ho_index("0123456789", c)) != 0; ) {
    result = true;
    local_n = 10*local_n + d - 1;
    ms_report_number(pr, local_n, "");
    c = get_tty_character();
    }
  pu_push_back_character(c);
  *n = neg ? - local_n : local_n;
  return result;
}
$eod
$ create UPDATE.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1983,1984,1986,1987 William P. Wood, Jr. */

#define TIMER 0
#define NODE_INFO 0
#define DEBUG 0

#include "symbols.h"
#include "update.cmn"
#include "screen.cmn"

#if NODE_INFO
#include "nodeinfo.cmn"
#endif

#define NONE 1
#define REPLACE 2
#define CLEAR 3
#define DELETE -1
#define INSERT -2
#define INSERT2 -3
#define UNTOUCHED 0
#define ON_OPEN 1
#define ON_CLOSED 2
#define succ(x) (x+1)
 
static void new_node(int cst,int idc,int old,int new,int neq,int op,nodep fa)
{
  register int index;

#if NODE_INFO
  nodes_generated = succ(nodes_generated);
#endif
  index = min(old - 1, sc_size) + (new - 1)*(sc_size + 1);
  if (up_stat(index) != ON_CLOSED)
    if (up_stat(index) == ON_OPEN) {
      if (up_cost(index) > cst) {
#if NODE_INFO
	nodes_replaced = succ(nodes_replaced);
#endif
	up_cost(index) = cst;
	up_insert_delete_count(index) = idc;
	up_operation(index) = op;
	up_father(index) = fa;
	up_neq(index) = neq;
	}
      }
    else {
#if NODE_INFO
      nodes_inserted = succ(nodes_inserted);
#endif
      up_open(index) = open;
      up_prev(index) = null;
      if (open != null)
	up_prev(open) = index;
      open = index;
      up_stat(index) = ON_OPEN;
      up_new_pos(index) = new;
      up_old_pos(index) = min(old,sc_size+1);
      up_cost(index) = cst;
      up_insert_delete_count(index) = idc;
      up_operation(index) = op;
      up_father(index) = fa;
      up_neq(index) = neq;
      }
}

static void remove_min_cost_node(void)
{
  register nodep op;
  int min_cost, i;

  min_node = open;
  min_cost = up_cost(open);
  op = up_open(open);
  while (op != null) {
    i = up_cost(op);
    if ((i < min_cost) ||
       ((i == min_cost) && (up_new_pos(op) > sc_size))) {
      min_cost = i;
      min_node = op;
      }
    op = up_open(op);
    }
  if (up_open(min_node) != null)
    up_prev(up_open(min_node)) = up_prev(min_node);
  if (up_prev(min_node) == null)
    open = up_open(min_node);
  else
    up_open(up_prev(min_node)) = up_open(min_node);
  up_stat(min_node) = ON_CLOSED;
}

static void skip(int *neq)
{
  while (up_new_pos(min_node) <= sc_size)
    /* this compare compares for reverse video too */
    if (q_cmpc(sc_buffer[sc_old][up_old_pos(min_node)-1],
	     sc_old_length(up_old_pos(min_node))+1,
	     sc_buffer[sc_new][up_new_pos(min_node)-1],
	     sc_new_length(up_new_pos(min_node))+1,
	     &neq)) {
      up_new_pos(min_node) = succ(up_new_pos(min_node));
      up_old_pos(min_node) = min(succ(up_old_pos(min_node)),sc_size+1);
      }
    else {
      neq = max(0, neq - 1);	/* because of reverse video */
      break;
      }
}

static void sc_find_a_way(volatile int *readc,int (*cs_replace)(int old,int new,int neq),int (*cs_delete)(int cheap,int idc),int (*cs_insert)(int newlen,int neq,int cheap,int idc))
{
  int old_new, op, np, cost, idc, neq;

#if DEBUG
  write(8,(" new page"));
#endif
  for ( ; ; ) {
    remove_min_cost_node();
    old_new = up_new_pos(min_node);
    skip(&neq);
    op = up_old_pos(min_node);
    np = up_new_pos(min_node);
    cost = up_cost(min_node);
    idc = up_insert_delete_count(min_node);
#if DEBUG
    write(8,(6i8)) op, np, up_operation(min_node), neq, cost;
#endif
#if NODE_INFO
    nodes_examined = succ(nodes_examined);
#endif
    if (np > sc_size || *readc)			/* done or read a character? */
      break;
    if (up_operation(min_node) > 0 || np != old_new) {
      new_node(
	    cost + (*cs_replace)(sc_old_length(op),sc_new_length(np),neq),
	    idc,
	    succ(op),
	    succ(np),
	    neq,
	    REPLACE,
	    min_node);
      if (op < sc_size) {
	new_node(
	    cost + (*cs_delete)(false, idc),
	    idc - 1,
	    succ(op),
	    np,
	    0,
	    DELETE,
	    min_node);
	if (np < sc_size) {
	  q_cmpc(0,0,sc_buffer[sc_new][np-1]+1,sc_new_length(np),&neq);
	  new_node(
	      cost + (*cs_insert)(sc_new_length(np), neq, false, idc),
	      idc + 1,
	      op,
	      succ(np),
	      neq,
	      INSERT,
	      min_node);
	  }
	}
      }
    else if (op < sc_size) {
      if (up_operation(min_node) == DELETE)
	new_node(
	    cost + (*cs_delete)(true, idc),
	    idc - 1,
	    succ(op),
	    np,
	    0,
	    DELETE,
	    min_node);
      else if (up_operation(min_node) == INSERT && np < sc_size) {
	q_cmpc(0,0,sc_buffer[sc_new][np-1]+1,sc_new_length(np),&neq);
	new_node(
	    cost + (*cs_insert)(sc_new_length(np), neq, true, idc),
	    idc + 1,
	    op,
	    succ(np),
	    neq,
	    INSERT,
	    min_node);
	}
      }
    }
}

static void sc_find_a_way_2(volatile int *readc,int (*cs_replace_2)(int old,int new,int neq),int cs_delete_2)
{
  int neq;

  for ( ; ; ) {
    remove_min_cost_node();
    if (up_operation(min_node) == NONE)
      new_node(cs_delete_2, 0, 2, 1, 0, DELETE, min_node);
    else if (up_new_pos(min_node) == 1 && up_old_pos(min_node) < sc_size)
      new_node(
	    up_cost(min_node) + cs_delete_2,
	    0,
	    succ(up_old_pos(min_node)),
	    1,
	    0,
	    DELETE,
	    min_node);
    skip(&neq);
#if NODE_INFO
    nodes_examined = succ(nodes_examined);
#endif
    if (up_new_pos(min_node) > sc_size || *readc)  /* done or read char? */
      break;
    new_node(
	    up_cost(min_node) +
			(*cs_replace_2)(sc_old_length(up_old_pos(min_node)),
					   sc_new_length(up_new_pos(min_node)),
					   neq),
	    0,
	    succ(up_old_pos(min_node)),
	    succ(up_new_pos(min_node)),
	    neq,
	    REPLACE,
	    min_node);
    }
}

static void do_deletes(nodep node)
{
  nodep i, j, k, m;
  int totdel, nd, ns, lastd;

  totdel = 0;
  for (i = node; i != null; )
    if (up_operation(i) != DELETE)
      i = up_son(i);
    else {
      nd = 1;
      lastd = i;
      for (j = up_son(i); j != null; j = up_son(j))
	if (up_operation(j) == DELETE && up_new_pos(j) == up_new_pos(i)) {
	  nd++;
	  lastd = j;
	  }
	else
	  break;
      /* try and merge insert-delete pairs into a scroll down */
      for (k = up_father(i); k != null && nd > 0; )
	if (up_operation(k) == INSERT) {
	  ns = 0;
	  for (m = k; k != null && ns < nd; k = up_father(k))
	    if (up_operation(k) == INSERT && up_old_pos(k) == up_old_pos(m)) {
	      ns++;
	      up_operation(k) = INSERT2;
	      }
	    else
	      break;
	  nd = nd-ns;
	  te_scroll_down_lines(up_old_pos(m)-totdel,
			    		up_old_pos(lastd)-totdel,ns);
	  up_old_pos(i) = up_old_pos(i) + ns;	/* might have been scrolled */
	  }
	else
	  k = up_father(k);
      /* try and merge delete-insert pairs into a scroll up */
      for (k = j; k != null && nd > 0; )
	if (up_operation(k) == INSERT) {
	  ns = 0;
	  for (m = k; k != null && ns < nd; k = up_son(k))
	    if (up_operation(k) == INSERT && up_old_pos(k) == up_old_pos(m)) {
	      ns++;
	      up_operation(k) = INSERT2;
	      }
	    else
	      break;
	  nd = nd-ns;
	  te_scroll_up_lines(up_old_pos(i)-totdel,
			    		up_old_pos(m)-1-totdel,ns);
	  /* fix up intervening deletes' delete position */
	  for (m = up_father(m); m != lastd; m = up_father(m))
	    if (up_operation(m) == DELETE)
	      up_old_pos(m) = up_old_pos(m)-ns;
	  }
	else
	  k = up_son(k);
      if (nd > 0) {
	te_scroll_up_lines(up_old_pos(i)-totdel,sc_size,nd);
	totdel = totdel + nd;
	}
      up_son(up_father(i)) = j;	/* remove delete nodes from list */
      if (j != null)
	up_father(j) = up_father(i);
      i = j;
      }
}

static void do_inserts(nodep node)
{
  nodep i, j;
  int ni;

  for (i = node; i != null; )
    if (up_operation(i) != INSERT)
      i = up_son(i);
    else {
      ni = 1;
      for (j = up_son(i); j != null; j = up_son(j))
	if (up_operation(j) == INSERT && up_old_pos(j) == up_old_pos(i))
	  ni++;
	else
	  break;
      te_scroll_down_lines(up_new_pos(i), sc_size, ni);
      i = j;
      }
}

/* An optimal buffer size is now computed by Q_DO_REPLACES (Nov 3, 1986)
 * which optimizes interruption of the screen update (by characters typed
 * by the user) versus effective QIO output speed.  One could use
 * the line speed indicated by the terminal's baud rate setting to set the
 * buffer size, but QIO output speed is a better measure of "interruptability"
 * than baud rate if you are logged in through a DECSA or are SET HOST.
 *
 * The idea is to let the user interrupt the screen update frequently
 * at low baud rates, and less frequently at high baud rates, so that
 * overall it takes about 1/4 of a second for the update to be interrupted.
 * Q_DO_REPLACES computes an optimal threshold size for the output buffer
 * after which the buffer is flushed at the next end of line.
 *
 * The technique is to measure the time it takes to write a screen which
 * contains more than 200 characters (less than 200 leads to unpredictable
 * results), then divide the time by the number of characters sent.  This
 * results in a figure for characters per second which is averaged over
 * 5 updates.  The buffer size is then set as large as possible while still
 * maintaining good interruptability.
 *
 * This technique results in high buffer sizes when SET HOST, leading to low
 * interruptability, because the RT driver seems to buffer the output
 * and send it more or less all at once.  Because of the driver's buffering,
 * Q_DO_REPLACES measures a high effective baud rate since it doesn't take
 * long to send the output to the RT driver's buffer.  Therefor Q_DO_REPLACES
 * measures an incorrect communications speed in this case, but it measures
 * the "interruptability" of the communications line correctly!  The reason is
 * that the routine measures the time for QIO's to complete, not line speed;
 * if all the QIOs complete quickly, there is no way to interrupt them anyway,
 * so the buffer size should be set high. */

static int q_do_replaces(nodep node, volatile int *readc)
{
  nodep i, j, k;
  int status, n, np, outlen;
  declare char
	tmp_buffer [SCREEN_SIZE] [SCREEN_WIDTH + 1];
  char tmp_length[SCREEN_SIZE];
# include "terminal.cmn"
# if VMS
  float seconds;
  static float characters_per_second = 0.0;
  static int setting_buffer_size = true;
  static int setting_buffer_size_count = 0;
  int nch;

  if (setting_buffer_size) {
    nch = 0;
    seconds = secnds(0.0);
    }
# endif
  status = true;
  for (i = node; i != null; i = up_son(i)) {
    if (ti_count >= up_buffer_size) {
# if VAX
      nch = nch + ti_count;
# endif
      ti_flush();
      if (*readc) {
	for (k = i; k != null; k = up_son(k)) {
	  if (up_operation(k) != REPLACE) {
	    tmp_length[up_new_pos(k)-1] = 0;
	    tmp_buffer[up_new_pos(k)-1][0] = false;
	    }
	  else {
	    tmp_length[up_new_pos(k)-1] = sc_old_length(up_old_pos(k));
	    movc(sc_buffer[sc_old][up_old_pos(k)-1],
		      tmp_buffer[up_new_pos(k)-1],
		      tmp_length[up_new_pos(k)-1]+1);
	    }
	  sc_modified(up_new_pos(k)) = true;
	  }
	for (j = 1; j <= sc_size; j++)
	  if (sc_modified(j))
	    if (i == null)
	      goto L10;
	    else if (j == up_new_pos(i)) {
	      movc(tmp_buffer[j-1],sc_buffer[sc_old][j-1],
			      tmp_length[j-1]+1);
	      sc_old_length(j) = tmp_length[j-1];
	      i = up_son(i);
	      }
	    else {
L10:	      movc(sc_buffer[sc_new][j-1],sc_buffer[sc_old][j-1],
			      sc_new_length(j)+1);
	      sc_old_length(j) = sc_new_length(j);
	      sc_modified(j) = false;
	      }
	status = false;
	break;
	}
      }
    n = up_neq(i);
    np = up_new_pos(i);
    outlen = sc_new_length(np) - n;
    if (outlen > 0 || up_operation(i) == REPLACE) {
      te_pos(np, n + 1);
      if (outlen > 0) {
	if (sc_reverse_video(np,sc_new))
	  te_reverse_video();
	ti_outch(sc_buffer[sc_new][np-1]+n+1,outlen);
	te_pos_x = te_pos_x + outlen;
	if (sc_reverse_video(np,sc_new))
	  te_reverse_video_off();
	}
      if (up_operation(i) == REPLACE)
	te_erase_to_end_of_line(sc_old_length(up_old_pos(i)),
			  max(n, sc_new_length(np)));
      }
    }
#if VMS
  if (setting_buffer_size) {
    if (nch > 200) {
/* flush the buffer one last time, but DON'T add the number of characters
 * in it to NCH; empirically, this results in more accurate results;
 * each flush seems to have to wait for the one before it to complete,
 * so we are only waiting for characters output BEFORE this flush. */
      ti_flush();
      seconds = secnds(seconds);
      if (seconds > 0.0) {
	characters_per_second = characters_per_second + (nch/seconds);
	if (characters_per_second <= 300)
	  /* make life easier for probable 1200 baud users */
	  up_buffer_size = 0;
	setting_buffer_size_count = setting_buffer_size_count + 1;
	if (setting_buffer_size_count >= 5) {
	  setting_buffer_size = false;
	  characters_per_second =
	    characters_per_second/setting_buffer_size_count;
	  if (characters_per_second <= 200)
	    up_buffer_size = 0;
	  else if (characters_per_second <= 300)
	    up_buffer_size = 50;
	  else if (characters_per_second <= 600)
	    up_buffer_size = 100;
	  else if (characters_per_second <= 1200)
	    up_buffer_size = 200;
	  else
	    up_buffer_size = 400;
	  }
	}
      }
    }
# endif
  return status;
}

static int q_update_screen(volatile int *readc)
{
  register nodep i;

  up_son(min_node) = null;
  for (i = min_node; up_operation(i) != NONE; i = up_father(i)) {
    up_son(up_father(i)) = i;
    up_old_pos(i) = up_old_pos(up_father(i));
    up_new_pos(i) = up_new_pos(up_father(i));
    }
#if DEBUG
  j = i;
  write(7,(/" *** new page ***"));
  for (i = up_son(i); i != null; i = up_son(i)) {
    switch (up_operation(i)) {
      case REPLACE:
	write(7,(' Replace old line 'i2' with new line 'i2'; cost = 'i4)) 
	  up_old_pos(i),up_new_pos(i),up_cost(i);
	break;
      case DELETE:
	write(7,(' Delete old line 'i2'; new line is 'i2'; cost = 'i4)) 
	  up_old_pos(i),up_new_pos(i),up_cost(i);
	break;
      case INSERT:
	write(7,(' Insert new line 'i2' before old line 'i2'; cost = 'i4)) 
	  up_new_pos(i),up_old_pos(i),up_cost(i);
	break;
      case CLEAR:
	write(7,(' Clear screen; cost = 'i4)) up_cost(i);
	break;
      }
    }
  i = j;
#endif
#if NODE_INFO
#define writeint write(9,(" $&:",5i8)) $&
  writeint(nodes_generated);
  writeint(nodes_examined);
  writeint(nodes_inserted);
  writeint(nodes_replaced);
  writeint(nodes_inserted + nodes_replaced);
#undef(writeint)
#endif
  if (up_son(i) != null)
    if (up_operation(up_son(i)) == CLEAR) {
      if (sc_redraw)
	te_init_sequence();
      te_clear();
      sc_redraw = false;
      return q_do_replaces(up_son(up_son(i)), readc);
      }
    else {
      do_deletes(up_son(i));
      do_inserts(up_son(i));
      return q_do_replaces(up_son(i), readc);
      }
  return true;
}

void sc_update(volatile int *readc)
{
# include "terminal.cmn"
  static const char bell[] = "\7";
  nodep op;
  int modlin, i;
#if TIMER
  long int handle = 0;
#endif

  if (*readc)						/* type-ahead? */
    return;
#if NODE_INFO
  nodes_generated = 0;
  nodes_examined = 0;
  nodes_inserted = 0;
  nodes_replaced = 0;
#endif
#if TIMER
  lib$init_timer(&handle);
#endif
  sc_fill_new();
  for (modlin = 1; modlin <= sc_size; modlin++)
    if (sc_modified(modlin))
      break;
  if (modlin <= sc_size || sc_redraw) {
    fillc(up_stat_a, (SCREEN_SIZE+1)*(SCREEN_SIZE+1), UNTOUCHED);
    sc_old_length(sc_size+1) = 0;
    sc_reverse_video(sc_size+1, sc_old) = false;
    open = null;
    new_node(0, 0, modlin, modlin, 0, NONE, null);
    op = open;
    if (sc_redraw)
      remove_min_cost_node();		/* only generate nodes after clear */
    switch (te_type) {
      case ADM3A:
	new_node(cs_adm3a_clear(), 0, sc_size+1, 1, 0, CLEAR, op);
	sc_find_a_way_2(readc, cs_adm3a_replace, cs_adm3a_delete());
	break;
      case ADM5:
	new_node(cs_adm3a_clear(), 0, sc_size+1, 1, 0, CLEAR, op);
	sc_find_a_way_2(readc, cs_adm5_replace, cs_adm3a_delete());
	break;
      case VT100:
	new_node(cs_vt100_clear(), 0, sc_size+1, 1, 0, CLEAR, op);
	sc_find_a_way(readc, cs_vt100_replace, cs_vt100_delete,
    							cs_vt100_insert);
	break;
      case VT52:
	new_node(cs_vt52_clear(), 0, sc_size+1, 1, 0, CLEAR, op);
	sc_find_a_way_2(readc, cs_vt52_replace, cs_adm3a_delete());
	break;
      }
    if (*readc)
      return;
    if (! q_update_screen(readc))
      return;
    for (i = modlin; i <= sc_size; i++)
      if (sc_modified(i)) {
	movc(sc_buffer[sc_new][i-1], sc_buffer[sc_old][i-1],
      			sc_new_length(i)+1);
	sc_old_length(i) = sc_new_length(i);
	sc_modified(i) = false;
	}
    if (sc_new_length(sc_size) != 0) {		/* clear messages */
      sc_modified(sc_size) = true;
      sc_new_length(sc_size) = 0;
      }
    }
  te_pos(sc_cursor_y, sc_cursor_x);
  if (sc_error_occurred) {
    ti_outch(bell, 1);
    sc_error_occurred = false;
    }
  ti_flush();
#if TIMER
  te_pos(22, 30);
  ti_flush();
  lib$show_timer(&handle, &2);
  te_pos(sc_cursor_y, sc_cursor_x);
  ti_flush();
#endif
}

void up_display_buffer_size(void)
{
  ms_report_number2("Output buffer size threshold is ",
  	up_buffer_size, " character.", " characters.");
}
$eod
$ create UPDATE.CMN
$deck
#define NUMBER_NODES (SCREEN_SIZE+1)*(SCREEN_SIZE+1)
#define nodep short int

static nodep
	open, min_node,
	up_father_a[NUMBER_NODES],
	up_open_a[NUMBER_NODES],
	up_prev_a[NUMBER_NODES];

static short int
	up_cost_a[NUMBER_NODES],
	up_neq_a[NUMBER_NODES];

static char
	up_old_pos_a[NUMBER_NODES],
	up_new_pos_a[NUMBER_NODES],
	up_operation_a[NUMBER_NODES],
	up_insert_delete_count_a[NUMBER_NODES],
	up_stat_a[NUMBER_NODES];

#define up_father(x) up_father_a[x]
#define up_open(x) up_open_a[x]
#define up_prev(x) up_prev_a[x]
#define up_cost(x) up_cost_a[x]
#define up_old_pos(x) up_old_pos_a[x]
#define up_new_pos(x) up_new_pos_a[x]
#define up_neq(x) up_neq_a[x]
#define up_operation(x) up_operation_a[x]
#define up_insert_delete_count(x) up_insert_delete_count_a[x]
#define up_stat(x) up_stat_a[x]
#define up_son(x) up_prev(x)

static int
	up_buffer_size = 30;	/* start with low buffer size threshold */
$eod
$ create WINDOW.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986,1987 William P. Wood, Jr. */

#include "symbols.h"
#include "screen.cmn"
#include "memory.cmn"
#include "session.cmn"

int q_split_current_window(void)
{
  register windowp wi;

  if (se_current_window == null) {
    se_current_window = wi_new(sc_size - 2);
    se_windows = se_current_window;
    }
  else if (wi_size(se_current_window) < 3)
    return false;
  else {
    wi_modified(se_current_window) = 1;
    wi = wi_copy(se_current_window);
    wi_size(wi) = (wi_size(se_current_window)-1)/2;
    wi_size(se_current_window) = wi_size(se_current_window)/2;
    wi_min_size(wi) = 1;
    wi_next(wi) = wi_next(se_current_window);
    wi_next(se_current_window) = wi;
    wi_prev(wi) = se_current_window;
    if (wi_next(wi) != null)
      wi_prev(wi_next(wi)) = wi;
    se_current_window = wi;
    }
  return true;
}

/* make wi a window on bu, and remove wi as a window on wi_buffer(wi) */
void wi_switch_to_buffer(windowp wi, bufferp bu)
{
  register windowp wi2, wi3, prev;
  windowp witmp, wiparent, wilast;
  bufferp bu2;

  for (wi2 = wi_parent(wi); wi2 != null; ) {
    if (wi_buffer(wi2) != null) {
      bu_dot(wi_buffer(wi2)) = wi_dot(wi2);/* save latest position in buffer */
      bu_bow(wi_buffer(wi2)) = wi_bow(wi2);
      if (wi2 == wi)
	bu_current(wi_buffer(wi2)) = 1;
      else
	bu_current(wi_buffer(wi2)) = 0;
      prev = null;			 /* remove window from buffer's list */
      bu_map_windows(wi_buffer(wi2), wi3)
	if (wi3 == wi2) {
	  if (prev == null)
	    bu_windows(wi_buffer(wi2)) = wi_next_bu_window(wi2);
	  else
	    wi_next_bu_window(prev) = wi_next_bu_window(wi2);
	  break;
	  }
	else
	  prev = wi3;
      }
    witmp = wi_sub_windows(wi2);
    if (wi2 != wi || bu == null)		/* deallocate extra windows */
      me_deallocate(wi2);
    wi2 = witmp;
    }
  if (bu != null) {
    wilast = wiparent = null;
    bu_map_sub_buffers(bu, bu2) {
      if (bu_current(bu2) == 1)
	wi2 = wi;
      else
	wi2 = wi_new(wi_size(wi));
      if (wiparent == null)
	wiparent = wi2;
      else
	wi_sub_windows(wilast) = wi2;
      wilast = wi2;
      wi_parent(wi2) = wiparent;
      wi_buffer(wi2) = bu2;
      wi_dot(wi2) = bu_dot(bu2);
      wi_set_bow(wi2, bu_bow(bu2));
      wi_modified(wi2) = 1;
      wi_mode_line(wi2) = bu_name(bu2);
      wi_next_bu_window(wi2) = bu_windows(bu2);
      bu_windows(bu2) = wi2;
      }
    }
}

int q_pop_up_window(void)
{
  while (! q_split_current_window())
    if (! q_enlarge_window())
      return false;
  return true;
}

windowp wi_new(int size)
{
  register windowp wi;

  wi = me_allocate(wi_sizeof);
  wi_parent(wi) = wi;
  wi_buffer(wi) = null;
  wi_dot(wi) = 1;
  wi_bow(wi) = 1;
  wi_size(wi) = size;
  wi_sub_size(wi) = size;
  wi_min_size(wi) = 1;
  wi_modified(wi) = 1;
  wi_id(wi) = 0;
  wi_mode_line(wi) = null;
  wi_next(wi) = null;
  wi_prev(wi) = null;
  wi_sub_windows(wi) = null;
  wi_next_bu_window(wi) = null;
  return wi;
}

int q_enlarge_window(void)
{
  register windowp wi, wi2;
# include "terminal.cmn"

  wi_map(wi_next(se_current_window),wi)	/* look down for a window to shrink */
    if (wi_size(wi) > wi_min_size(wi))	/* found one... */
      wi_map(se_current_window,wi2) {	/* mark intervening windows as modified */
	wi_modified(wi2) = 1;
	if (wi2 == wi)
	  goto L10;
	}
  wi_map_back(wi_prev(se_current_window),wi) /*look up for a window to shrink */
    if (wi_size(wi) > wi_min_size(wi))	   /* found one... */
      wi_map_back(se_current_window,wi2) { /* mark intervening windows modified */
	wi_modified(wi2) = 1;
	if (wi2 == wi)
	  goto L10;
	}
/* if screen is not at full length, increase screen size by one...
 *	(only if this is the only page present) */
  if (sc_size < te_size_y && pa_next(se_pages) == null) {
    sc_fill_line(sc_size+1,sc_buffer(1,sc_size,sc_new),
    	sc_new_length(sc_size));
    sc_reverse_video(sc_size+1,sc_new) = false;
    sc_size = sc_size + 1;
    wi_size(se_current_window) = wi_size(se_current_window) + 1;
    wi_map(se_current_window,wi)     /* mark intervening windows as modified */
      wi_modified(wi) = 1;
    redraw();
    return true;
    }
  return false;
L10:
  wi_size(se_current_window) = wi_size(se_current_window) + 1;
  wi_size(wi) = wi_size(wi) - 1;
  return true;
}

int q_shrink_window(void)
{
  register windowp wi;

  wi = se_current_window;
  if (wi_size(wi) <= 1)
    return false;
  else if (wi_next(wi) != null) {
    wi_size(wi_next(wi)) = wi_size(wi_next(wi)) + 1;
    wi_modified(wi_next(wi)) = 1;
    }
  else if (wi_prev(wi) != null) {
    wi_size(wi_prev(wi)) = wi_size(wi_prev(wi)) + 1;
    wi_modified(wi_prev(wi)) = 1;
    }
  else if (pa_next(se_pages) != null)
    return false;
  else {
    sc_fill_line(sc_size-1,sc_buffer(1,sc_size,sc_new),
    	sc_new_length(sc_size));
    sc_reverse_video(sc_size-1,sc_new) = false;
    sc_size = sc_size-1;
    redraw();		/* don't want to leave junk on the screen */
    }
  wi_size(wi) = wi_size(wi) - 1;
  wi_modified(wi) = 1;
  return true;
}

void next_window(void)
{
  se_current_window = wi_next(se_current_window);
  if (se_current_window == null)
    se_current_window = se_windows;
}

void previous_window(void)
{
  register windowp wi;

  se_current_window = wi_prev(se_current_window);
  if (se_current_window == null)
    wi_map(se_windows,wi)
      if (wi_next(wi) == null)
	se_current_window = wi;
}

int q_delete_window(void)
{
  register windowp wi;

  wi = se_current_window;
  if (wi_next(wi) == null && wi_prev(wi) == null)
    return false;
  if (wi_prev(wi) == null) {
    se_current_window = wi_next(wi);
    se_windows = wi_next(wi);
    }
  else if (wi_next(wi) == null)
    se_current_window = wi_prev(wi);
  else if (wi_parent_buffer(wi_prev(wi)) != wi_parent_buffer(wi) &&
	    wi_parent_buffer(wi_next(wi)) == wi_parent_buffer(wi))
    se_current_window = wi_next(wi);
  else
    se_current_window = wi_prev(wi);
  if (wi_prev(wi) != null)
    wi_next(wi_prev(wi)) = wi_next(wi);
  if (wi_next(wi) != null)
    wi_prev(wi_next(wi)) = wi_prev(wi);
  wi_size(se_current_window) = wi_size(se_current_window) + wi_size(wi) + 1;
  wi_modified(se_current_window) = 1;
  wi_switch_to_buffer(wi, null);
  return true;
}

void delete_other_windows(void)
{
  register windowp wi;

  wi = se_current_window;
  for (se_current_window = se_windows; se_current_window != null; )
    if (se_current_window == wi)
      se_current_window = wi_next(se_current_window);
    else
      q_delete_window();
  se_current_window = wi;
}

void beginning_of_window(void)
{
  wi_dot(se_current_window) = wi_bow(se_current_window);
}

void wi_fill(void)
{
  textind t;

  t = wi_dot(se_current_window);
  wi_dot(se_current_window) = max(wi_dot(se_current_window),
					bu_size(se_current_buffer));
  while (q_dot_is_visible())
    if (! q_shrink_window())
      break;
  while (! q_dot_is_visible())
    if (! q_enlarge_window())
      break;
  wi_dot(se_current_window) = t;
  if (! q_dot_is_visible())
    q_enlarge_window();
}

void wi_display(register windowp w)
{
  register windowp wi, w2;

  wi_map(w, w2)
    wi_map_sub_windows(w2, wi)
      printf(
  " Window at: %d\n   size = %d\n   buffer = %d\n   dot = %d\n   bow = %d\n",
	    wi,wi_size(wi),wi_buffer(wi),wi_dot(wi),wi_bow(wi));
}

void wi_equalize(void)
{
  register windowp wi;
  int nw, ss;

  nw = 0;
  wi_map(se_windows,wi)
    nw = nw+1;
  ss = sc_size - 1;
  wi_map (se_windows,wi) {
    wi_size(wi) = ss/nw + min(1, mod(ss, nw)) - 1;
    wi_modified(wi) = 1;
    ss = ss - (wi_size(wi) + 1);
    nw = nw-1;
    }
}

windowp wi_copy(windowp wi)
{
  register windowp wi2, wic, wiparent;
  windowp wilast, wicopied;

  wilast = wiparent = null;
  wi_map_sub_windows(wi, wi2) {
    wic = wi_new(wi_size(wi2));
    if (wi2 == wi)
      wicopied = wic;
    movc(&me_mem(wi2), &me_mem(wic), wi_sizeof*CHARS_PER_INT);
    if (wiparent == null)
      wiparent = wic;
    else
      wi_sub_windows(wilast) = wic;
    wilast = wic;
    wi_parent(wic) = wiparent;
    wi_sub_windows(wic) = null;
    wi_next_bu_window(wic) = bu_windows(wi_buffer(wic));
    bu_windows(wi_buffer(wic)) = wic;
    }
  return wicopied;
}

void wi_status(register windowp wi)
{
  register bufferp bu;
  char num[15];
# include <time.h>
  time_t bintim;
  char date[26];

  bu = wi_buffer(wi);
  if (mod(bu_modified(bu), 2) != 1)
    ms_message("Mod: N  Size: ");
  else
    ms_message("Mod: Y  Size: ");
  ho_itoc(bu_size(bu), num, 15);
  ms_add_to_message(num);
  ms_add_to_message("  Pos: ");
  ho_itoc(wi_dot(wi), num, 15);
  ms_add_to_message(num);
  ms_add_to_message(" (");
  if (bu_size(bu) == 0)
    ms_add_to_message("0");
  else {
    ho_itoc((100*(wi_dot(wi)-1))/bu_size(bu), num, 15);
    ms_add_to_message(num);
    }
  ms_add_to_message("%)  Col: ");
  ho_itoc(current_column(), num, 15);
  ms_add_to_message(num);
  ms_add_to_message("  Page: ");
  ho_itoc(pa_number(se_current_page), num, 15);
  ms_add_to_message(num);
  ms_add_to_message("  ");
  bintim = time(NULL);
  ho_scopy(ctime(&bintim), 1, date, 1);
  date[24] = EOS;
  ms_add_to_message(date);
}

void wi_ready(windowp wi)
{
  register windowp wi2;

  wi_map_sub_windows(wi, wi2) {
    wi_dot(wi2) = min(wi_dot(wi2), bu_size(wi_buffer(wi2)) + 1);
    wi_set_bow(wi2, find_bol(wi_buffer(wi2), wi_bow(wi2)));
    }
}
$eod
$ create WINDOW.H
$deck
/*
typedef struct window {
	buffer		*wi_buffer;
	window		*wi_next;
	window		*wi_prev;
	window		*wi_parent;
	window		*wi_sub_windows;
	window		*wi_next_bu_window;
	string		*wi_mode_line;
	textind		wi_dot;
	textind		wi_bow;
	int		wi_size;
	int		wi_sub_size;
	int		wi_min_size;
	int		wi_modified;
	int		wi_id;
	} window;
 */

#define wi_buffer(wi) me_mem(wi)
#define wi_dot(wi) me_mem(1+wi)
#define wi_bow(wi) me_mem(2+wi)
#define wi_size(wi) me_mem(3+wi)
#define wi_sub_size(wi) me_mem(4+wi)
#define wi_min_size(wi) me_mem(5+wi)
#define wi_modified(wi) me_mem(6+wi)
#define wi_id(wi) me_mem(7+wi)
#define wi_mode_line(wi) me_mem(8+wi)
#define wi_next(wi) me_mem(9+wi)
#define wi_prev(wi) me_mem(10+wi)
#define wi_parent(wi) me_mem(11+wi)
#define wi_sub_windows(wi) me_mem(12+wi)
#define wi_next_bu_window(wi) me_mem(13+wi)
#define wi_sizeof 14

#define wi_parent_buffer(wi) bu_parent(wi_buffer(wi))
#define wi_map(wi1, wi2) for (wi2 = wi1; wi2 != null; wi2 = wi_next(wi2))
#define wi_map_back(wi1, wi2) for (wi2 = wi1; wi2 != null; wi2 = wi_prev(wi2))
#define wi_set_bow(wi, bow) {wi_bow(wi) = bow; wi_modified(wi) = 1;}
#define wi_map_sub_windows(wi1, wi2) \
	  for (wi2 = wi_parent(wi1); wi2 != null; wi2 = wi_sub_windows(wi2))
$eod
$ create WORD.C
$deck
/*	Zilch Screen Editor,
 *	Copyright (c) 1982,1986 William P. Wood, Jr. */

#include "symbols.h"
#include "session.cmn"
#include "memory.cmn"

/* this subroutine relies on the extra NEWLINES hidden at the end of each buffer */
void next_word(void)
{
  textind end;
  int class;

  end = bu_size(se_current_buffer) + 1;
  wo_skip_non_word(end,1,se_cross_lines,0);
  class = se_word_definition(
	tx_text(tx_address(se_current_buffer, wi_dot(se_current_window))), 0);
  wo_skip_word(end,1,class);
}

/* this subroutine relies on the extra NEWLINES hidden at the end of each buffer */
void previous_word(void)
{
  int class;

  if (wi_dot(se_current_window) > 1) {
    previous_character();
    wo_skip_non_word(0,-1,se_cross_lines,0);
    class = se_word_definition(
	tx_text(tx_address(se_current_buffer, wi_dot(se_current_window))), 0);
    wo_skip_word(0,-1,class);
    next_character();
    }
}

/* this subroutine relies on the extra NEWLINES hidden at the end of each buffer */
void wo_skip_non_word(int end, int inc, int cross, int class)
{
  register char c;
  register textind tx;
  register bufferp bu;

  bu = se_current_buffer;
  for (tx = wi_dot(se_current_window); tx != end; tx = tx+inc) {
    c = tx_text(tx_address(bu, tx));
    if (se_word_definition(c, class) != 0)
      break;
    else if (c == NEWLINE && ! cross)
      break;
    }
  wi_dot(se_current_window) = tx;
}

/* this subroutine relies on the extra NEWLINES hidden at the end of each buffer */
void wo_skip_word(int end, int inc, int class)
{
  register textind tx;
  register bufferp bu;

  bu = se_current_buffer;
  for (tx = wi_dot(se_current_window); tx != end; tx = tx+inc)
    if (se_word_definition(tx_text(tx_address(bu, tx)), class) == 0)
      break;
  wi_dot(se_current_window) = tx;
}
$eod
$ create BUILD.COM
$deck
$ save_verify := 'f$verify("NO")'
$ on control_y then goto done
$ on error then goto done
$	comp*ile	:= $dpc_exe:compile com
$ assign/nolog 'f$logical("sys$disk")''f$directory()' z
$ if p1 .eqs. "" then p1 = "zbind"
$ if p3 .eqs. "" then p3 = "/notrace"
$ set def [-]
$ take_files = "''take_files'"
$ if take_files .nes. "" then -
	compile/symbols/nolist/nocheck/nodebug 'take_files'
$ compile/nolist/disable=(debug,trace)/libr=zilch -
		movc,-
		fillc,-
		cmpc,-
		findnew,-
		gpopen
$ compile/symbols/nolist/nocheck/nodebug/libr=zilch -
		macro,-
		bind/inc=bind.cmn,-
		fileio,-
		text,-
		hollerith,-
		buffer,-
		window,-
		page,-
		message,-
		indent,-
		mark,-
		search,-
		mappings,-
		dcl,-
		help,-
		spfiles,-
		pushb
$ compile/symbols/nolist/nocheck/nodebug/libr=zilch -
		[]screen/nocheck/nodebug,-
		session,-
		alloc,-
		string,-
		update/nocheck/nodebug,-
		cost,-
		tecon/noch,-
		iobuffer,-
		[]tty,-
		edfunc,-
		word,-
		region,-
		insert,-
		command,-
		hyper,-
		checkp
$ assign/nolog icr$library:icr i$
$ comp/sym/nolis/noch/nodeb/link=(/nomap/nodeb'p3'/exe=z:zilch-
		'take_files'zilch/lib,zilch/opt,'p2'i$/lib) -
	edit,z:'p1'
$done:
$ set default z:
$ if save_verify then set verify
$eod
$ create MAKEBIND.COM
$deck
$ on error then goto done
$ on control_y then goto done
$ set def [-]
$ compile/symbols/nolist -
	/link=(/nomap/exe=[.wood]makebind -
		hollerith,icr$library:icr/lib) -
	[.wood]makebind/nocheck/nodebug,bind/nocheck/nodebug/inc=bind.cmn
$done:
$ set def [.wood]
$eod
$ create MAKEBIND.RAT
$deck
# Zilch Screen Editor, Copyright (c) 1982,1983,1984,1986 William P. Wood, Jr.

define(header,implicit integer (a-p,r-z); implicit logical (q)
  common /err/ error
    logical error
  include "bind.cmn")

define(BI_MEM_SIZE,20000)

_undef(true)
_undef(false)
define(trim,$1(1:len_trim($1)))

  header
  logical parse, code, restart
  character*129 cline, file, fncfile, dat, dat2
  character*80 funcs(500), curfunc
  integer funcn(500)

  code = .false.
  error = .false.
  call lib$get_foreign(cline)
  if (! parse(cline, file))
    call exit(16%10000002)
  if (file == '/CODE') {
    code = .true.
    if (! parse(cline, file))
      call exit(16%10000002)
    open(unit=4, name=file//'.rat', type='new', carriagecontrol='list')
    open(unit=7, type='scratch', carriagecontrol='list')
    }
  inlun = 11
  open(unit=inlun, name=file//'.bnd', type='old', readonly, err=10)
  if (code)
    open(unit=3, name=file//'.fnc', type='new', carriagecontrol='list')
  else {
    if (! parse(cline, fncfile))
      call exit(16%10000002)
    open(unit=3, name=fncfile, type='old', carriagecontrol='list', readonly)
    }
  do i = 0, NUM_MODES-1
    bi_modes(i) = null
  do i = 0, NUM_MACROS-1
    bi_macros(i) = null
  bi_free = 1
  bi_max = BI_MEM_SIZE
  bi_modes(CONTROL_MODE) = bi_allocate(128)
  bi_mem(bi_modes(CONTROL_MODE)) = - 1		# function for QIO error
  bi_mem(bi_modes(CONTROL_MODE) + 8%31) = -3	# function for ^Y interrupt
  call bi_use_keymap(CONTROL_MODE)
  bi_keypad = KEYPAD_NUMERIC
  do i = 0, 127
    bi_alternate_escape_followers(i) = .false.
  bi_alternate_escape = EOS
  lastfunc = 0
  repeat {
  restart = .false.
  funcnum = 0
  funcoffset = lastfunc
  macro = -1					# not defining a macro
  codelun = 4
  if (code) {
    rewind 7
    write(7, ('       ), cmd'))
    write(7, ('      unbound_key_sequence'))
    write(7, ('      end_function_definition'))
    write(7, ('2001  qio_error'))
    write(7, ('      end_function_definition'))
    write(7, ('2002  qio_error_in_insert_mode'))
    write(7, ('      end_function_definition'))
    write(7, ('2003  control_y_interrupt'))
    }
  repeat {
    read(inlun,(q,a),end=1) nch,dat2
    if (.false.) {
1     close(unit=inlun)
      inlun = inlun - 1
      if (inlun == 10)
	goto 5
      next
      }
    if (nch == 0)
      ;
    else if (dat2(1:1) == ' ' | dat2(1:1) == char(8%11)) {
      if (code & funcnum > 0) {
	write(7, ('      end_function_definition'))
	write(7, (i4,t51,'# ',a)) funcnum + 1000,
				  trim(curfunc)
	write(7, (a)) dat2(1:nch)
	funcnum = 0
	}
      else if (macro >= 0) {			# defining a macro
	if (bi_macros(macro) == null) {
	  bi_macros(macro) = bi_free
	  mlen = 0
	  }
	else
	  mlen = bi_mem(bi_macros(macro))
	call esc(dat2(1:nch), dat, ilen, funcend, low, high, .false., .false.)
	bi_free = bi_macros(macro) + 1 + (mlen + ilen + 1)/2
	if (bi_free > bi_max + 1)
	  stop "Macro overflow!"
	call copy(%ref(dat), ilen, bi_mem(bi_macros(macro) + 1), mlen)
	bi_mem(bi_macros(macro)) = mlen
	}
      else if (code)
	write(codelun, (a)) dat2(1:nch)
      }
    else {
      call esc(dat2(1:nch), dat, ilen, funcend, low, high, .true., .true.)
      if (funcend == 0)
	next
      funcnum = 0
      macro = -1				# not defining a macro
      if (dat(1:5) == 'MODE_' & funcend > 5) {
	decode(funcend - 5, (i<funcend - 5>), dat(6:funcend), err=6) mode
	if (mode < 0 | mode >= NUM_MODES) {
6	  write(6,(' Illegal keypad mode: ',a)) dat(1:funcend)
	  error = .true.
	  }
	else
	  funcnum = mode + 4000
	}
      else if (dat(1:12) == 'UDK_REPLACE_' & funcend > 12) {
	decode(funcend - 12, (i<funcend - 12>), dat(13:funcend), err=601) unum
	if (unum < 0 | unum >= MAX_MACROS) {
601	  write(6,(' Illegal macro number: ',a)) dat(1:funcend)
	  error = .true.
	  }
	else
	  funcnum = 3000 + unum
	}
      else if (dat(1:4) == 'UDK_' & funcend > 4) {
	decode(funcend - 4, (i<funcend - 4>), dat(5:funcend), err=603) unum
	if (unum < 0 | unum >= MAX_MACROS) {
603	  write(6,(' Illegal macro number: ',a)) dat(1:funcend)
	  error = .true.
	  }
	else
	  funcnum = 2000 + unum
	}
      else if (dat(1:6) == 'MACRO_' & funcend > 6) {
	if (dat(1:funcend) == 'MACRO_X') {
	  macro = -1
	  do i = NUM_MACROS - 1, 0, - 1
	    if (bi_macros(i) == NULL) {
	      macro = i
	      break
	      }
	  if (macro == -1) {
	    write(6,(' Too many macros!'))
	    error = .true.
	    }
	  }
	else
	  decode(funcend - 6, (i<funcend - 6>), dat(7:funcend), err=7) macro
	if (macro < 0 | macro >= NUM_MACROS) {
7	  write(6,(' Illegal macro: ',a)) dat(1:funcend)
	  error = .true.
	  }
	else {
	  funcnum = macro + 1000
	  if (bi_macros(macro) != null)		# already defined?
	    macro = -1				# not defining a macro
	  }
	}
      else if (code & dat(1:1) != '%') {
	for (funcnum = 1; funcnum <= lastfunc; funcnum = funcnum + 1)
	  if (funcs(funcnum) == dat(1:funcend))
	    break
	if (funcnum > lastfunc) {
	  lastfunc = funcnum
	  if (lastfunc > 500)
	    stop "too many functions"
	  funcs(lastfunc) = dat(1:funcend)
	  funcn(lastfunc) = lastfunc - funcoffset
	  write(3,(a)) dat(1:funcend)
	  if (codelun == 4) {
# 2001 is for a QIO error while not in INSERT mode
# 2002 is for a QIO error while in INSERT mode
# 2003 is for a CONTROL-Y interrupt
	    write(4, ('      goto (2001, 2002, 2003 _'))
	    codelun = 7
	    }
	  write(4, ('       ,', i5, ' _')) funcn(lastfunc) + 1000
	  }
	curfunc = funcs(funcnum)
	funcnum = funcn(funcnum)
	}
      dat(ilen+1:ilen+1) = char(0)
      if (funcend == ilen & dat(1:1) != '%')	# function is not bound
	;
      else if (high != 0) {			# bind a range of characters
	while (ichar(dat(low:low)) <= ichar(dat(high:high))) {
	  call bindit(dat(1:funcend), dat(funcend+1:low)// _
		      dat(high+1:ilen+1), funcnum, inlun, restart)
	  dat(low:low) = char(ichar(dat(low:low)) + 1)
	  }
	}
      else
	call bindit(dat(1:funcend), dat(funcend+1:ilen+1),
				  funcnum, inlun, restart)
      if (funcnum >= 1000)			# mode or macro function
	funcnum = 0
      }
    } until (restart)
5
  if (code) {
    rewind 7
    repeat {
      read(7, (q,a), end=8) nch, dat2
      write(4, (a)) dat2(1:nch)
      }
8     continue
    }
  if (restart & code)
    write(3,(a)) ' '
  } until (! restart)
  if (error)
    call exit(16%10000002)
  bl = index(file,']')
  dl = index(file(bl+1:), '.')
  if (dl != 0)
    file(bl + dl:) = ' '
  open(unit=2, name=file//'.bor', type='new', carriagecontrol='list')
  inquire(unit=2,name=file)
  call write_block_data
  call exit(1)
10
  write(6,(' Can''t open ',a)) trim(file)
  call exit(16%10000002)
  end

  subroutine esc(dat, outdat, ilen, funcend, low, high, dorange, upcase)
  implicit integer (a - z)
  character*(*) dat, outdat
  logical dorange, upcase
  character*1 c

  nch = len(dat)
  ilen = 0
  funcend = 0
  low = 0
  high = 0
  for (i1 = 1; i1 <= nch; i1 = i1 + 1) {
    switch (ichar(dat(i1:i1))) {
      case '-':
	if (dorange) {
	  low = ilen
	  high = ilen + 2
	  ilen = ilen+1
	  outdat(ilen:ilen) = char(0)
	  }
	else {
	  ilen = ilen+1
	  outdat(ilen:ilen) = dat(i1:i1)
	  if (upcase)
	    call str$upcase(outdat(ilen:ilen), outdat(ilen:ilen))
	  }
      case ' ','@t':
	if (funcend == 0)
	  funcend = ilen
      case '#':
	break
      case '^':
	i1 = i1 + 1
	ilen = ilen + 1
	c = dat(i1:i1)
	call str$upcase(c, c)
	outdat(ilen:ilen) = char(ichar(c) - 8%100)
      case '\':
	i1 = i1 + 1
	switch (ichar(dat(i1:i1))) {
	  case '0'-'9':
	    n = 0
	    repeat {
	      n = n*8 + (index('0123456789',dat(i1:i1)) - 1)
	      i1 = i1 + 1
	      } until (index('0123456789', dat(i1:i1)) == 0 | i1 > nch)
	    i1 = i1 - 1
	    ilen = ilen+1
	    outdat(ilen:ilen) = char(n)
	  default:
	    ilen = ilen+1
	    outdat(ilen:ilen) = dat(i1:i1)
	  }
	c = outdat(ilen:ilen)
	if ((c >= 'A' & c <= 'Z') | (c >= 'a' & c <= 'z'))
	  outdat(ilen:ilen) = char(- ichar(c))
      default:
	ilen = ilen+1
	outdat(ilen:ilen) = dat(i1:i1)
	if (upcase)
	  call str$upcase(outdat(ilen:ilen), outdat(ilen:ilen))
      }
    }
  if (funcend == 0)
    funcend = ilen
  return
  end

  subroutine bindit(func, keystrokes, funcnum, inlun, restart)
  header
  character*(*) func, keystrokes
  character*80 funcs(500)
  integer funcn(500)
  byte c
  logical first, restart
  data first /.true./

  if (func == '%MODE') {
    if (trim(keystrokes) == 'CONTROL')
      mode = CONTROL_MODE
    else if (trim(keystrokes) == 'INSERT')
      mode = INSERT_MODE
    else if (trim(keystrokes) == 'OVERSTRIKE')
      mode = OVERSTRIKE_MODE
    else if (trim(keystrokes) == 'PROMPT')
      mode = PROMPT_MODE
    else if (trim(keystrokes) == 'CHANGE')
      mode = CHANGE_MODE
    else if (trim(keystrokes) == 'SEQ')
      mode = SEQ_MODE
    else if (trim(keystrokes) == 'CALC')
      mode = CALC_MODE
    else {
      lk = len(keystrokes) - 1
      decode(lk, (i<lk>), keystrokes(1:kl), err=5) mode
      if (mode < 0 | mode >= NUM_MODES) {
5	write(6, (' Illegal mode: ',a)) trim(keystrokes)
	error = .true.
	mode = -1
	}
      }
    if (mode != -1) {
      if (bi_modes(mode) == null) {
	bi_modes(mode) = bi_allocate(128)
	if (mode == INSERT_MODE)
	  bi_mem(bi_modes(mode)) = - 2		# QIO error while in INSERTMODE
	else
	  bi_mem(bi_modes(mode)) = - 1		# QIO error while in other mode
	bi_mem(bi_modes(mode) + 8%31) = - 3	# function for ^Y interrupt
	}
      call bi_use_keymap(mode)
      }
    }
  else if (func == '%KEYPAD') {
    if (trim(keystrokes) == 'NUMERIC')
      bi_keypad = KEYPAD_NUMERIC
    else if (trim(keystrokes) == 'APPLICATION')
      bi_keypad = KEYPAD_APPLICATION
    else {
      write(6, (' Illegal keypad mode: ',a)) trim(keystrokes)
      error = .true.
      }
    }
  else if (func == '%INCLUDE') {
    inlun = inlun + 1
    open(unit=inlun, name=trim(keystrokes), defaultfile='.bnd',
		      type='old', readonly, err=99)
    }
  else if (func == '%RESTART') {
    restart = .true.
    }
  else if (func == '%ALTERNATE_ESCAPE') {
    c = ichar(keystrokes(1:1))
    if (c <= 0 | len(keystrokes) != 2) {
      write(6, (' Illegal alternate escape character: ',a)) trim(keystrokes)
      error = .true.
      }
    else
      bi_alternate_escape = c
    }
  else if (funcnum != 0) {
    if (funcnum >= 1000)			# mode or macro function
      call bi_bind_to_key(funcnum, %ref(keystrokes))
    else
      call bi_bind_to_key(funcnum + 3, %ref(keystrokes))
    }
  else {
    if (first) {
      first = .false.
      i = 1
      for (nfunc = 0; ; ) {
	if (nfunc >= 500)
	  stop "too many functions"
	read(3,(a),end=8) funcs(nfunc+1)
	funcn(nfunc+1) = i + 3
	i = i + 1
	if (funcs(nfunc+1) == ' ')			# restart?
	  i = 1
	else
	  nfunc = nfunc + 1
	}
8     continue
      }
    for (i = 1; i <= nfunc; i = i + 1)
      if (funcs(i) == func)
	break
    if (i > nfunc) {
      write(6,(' Unrecognized function: ',a)) func
      error = .true.
      }
    else
      call bi_bind_to_key(funcn(i), %ref(keystrokes))
    }
  return
99
  write(6,(' Can''t open ',a)) trim(keystrokes)
  call exit(16%10000002)
  end

  subroutine write_block_data
  header
  integer*2 bi_stuff(1),bi_mem_extend(BI_MEM_SIZE)
  equivalence (bi_stuff,bi_mode),
	      (bi_mem_extend, bi_mem)

  bi_max = bi_free - 1
  common_size = (%loc(bi_mem(bi_free)) - %loc(bi_stuff))/2
  if (bi_free == 1) {
    common_size = common_size + 1		# For null binding files
    bi_mem(1) = 0
    }
  write(2, ('      block data bi_data'))
  write(2, ('      common /bind/ bi_stuff(',i10,')')) common_size
  write(2, ('      integer*2 bi_stuff'))
  do i = 1, common_size
    write(2, ('      data bi_stuff(',i10,') /',i10,'/')) i, bi_stuff(i)
  write(2, ('      end'))
  close(unit=2)
  return
  end

  byte function get_tty_character

  stop 'Huh?'
  end

  subroutine ms_report_number(s1, n, s2)
  implicit integer (a - z)
  byte s1(1), s2(1), buf(132)

  call ho_scopy(s1, 1, buf, 1)
  lb = ho_length(buf)
  lb = lb + ho_itoc(n, buf(lb+1), 132-lb)
  call ho_scopy(s2, 1, buf, lb+1)
  lb = ho_length(buf)
  write(6,(' ',<lb>a1)) (buf(i),i=1,lb)
  return
  end

  subroutine ms_error(s1)
  header
  byte s1(1)

  error = .true.
  lb = ho_length(s1)
  if (lb > 0)
    write(6,(' ',<lb>a1)) (s1(i),i=1,lb)
  return
  end

  subroutine copy(s1, s1len, s2, s2len)
  integer s1len, s2len
  byte s1(1), s2(1)

  do i = 1, s1len {
    s2len = s2len + 1
    s2(s2len) = s1(i)
    }
  return
  end

define(dellb,{ if ($1 != ' ') while ($1(1:1) == ' ') $1 = $1(2:) })
  logical function parse(line, out)
  implicit integer (a-z)
  character*(*) line, out

  dellb(line)
  if (line == ' ')
    return(.false.)
  if (line(1:1) == '/') {
    idxsl = index(line(2:), '/')
    if (idxsl > 0)
      idxsl = idxsl + 1
    idxs = index(line, ' ')
    if ((idxs > idxsl | idxs == 0) & idxsl != 0)
      idxs = idxsl
    }
  else {
    idxc = index(line, ',')
    if (idxc != 0)
      line(idxc:idxc) = ' '
    idxs = index(line, ' ')
    }
  if (idxs == 0)
    idxs = len(line) + 1
  out = line(1:idxs-1)
  if (idxs > len(line))
    line = ' '
  else
    line = line(idxs:)
  return(.true.)
  end
$eod
$ create VT.BND
$deck
  # Zilch Screen Editor, Copyright (c) 1982,1983,1984,1986 William P. Wood, Jr.
  # Extra keyboard bindings for VT100/VT200/VTxxx Zilch

%keypad					application
%alternate_escape			^C

%mode					insert
exit_insert_mode_without_popping_mappings	^S^[
exit_insert_mode			`
exit_insert_mode			^C[23~		# F11 (ESC)
macro_x					^C[2~		# Insert Here
	^[~						# switch to overstrike
in_next_character			^C[\C
in_previous_character			^C[\D
in_previous_character			^C[24~		# F12 (BS)
in_next_line				^C[\B
in_next_line				^C[25~		# F13 (LF)
in_previous_line			^C[\A
macro_0					^C\O\P		# PF1
	^S^[\\^M					# find previous
macro_1					^C\O\Q		# PF2
	^S^[/^M						# find next
macro_2					^C\O\R		# PF3
	^S^[>o<^D^Sm^M^[				# delete previous word
macro_3					^C\O\S		# PF4
	^S^[<p>^D^Sm^M^[				# delete next word
macro_4					^C[5~		# PREV_SCREEN
	^S^[wty
macro_5					^C[6~		# NEXT_SCREEN
	^S^[wtn
macro_6					^C\O\m		# (keypad) -
	^S^[^Sd^[					# delete to end of line
macro_7					^C\O\l		# (keypad) ,
	^S^[^S\177^[					# delete next character
macro_7					^C[3~		# REMOVE
macro_10						# unbound
	^S^[/<%^Mhh</%>^M>^E^[				# insert into template

%mode					control
exit_insert_mode_without_popping_mappings	^S^[
message					^Sm
delete_next_character			^S\177
kill_to_end_of_line			^Sd
enter_insert_mode			`
enter_insert_mode			^C[23~		# F11 (ESC)
enter_insert_mode			^C[2~		# Insert Here
next_character				^C[\C
previous_character			^C[\D
previous_character			^C[24~		# F12 (BS)
next_line				^C[\B
scroll_one_line_up			^C[25~		# F13 (LF)
previous_line				^C[\A
help					^C[28~		# Help
macro_0					^C\O\P		# PF1
macro_1					^C\O\Q		# PF2
macro_2					^C\O\R		# PF3
macro_3					^C\O\S		# PF4
macro_4					^C[5~		# PREV_SCREEN
macro_5					^C[6~		# NEXT_SCREEN
macro_6					^C\O\m		# (keypad) -
macro_7					^C\O\l		# (keypad) ,
macro_7					^C[3~		# REMOVE
udk_0					^C\O\p		# (keypad) 0
udk_replace_0				^C\O\n^C\O\p	# (keypad) . (keypad) 0
udk_1					^C\O\q		# (keypad) 1
udk_replace_1				^C\O\n^C\O\q	# (keypad) . (keypad) 1
udk_2					^C\O\r		# (keypad) 2
udk_replace_2				^C\O\n^C\O\r	# (keypad) . (keypad) 2
udk_3					^C\O\s		# (keypad) 3
udk_replace_3				^C\O\n^C\O\s	# (keypad) . (keypad) 3
udk_4					^C\O\t		# (keypad) 4
udk_replace_4				^C\O\n^C\O\t	# (keypad) . (keypad) 4
udk_5					^C\O\u		# (keypad) 5
udk_replace_5				^C\O\n^C\O\u	# (keypad) . (keypad) 5
udk_6					^C\O\v		# (keypad) 6
udk_replace_6				^C\O\n^C\O\v	# (keypad) . (keypad) 6
udk_7					^C\O\w		# (keypad) 7
udk_replace_7				^C\O\n^C\O\w	# (keypad) . (keypad) 7
udk_8					^C\O\x		# (keypad) 8
udk_replace_8				^C\O\n^C\O\x	# (keypad) . (keypad) 8
udk_9					^C\O\y		# (keypad) 9
udk_replace_9				^C\O\n^C\O\y	# (keypad) . (keypad) 9

%mode					overstrike
exit_overstrike_mode			^S^[
exit_overstrike_mode			`
exit_overstrike_mode			^C[23~		# F11 (ESC)
macro_x					^C[2~		# Insert Here
	^[^[						# switch to insert
next_character				^C[\C
previous_character			^C[\D
previous_character			^C[24~		# F12 (BS)
next_line_and_hug_column		^C[\B
next_line_and_hug_column		^C[25~		# F13 (LF)
previous_line_and_hug_column		^C[\A
macro_0					^C\O\P		# PF1
macro_1					^C\O\Q		# PF2
macro_x					^C\O\R		# PF3
	^[>o<^D^Sm^M~					# delete previous word
macro_x					^C\O\S		# PF4
	^[<p>^D^Sm^M~					# delete next word
macro_4					^C[5~		# PREV_SCREEN
macro_5					^C[6~		# NEXT_SCREEN
kill_to_end_of_line			^C\O\m		# Keypad -
delete_next_character			^C\O\l		# Keypad ,
delete_next_character			^C[3~		# REMOVE

%mode					prompt
pr_previous_line			^C[\A		# Up-Arrow
pr_next_line				^C[\B		# Down-Arrow
pr_previous_character			^C[\D		# Left-Arrow
pr_next_character			^C[\C		# Right-Arrow
pr_beginning_of_line			^C[24~		# F12

%mode					control
$eod
$ create ZBIND.BND
$deck
  # Zilch Screen Editor, Copyright (c) 1982,1983,1984,1986 William P. Wood, Jr.
  # Keyboard bindings and function definitions for standard Zilch

%keypad					numeric		# {numeric,application}
%include				[]key.bnd	# standard bindings

%restart						# prompt subroutines
%include				[]prompt.bnd

%restart						# change subroutines
%include				[]change.bnd

%restart						# calc subroutines
%include				[]calc.bnd

%include				[]vt.bnd	# VTxxx bindings

%mode					control
$eod
$ create zilchbind.bnd
$deck
# This is a dummy bindings file for linking Zilch only.
$eod
