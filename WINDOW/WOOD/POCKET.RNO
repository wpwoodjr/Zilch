_macro(.command,.indent -4;.bold(_substr($&,1,_arith(_index($&,	),-,1)))_
_substr($&,_index($&,	)))
_macro(.heading,.skip 2;.lm -4;.bold($&)
.lm +4;.skip 1)
_macro(.bold,^*$&\*)
.page size 1000,_width
.tab stops 4
.flags bold
.lm 4
.rm _width
.center;.bold(Z#i#l#c#h)
.center;.bold(Pocket Reference)
.skip 2
.center;.bold(C#o#n#t#r#o#l##M#o#d#e)
.skip 1;.lm -4
.bold(Functions to position the cursor:)
.lm +4;.skip 1
.command(H	Go back one character.)
.command(L	Go forward one character.)
.command(K	Go up one line.)
.command(J	Go down one line.)
.command(_^J	Scroll up one line.)
.command(_^K	Scroll down one line.)
.command(I	Go up one line but stay in same column.)
.command(U	Go down one line but stay in same column.)
.command(G	Go up half the window length.)
.command(B	Go down half the window length.)
.command(Y	Go up by the number of lines in the window minus one.)
.command(N	If not in top line`,` bring current line to the top of the
window.  If at top`,` bring bottom line to the top
of the window.)
.command(M	Go to beginning of line if not at beginning`,`
else go to end of line.)
.command(O	Go back one word.)
.command(P	Go forward one word.)
.command(T	Go to top of file.)
.command(E	Go to last lines of file.)
.command(F	Go back to last subprogram. Behavior depends on
language as determined by file's extension or the WM command.)
.command(V	Go forward to next subprogram. Behavior depends on
language as determined by file's extension or the WM command.)
.command(WT	Go to top of window.)
.command(/	Search forward.)
.command(_\	Search backward.)
.command(=	Save current location.)
.command(_^	Go to saved location.)
.command(_*	Go to saved location and save current location.)
.heading(Functions to change mode:)
.command(DCL	Allows access to VMS commands without leaving the
editor. Type "logo" to exit DCL.)
.command(<ESC>	Changes mode from insert mode to control mode and
back again.)
.command(<CR>	Exits editor`,` but asks if you wish to save files.)
.command(_^Z	Saves all modified files and exits editor.)
.heading(Editing functions:)
.command(C	Change one character string to another.)
.command(_^U	Delete from cursor to beginning of next line.)
.command(_^R	Restore text deleted by _^U.)
.command(<	Mark beginning of specified text.)
.command(>	Mark end of specified text.)
.command(S	Save specified text.)
.command(_^A	Add saved text at current location.)
.command(_^D	Delete specified text.)
.command(_^E	Extract (save then delete) specified text.)
.command(X_^	Change the case of specified text to the case
of the current buffer.)
.heading(Functions affecting files`,` windows`,` and buffers:)
.command(WV	Create a new window for a file.)
.command(WC	Use current window to display another file instead of the
current file.)
.command(WB	Create a new window for a buffer.)
.command(WX	Use current window to display another buffer instead of the
current buffer.)
.command(WH	Split the current window into two windows.)
.command(WD	Delete current window.)
.command(WO	Delete all other windows on the screen.)
.command(WP	Move to previous window.)
.command(WN	Move to next window.)
.command(WE	Expand current window size by one line.)
.command(WS	Shrink current window size by one line.)
.command(WF	Expand current window size as much as possible.)
.command(WQ	Equalize size of all windows.)
.command(WR	Read a file into current window (and replace data
already there).)
.command(WA	Write back all modified files.)
.command(WW	Write text to a new file name.)
.command(_^T	Write the current file.)
.command(WL	List all buffers and files.)
.command(W_^	Toggle the case of the current buffer.)
.command(WM	Change the mapping type of the current buffer.)
.heading(Functions affecting pages:)
.command(_#	Switch to page.  If the page has never been used`,`
it is initialized with the windows of the
current page.)
.command(-	Switch to previous page.)
.command(+	Advance to next page.)
.heading(Miscellaneous functions:)
.command(R	Redraw screen.)
.command([	Start "remembering" keystrokes.)
.command(]	Stop "remembering" keystrokes.)
.command(XM	Execute "remembered" keystrokes.)
.command(?	List help buffer.)
.command(_^V	Move line left by 2.)
.command(_^B	Move line right by two.)
.command(_^I	Set initial tab stop to current line's first non-blank
position.)
.command(XDCL	Execute a VMS DCL command and display the results
in a window.)
.command(n	("n" is a number.) Repeat next command n times.)
.command(_^G	Abort command or prompt entry.)
.command(_^C	Abort XM command or repeating commands.)
.skip 2
.center;.bold(I#n#s#e#r#t##M#o#d#e)
.skip 1;.lm -4
.bold(Functions to change mode:)
.lm +4;.skip 1
.command(<ESC>	Changes mode from insert mode to control mode and
back again.)
.command(_^Z	Exits insert mode without popping mapping characters.)
.heading(Miscellaneous functions:)
.command(<CR>	End current line and start a new one.)
.command(<DEL>	Delete previous character.)
.command(_^U	Delete through beginning of current line.)
.command(_^R	Restore text deleted by _^U.)
.command(_^A	Add saved text.)
.command(_^H	Go back one character.)
.command(_^L	Go forward one character.)
.command(_^K	Go up one line.)
.command(_^J	Go down one line.)
.command(_^P	Go forward one word.)
.command(_^I	Tab to initial tab stop if before it`,` else tab
to next eighth character position.)
.command(_^W	Move initial tab stop left by 2.)
.command(_^E	Move initial tab stop right by 2.)
.command(_^D	Set initial tab stop to current cursor position.)
.command(_\	Start mapping sequence.)
.command(_\{	Insert comment.  Behavior depends on
language as determined by file's extension
or the WM command.)
.command(_\[	Make structured block.  Behavior depends on
language as determined by file's
extension or the WM command.)
.command(_\<DEL>	Delete the mapping sequence begun by the last _\
  command.)
.skip 2
.lm 2
.center;.bold(C#o#m#m#a#n#d##L#i#n#e)
.center;.bold(S#w#i#t#c#h#e#s)
.skip 1
.indent -2
.bold(/Restore=file-spec)
.break
Names a file from which Zilch restores a previous editing
session if no files were specified on the command line.
.comment By default, Zilch is defined in the system login command file
.comment to save
.comment and restore sessions from 'username'.zil where 'username'
.comment is the first 9 letters of the currently logged in user's name.

.skip
.indent -2
.bold(/Save=file-spec)
.break
Names a file in which Zilch saves the current editing
session when it exits.
.comment By default, Zilch is defined in the system login command file
.comment to save
.comment and restore sessions from 'username'.zil where 'username'
.comment is the first 9 letters of the currently logged in user's name.

.skip
.indent -2
.bold(/Help=file-spec)
.break
Names a file which Zilch displays during the "?" help command.
.comment By default, Zilch is defined in the system login command file
.comment to read SYS$PUBLIC:ZHELP.

.skip
.indent -2
.bold(/Initialize=file-spec)
.break
Names a file containing Zilch keyboard commands
which are executed before control is given to the terminal.
.comment There is no default initialization file.

.skip
.indent -2
.bold(/Terminal=term)
.break
Overrides Zilch's default selection of terminal type.
.comment By default Zilch assumes your terminal is a VT100 or VT52
.comment if the system terminal type (as displayed by the SHOW TERMINAL command)
.comment is VT100 or VT52, respectively.
.comment Otherwise Zilch assumes your terminal is an ADM3A.
.comment To use an ADM5, /TERM=ADM5 should be specified on Zilch's command
.comment line, or the DCL command "Z5" may be used.
"term" may be one of: VT100, VT52, ADM3A, or ADM5.

.skip
.indent -2
.bold(/Length=n)
.break
Specifies the screen length of the terminal.
.comment 24 lines is the default length.
.comment The following terminals accept
.comment the following lengths:

.skip
.indent -2
.bold(/Width=n)
.break
Specifies the width of the terminal.
.comment 80 columns is the default width.
.comment The following terminals accept
.comment the following widths:

.skip
.indent -2
.bold(/INDent=n)
.break
Specifies the incremental indent.
.comment Two columns is the default incremental indent.

.skip
.indent -2
.bold(/CAse=case)
.break
Sets the default initial case for buffers.
"case" may be UPPER or LOWER.
.comment If the /CAse switch isn't specified,
.comment Zilch uses LOWER as the initial case, which allows
.comment insertion of upper or lower case characters in the buffer.

.skip
.indent -2
.bold(/FORMAP=file-spec)
.break
Names a file which contains mapping characters for Fortran
programs.
.comment By default, Zilch is defined in the system login command file
.comment to read SYS$PUBLIC:FORMAP.

.skip
.indent -2
.bold(/PASMAP=file-spec)
.break
Names a file which contains mapping characters for Pascal
programs.
.comment By default, Zilch is defined in the system login command file
.comment to read SYS$PUBLIC:PASMAP.

.skip
.indent -2
.bold(/RATMAP=file-spec)
.break
Names a file which contains mapping characters for Ratfiv
programs.
.comment By default, Zilch is defined in the system login command file
.comment to read SYS$PUBLIC:RATMAP.

.skip
.indent -2
.bold(/TEXTMAP=file-spec)
.break
Names a file which contains mapping characters for text files.
.comment By default, Zilch is defined in the system login command file
.comment to read SYS$PUBLIC:RNOMAP.

.lm 0
.tab stops 8
.no fill
.skip 2
.bold(Pascal Mapping Characters:)
.skip 1
.bold([)	BEGIN
	  END (_* _<structure_> _*);
.bold(A)	READ
.bold(B)	WRITE
.bold(C)	CASE ... OF
	  END (_* CASE _*);
.bold(D)	DOWNTO
.bold(E)	ELSE
.bold(F)	FOR ... DO
.bold(G)	PROCEDURE ... EXTERN;
.bold(H)	FUNCTION ... EXTERN;
.bold(I)	IF ... THEN
.bold(J)	ELSE IF ... THEN
.bold(M)	MODULE
	END (_*_* MODULE _*_*).
.bold(P)	PACKED
.bold(R)	REPEAT
	  UNTIL
.bold(T)	TO
.bold(V)	WITH ... DO
.bold(W)	WHILE ... DO
.bold(X)	PROGRAM
	BEGIN (_* PROGRAM _*)
	END (_*_* PROGRAM _*_*).
.bold(Y)	PROCEDURE
	BEGIN (_* PROC _*)
	END (_*_* PROC _*_*);
.bold(Z)	FUNCTION
	BEGIN (_* FUNC _*)
	END (_*_* FUNC _*_*);
.bold(0)	RECORD
	  END (_* RECORD _*);
.bold(1)	CONST
.bold(2)	TYPE
.bold(3)	VAR
.bold(4)	: INTEGER;
.bold(5)	: BOOLEAN;
.bold(6)	: CHAR;
.bold(7)	ARRAY [...] OF
.bold(8)	: REAL;
.bold(9)	: SET OF
.bold(/)	DIV
.bold({)	(_* ... _*)
.bold(@)	%INCLUDE '
.bold(=)	=
.bold(`,`)	_<
.bold(_<)	_<=
.bold(_.)	_>
.bold(_>)	_>=
.bold(_#)	_<_>
.bold(_<space_>)	=
.bold(:)	:=
.bold(;)	:=
.bold(_<tab_>)	_<tab_>
.skip 2
.bold(Fortran Mapping Characters:)
.skip 1
.bold(A)	ACCEPT
.bold(B)	BYTE
.bold(C)	CONTINUE
.bold(D)	DO
.bold(E)	ELSE
.bold(F)	FORMAT (
.bold(G)	GO TO
.bold(H)	COMMON /
.bold(I)	IF ( ... THEN
	  ENDIF
.bold(1)	CHARACTER_*
.bold(2)	INTEGER_*2
.bold(4)	INTEGER_*4
.bold(8)	REAL_*8
.bold(6)	REAL_*16
.bold(J)	DIMENSION
.bold(K)	CALL
.bold(L)	LOGICAL
.bold(M)	END
.bold(N)	FUNCTION
.bold(O)	READ (
.bold(P)	PARAMETER
.bold(Q)	IF (
.bold(R)	RETURN
.bold(S)	SUBROUTINE
.bold(T)	TYPE
.bold(U)	REAL
.bold(W)	WRITE (
.bold(X)	DO WHILE (
	  ENDDO
.bold(Z)	ELSE IF ( ... THEN
.bold(=)	EQUIVALENCE (
.bold(-)	IMPLICIT INTEGER_*4 (A - Z)
.bold(`(`)	OPEN (UNIT=
.bold(`)`)	CLOSE (UNIT=
.bold({)	_!
.bold(@)	INCLUDE '
.bold(_<space_>)	=
.bold(_<tab_>)	_<tab_>
.skip 2
.bold(Ratfiv Mapping Characters:)
.skip 1
.bold([)	{
	  }
.bold(A)	ACCEPT
.bold(B)	BYTE
.bold(C)	CONTINUE
.bold(D)	DO
.bold(E)	ELSE
.bold(F)	FOR (
.bold(G)	GOTO
.bold(H)	COMMON /
.bold(I)	IF (
.bold(1)	CHARACTER_*
.bold(2)	INTEGER_*2
.bold(4)	INTEGER_*4
.bold(8)	REAL_*8
.bold(6)	REAL_*16
.bold(J)	DIMENSION
.bold(K)	CALL
.bold(L)	LOGICAL
.bold(M)	END
.bold(N)	FUNCTION
.bold(O)	READ (
.bold(P)	PARAMETER
.bold(Q)	SWITCH ( ... {
	  }
.bold(R)	RETURN
.bold(S)	SUBROUTINE
.bold(T)	TYPE
.bold(U)	REAL
.bold(W)	WRITE (
.bold(X)	WHILE (
.bold(Z)	ELSE IF (
.bold(=)	EQUIVALENCE (
.bold(-)	IMPLICIT INTEGER_*4 (A - Z)
.bold(`(`)	OPEN (UNIT =
.bold(`)`)	CLOSE (UNIT =
.bold(@)	INCLUDE "
.bold({)	_#
.bold(_<space_>)	=
.bold(_<tab_>)	_<tab_>
.skip 2
.bold(Runoff Mapping Characters:)
.skip 1
.bold(C)	.CENTER;
.bold(P)	.PARAGRAPH
.bold(S)	.SKIP
.bold(H)	.HEADER LEVEL
.bold(L)	.LIST
	.END LIST
.bold(E)	.LE;
.bold(G)	.PAGE
.bold(B)	.BREAK
.bold(I)	.INDENT
.bold(M)	.LEFT MARGIN
.bold(R)	.RIGHT MARGIN
.bold(N)	.NOTE
	.END NOTE
.bold(F)	.FOOTNOTE
	.END FOOTNOTE
.bold(T)	.TEST PAGE
.bold(K)	.BLANK
.bold(X)	.INDEX
.bold(Y)	.ENTRY
.bold(Z)	.PAGE SIZE
.bold(_>)	_\_\ ... _^_^
.bold(_<)	_^_< ... _^_^
.bold(_*)	_^_* ... _\_*
.bold(_&)	_^_& ... _\_&
.bold(__)	.LITERAL
	.END LITERAL
.bold(_<tab_>)	.TAB STOPS
.bold(_<space_>)	.SPACING
.bold({)	_!
.bold(@)	.REQUIRE "
